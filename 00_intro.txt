:next_link: 01_values
:load_files: ["code/intro.js"]

= Введение =

Это книга рассказывает, как заставить компьютеры делать то, что вам от них нужно. Компьютеры сегодня так же распространены, как отвёртки – но содержат гораздо больше скрытых сложностей, и поэтому их сложнее понять и с ними сложнее работать. Для многих они остаются чуждыми, слегка угрожающими штуками.

image::img/generated/computer.png[alt="Communicating with a computer"]

Мы обнаружили два эффективных способа уменьшить коммуникационный разрыв между нами – водянистыми биологическими организмами, у которых есть талант к социальным связям и пространным рассуждениям, и компьютерами – бесчувственными манипуляторами, работающими с бессмысленными данными. Первый – обратиться к нашему ощущению физического мира, и строить интерфейсы, имитирующие его, чтобы мы могли при помощи пальцев манипулировать формами на экране. Для простого взаимодействия с компьютером это неплохо подходит.

Но мы не нашли хороший способ передавать компьютеру при помощи перемещений и нажатий мышью те вещи, которые дизайнер интерфейса не предусмотрел. Для того, чтобы взаимодействовать с компьютером на более сложных уровнях, например задавать ему произвольные задачи на выполнение, лучше подходит наш талант к общению: мы обучаем компьютер языку.

Человеческие языки позволяют комбинировать слова великим множеством способов, так, что мы можем сказать очень много разных вещей. Компьютерные языки устроены примерно так же, хотя и менее гибки грамматически.

За последние 20 лет работа с компьютером стала очень распространённым явлением, и интерфейсы, построенные на языке (а когда-то это был единственный способ общения с компьютером) почти вытеснены графическими. Но они всё ещё есть – если вы знаете, где их искать. Один из таких языков, JavaScript, встроен почти в любой веб-браузер, и потому доступен почти на каждом вычислительном устройстве.

Эта книга ставит целью познакомить вас с этим языком достаточно для того, чтобы вы могли заставить компьютер делать то, что вам нужно.

== О программировании ==

[quote, Конфуций]
____
(((Конфуций)))Я не просвещаю тех, кто не жаждет учиться, и не побуждаю тех, кто не хочет искать ответы самостоятельно. Если я покажу один угол квадрата, и они не приходят ко мне с остальными тремя – мне не нужно давать повторных объяснений.
____

Кроме объяснения JavaScript я также хочу объяснить основные принципы программирования. Как выясняется, программировать тяжело. Обычно базовые принципы просты и понятны. Но программы, построенные на этих принципах, становятся сложными настолько, что вводят свои собственные правила и уровни сложности. Вы строите свой собственный лабиринт, и можете в нём потеряться.

Возможно, временами чтение будет разочаровывать вас. Если вы новичок в программировании, вам нужно будет много чего переварить. Много материала будет _скомбинировано_ таким образом, что вам нужно будет установить новые связи между его частями.

Вы сами должны обосновать необходимость этих усилий. Если вам тяжело продираться через книгу, не нужно думать о себе плохо. С вами всё в порядке – вам нужно просто продолжать движение. Сделайте перерыв, вернитесь назад – и _всегда_ удостоверяйтесь, что вы прочли и поняли примеры программ. Обучение – это сложная работа, но раз вы что-то выучили, оно уже принадлежит вам, и облегчает дальнейшие шаги.

[quote, Джозеф Вайзенбаум, Сила Компьютеров и Разум Людей]
____
Программист создаёт вселенные, за которые он один в ответе. В компьютерных программах могут быть созданы вселенные практически неограниченной сложности.
____

Программа – сложное понятие. Это кусок текста, набранный программистом, это направляющая сила, заставляющая компьютер что-то делать, это данные в памяти компьютера, и при этом она контролирует работу с этой же самой памятью. Аналогии, которые пытаются сравнивать программы со знакомыми нам объектами обычно не справляются с этим. Одна более-менее подходящая – аналогия с машиной. Множество отдельных частей составляют одно целое, и чтобы заставить её работать, нам нужно представлять себе способы, которыми эти части взаимодействуют и что они привносят в работу целой машины.

Компьютер – это машина, которая устроена так, чтобы содержать в себе эти нематериальные машинки. Компьютеры сами по себе могут выполнять только простые действия. Польза их в том, что они могут делать это очень быстро. Программа может очень хитрым образом комбинировать эти действия так, чтобы в результате выполнялись очень сложные действия.

Для некоторых из нас программирование – это увлекательная игра. Программа – это мысленная конструкция. Ничего не стоит её построить, она ничего не весит, и она легко вырастает под нашими пальцами.

Если не быть осторожным, размер и сложность выходят из-под контроля, запутывая даже того, кто её пишет. Это основная проблема программирования: сохранять контроль над программами. Когда программа работает – это прекрасно. Искусство программирования – это умение контролировать сложность. Большая программа находится под контролем, и выполнена просто в своей сложности.

Многие программисты верят, что этой сложностью лучше всего управлять, используя в программах небольшой набор хорошо известных техник. Они описали строгие правила («наилучшие практики») того, какую форму программы должны иметь. И самые ревностные среди них считают тех, кто отклоняется от этих практик, _плохими_ программистами.

Что за враждебность по отношению к богатству программирования – попытки принизить его до чего-то прямолинейного и предсказуемого, наложить табу на всякие странные и прекрасные программы! Ландшафт техник программирования огромен, увлекателен своим разнообразием, и до сих пор изучен мало. Это опасное путешествие, заманивающее и запутывающее неопытного программиста, но это всего лишь означает, что вы должны следовать этим путём осторожно и думать головой. По мере обучения вам всегда будут встречаться новые задачи и новые неизведанные территории. Программисты, не изучающие новое, стагнируют, забывают свою радость, их работа наскучивает им.

== Почему язык имеет значение ==

В начале, при зарождении компьютерных дисциплин, не было языков программирования. Программы выглядели так:

----
00110001 00000000 00000000
00110001 00000001 00000001
00110011 00000001 00000010
01010001 00001011 00000010
00100010 00000010 00001000
01000011 00000001 00000000
01000001 00000001 00000001
00010000 00000010 00000000
01100010 00000000 00000000
----

Это программа, складывающая числа от 1 до 10, и выводящая результат `1 + 2 + ... + 10 = 55`. Она может выполняться на очень простой гипотетической машине. Для программирования первых компьютеров было необходимо устанавливать большие массивы переключателей в нужные позиции, или пробивать дырки в перфокартах и скармливать их компьютеру. Можете представить, какая это была утомительная, подверженная ошибкам процедура. Написание даже простых программ требовало большого ума и дисциплины. Сложные программы были практически немыслимы.

Конечно, ручной ввод этих мистических диаграмм бит (нулей и единиц) давал программисту возможность ощутить себя волшебником. И это чего-то стоило в смысле удовлетворения работой.

Каждая строка указанной программы содержит одну инструкцию. На обычном языке их можно описать так:

[source,text/plain]
----
1. Записать число 0 в ячейку памяти 0.
2. Записать число 1 в ячейку памяти 1.
3. Записать значение ячейки 1 в ячейку 2.
4. Вычесть 11 из значения ячейки 2.
5. Если у ячейке 2 значение 0,
   тогда продолжить с пункта 9.
6. Добавить значение ячейки 1 к ячейке 0.
7. Добавить число 1 к ячейке 1.
8. Продолжить с пункта 3.
9. Вывести значение ячейки 0.
----

Этот вариант легче прочесть, чем кучу бит, но он всё равно не очень удобен. Использование имён вместо номеров инструкций и ячеек памяти может улучшить понимание.

[source,text/plain]
----
 Установить “total” в 0.
 Установить “count” в 1.
[loop]
 Установить “compare” в “count”.
 Вычесть 11 из “compare”.
 Если “compare” равно нулю, перейти на [end].
 Добавить “count” в “total”.
 Добавить 1 к “count”.
 Перейти на [loop].
[end]
 Вывести “total”.
----

Вот теперь уже не так сложно понять, как работает программа. Справитесь? Первые две строки назначают двум областям памяти начальные значения. `total` будет использоваться для подсчёта результата вычисления, а `count` будет следить за числом, с которым мы работаем в данный момент. Строчки, использующие `compare`, наверно, самые странные. Программе нужно понять, не равно ли `count` 11, чтобы прекратить подсчёт. Так как наша воображаемая машина довольно примитивна, она может только выполнить проверку на равенство переменной нулю, и принять решение о том, надо ли перепрыгнуть на другую строку. Поэтому она использует область памяти под названием `compare`, чтобы подсчитать значение `count – 11` и принять решение на основании этого значения. Следующее две строки добавляют значение `count` в счётчик результата и увеличивают `count` на 1 каждый раз, когда программа решает, что ещё не достигла значения 11.

Вот та же программа на JavaScript:

[source,javascript]
----
var total = 0, count = 1;
while (count <= 10) {
  total += count;
  count += 1;
}
console.log(total);
// → 55
----

Ещё несколько улучшений. Главное – нет необходимости вручную обозначать переходы между строками. Конструкция языка `while` делает это сама. Она продолжает вычислять блок, заключённый в фигурные скобки, пока условие `count <= 10` выполняется, то есть “значение ++count++ меньше или равно 10“. Уже не нужно создавать временное значение и сравнивать его с нулём. Это было скучно, и сила языков программирования в том, что они помогают избавиться от скучных деталей.

В конце программы по завершению `while` к результату применяется операция `console.log` с целью вывода.

И наконец, вот так могла бы выглядеть программа, если б у нас были удобные операции `range` и `sum`, которые, соответственно, создавали бы набор чисел в заданном промежутке и подсчитывали его сумму:

// start_code

[source,javascript]
----
console.log(sum(range(1, 10)));
// → 55
----

Мораль сей басни – одна и та же программа может быть написана и долго, и коротко, читаемо и нечитаемо. Первая версия программы была совершенно смутной, а последняя – почти настоящий язык – записать сумму диапазона чисел от 1 до 10. В link:04_data.html#data[следующих главах] мы рассмотрим, как делать такие вещи.

Хороший язык программирования помогает программисту сообщать компьютеру о необходимых операциях на высоком уровне. Позволяет опускать скучные детали, даёт удобные строительные блоки (`while` и `console.log`), позволяет создавать свои собственные блоки (`sum` и `range`), и делает простым комбинирование блоков.

== Что такое JavaScript? ==

JavaScript был представлен в 1995 году как способ добавлять программы на веб-страницы в браузере Netscape Navigator. С тех пор язык прижился во всех основных графических браузерах. Он дал возможность появиться современным веб-приложениям – браузерные е-мейл-клиенты, карты, социальные сети. А ещё он используется на более традиционных сайтах для обеспечения интерактивности и всяких наворотов.

Важно отметить, что JavaScript практически не имеет отношения к другому языку под названием Java. Похожее имя было выбрано из маркетинговых соображений. Когда появился JavaScript, язык Java широко рекламировался и набирал популярность. Кое-кто решил, что неплохо бы прицепиться к этому паровозу. А теперь мы уже никуда не денемся от этого имени.

После того, как язык вышел за пределы Netscape, был составлен документ, описывающий работу языка, чтобы разные программы, заявляющие о его поддержке, работали одинаково. Он называется стандарт ECMAScript по имени организации ECMA. На практике можно говорить о ECMAScript и JavaScript как об одном и том же.

Многие ругают JavaScript и говорят о нём много _плохого_. И многое из этого – правда. Когда мне первый раз пришлось писать программу на JavaScript, я быстро почувствовал отвращение – язык принимал практически всё, что я писал, при этом интерпретировал это вовсе не так, как я подразумевал. В основном это было из-за того, что я не имел понятия о том, что делаю, но тут есть и проблема: JavaScript слишком либерален. Задумывалось это как облегчение программирования для начинающих. В реальности, это затрудняет розыск проблем в программе, потому что система о них не сообщает.

Гибкость имеет свои преимущества. Она оставляет место для разных техник, невозможных в более строгих языках. Иногда, как мы увидим в link:10_modules.html#modules[Главе 10], её можно использовать для преодоления некоторых недостатков языка. После того, как я по настоящему изучил и поработал с ним, я научился _любить_ JavaScript.

Вышло уже несколько версий языка JavaScript. ECMAScript 3 была доминирующей, распространённой версией во время подъёма языка, примерно с 2000 до 2010. В это время готовилась амбициозная 4-я версия, в которой было запланировано несколько радикальных улучшений и расширений языка. Однако политические причины сделали изменение живого популярного языка очень сложным, и работа над 4-й версией была прекращена в 2008. Вместо неё вышла менее амбициозная 5-я версия в 2009. Сейчас большинство браузеров поддерживает 5-ю версию, которую мы и будем использовать в книге. Версия 6 находится в процессе завершения и некоторые браузеры начинают поддерживать новые возможности этой версии.

JavaScript поддерживают не только браузеры. Базы данных типа MongoDB and CouchDB используют его в качестве скриптового языка и языка запросов. Есть несколько платформ для декстопов и серверов, наиболее известная из которых Node.js (основная тема link:20_node.html#node[Главы
20]), предоставляют мощное окружение для программирования вне браузера.

== Код, и что с ним делать ==

Код – это текст, из которого состоят программы. В большинстве глав книги есть код. Чтение и написание кода – это неотъемлемая часть обучения программированию. Старайтесь не просто пробегать глазами примеры – читайте их внимательно и разбирайтесь. Сначала это будет происходить медленно и непонятно, но вы быстро овладеете навыками. То же – насчёт упражнений. Не подразумевайте, что вы в них разобрались, пока не напишете работающий вариант.

Рекомендую пробовать ваши решения в настоящем интерпретаторе языка, чтобы сразу получать обратную связь, и, надеюсь, подвергаться искушению поэкспериментировать далее.

ifdef::interactive_target[]

When reading this book in your browser, you can edit (and run) all
example programs by clicking them.

endif::interactive_target[]

ifdef::book_target[]

(((download)))(((sandbox)))(((running code)))The easiest way to run
the example code in the book, and to experiment with it, is to look it
up in the online version of the book at
http://eloquentjavascript.net/[_eloquentjavascript.net_]. There, you
can click any code example to edit and run it and to see the
output it produces. To work on the exercises, go to
http://eloquentjavascript.net/2nd_edition/code[_eloquentjavascript.net/2nd_edition/code_],
which provides starting code for each coding exercise and allows you
to look at the solutions.

endif::book_target[]

(((developer tools)))(((JavaScript console)))If you want to run the
programs defined in this book outside of the book's sandbox, some care
is required. Many examples stand on their own and should work in any
JavaScript environment. But code in later chapters is mostly written
for a specific environment (the browser or Node.js) and can run only
there. In addition, many chapters define bigger programs, and the
pieces of code that appear in them depend on each other or on external
files. The http://eloquentjavascript.net/2nd_edition/code[sandbox] on the website
provides links to Zip files containing all of the scripts and data
files necessary to run the code for a given chapter.

== Overview of this book ==

This book contains roughly three parts. The first 11 chapters discuss
the JavaScript language itself. The next eight chapters are about web
((browsers)) and the way JavaScript is used to program them. Finally,
two chapters are devoted to ((Node.js)), another environment to program
JavaScript in.

Throughout the book, there are five _project chapters_, which describe
larger example programs to give you a taste of real programming. In
order of appearance, we will work through building an
link:07_elife.html#elife[artificial life simulation], a
link:11_language.html#language[programming language], a
link:15_game.html#game[platform game], a
link:19_paint.html#paint[paint program], and a
link:21_skillsharing.html#skillsharing[dynamic website].

The language part of the book starts with four chapters to introduce
the basic structure of the JavaScript language. They introduce
link:02_program_structure.html#program_structure[control structures]
(such as the `while` word you saw in this introduction),
link:03_functions.html#functions[functions] (writing your own
operations), and link:04_data.html#data[data structures]. After these,
you will be able to write simple programs. Next, Chapters
link:05_higher_order.html#higher_order[5] and
link:06_object.html#object[6] introduce techniques to use functions
and objects to write more _abstract_ code and thus keep complexity
under control.

After a link:07_elife.html#elife[first project chapter], the first
part of the book continues with chapters on
link:08_error.html#error[error handling and fixing], on
link:09_regexp.html#regexp[regular expressions] (an important tool for
working with text data), and on
link:10_modules.html#modules[modularity]—another weapon against
complexity. The link:11_language.html#language[second project chapter]
concludes the first part of the book.

The second part, Chapters link:12_browser.html#browser[12] to
link:19_paint.html#paint[19], describes the tools that browser
JavaScript has access to. You'll learn to display things on the screen
(Chapters link:13_dom.html#dom[13] and
link:16_canvas.html#canvas[16]), respond to user input (Chapters
link:14_event.html#event[14] and link:18_forms.html#forms[18]), and
communicate over the network (link:17_http.html#http[Chapter 17]).
There are again two project chapters in this part.

After that, link:20_node.html#node[Chapter 20] describes Node.js, and
link:21_skillsharing.html#skillsharing[Chapter 21] builds a simple web
system using that tool.

ifdef::commercial_target[]

Finally, link:22_fast.html#fast[Chapter 22] describes some of the
considerations that come up when optimizing JavaScript programs for
speed.

endif::commercial_target[]

== Typographic conventions ==

(((factorial function)))In this book, text written in a `monospaced`
font will represent elements of programs—sometimes
they are self-sufficient fragments, and sometimes they just refer to
part of a nearby program. Programs (of which you have already seen a
few), are written as follows:

[source,javascript]
----
function fac(n) {
  if (n == 0)
    return 1;
  else
    return fac(n - 1) * n;
}
----

(((console.log)))Sometimes, in order to show the output that a program
produces, the expected output is written after it, with two slashes
and an arrow in front.

[source,javascript]
----
console.log(fac(8));
// → 40320
----

Good luck!
