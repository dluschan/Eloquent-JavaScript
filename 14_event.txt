:chap_num: 14
:prev_link: 13_dom
:next_link: 15_game

= Handling Events =

[chapterquote="true"]
[quote,Марк Аврелий,Медитации]
____
Вы властны над своим разумом, но не над внешними событиями. Когда вы поймёте это, вы обретёте силу.
____

(((stoicism)))(((Marcus Aurelius)))(((input)))(((timeline)))(((control flow)))Некоторые программы работают с вводом пользователя, мышью и клавиатурой. Время возникновения такого ввода и последовательность данных нельзя предсказать заранее. Это требует иного подхода к контролю над порядком выполнения программы, чем уже привычный нам.

== Обработчики событий ==

(((polling)))(((button)))(((real-time)))Представьте интерфейс, в котором единственным способом узнать, нажали ли на кнопку клавиатуры, было бы считывание текущего состояния кнопки. Чтобы реагировать на нажатия, вам пришлось бы постоянно считывать состояния кнопок, чтобы вы могли поймать это состояние, пока кнопка не отжалась. Было бы опасно проводить другие подсчёты, отнимающие процессорное время, так как можно было бы пропустить момент нажатия.

Таким образом ввод обрабатывался на примитивных устройствах. Шагом вперёд было бы, если железо или операционка замечали бы нажатие кнопки и передавали бы его в очередь. Затем программа периодически могла бы проверять очередь на новые события и реагировать на то, что находится в очереди.

(((responsiveness)))(((user experience)))Разумеется, она должна помнить о проверке, и делать это достаточно часто, потому что наличие длительного промежутка времени между нажатием кнопки и тем, когда программа замечает и реагирует на это, ведёт к восприятию этой программы как медленно работающей. Такой подход называется _((опрос))ом_. Большинство программистов по возможности избегают его.

(((callback function)))(((event handling)))Вариант получше – некая промежуточная система, которая позволяет коду реагировать на события в момент их возникновения. Браузеры позволяют это делать путём регистрации функций как _обработчиков_ заданных событий.

[source,text/html]
----
<p>Щёлкните по документу для запуска обработчика.</p>
<script>
  addEventListener("click", function() {
    console.log("Щёлк!");
  });
</script>
----

(((click event)))(((addEventListener method)))Функция `addEventListener` регистрирует свой второй аргумент как функцию, которая вызывается, когда описанное в первом аргументе событие случается.

== События и узлы DOM ==

(((addEventListener method)))(((event handling)))Каждый обработчик событий ((браузер))а зарегистрирован в контексте. Когда вы вызываете `addEventListener`, вы вызываете её как метод целого окна, потому что в браузере ((глобальная область видимости)) – это объект `window`. У каждого элемента ((DOM)) есть свой метод `addEventListener`, позволяющий слушать события от этого элемента.

[source,text/html]
----
<button>Нажми меня нежно</button>
<p>А здесь нет обработчиков.</p>
<script>
  var button = document.querySelector("button");
  button.addEventListener("click", function() {
    console.log("Кнопка нажата.");
  });
</script>
----

(((click event)))(((button (HTML tag))))Пример назначает обработчик на DOM-узел кнопки. Нажатия на кнопку запускают обработчик, а нажатия на другие части документа – не запускают.

(((onclick attribute)))(((encapsulation)))Присвоение узлу атрибута `onclick` работает похоже. Но у узла есть только один атрибут `onclick`, значит таким способом вы можете зарегистрировать только один обработчик. Метод `addEventListener` позволяет добавлять любое количество обработчиков, так что вы не замените случайно уже назначенный ранее обработчик.

(((removeEventListener method)))Метод `removeEventListener`, вызванный с такими же аргументами, как `addEventListener`, удаляет обработчик.

[source,text/html]
----
<button>Act-once button</button>
<script>
  var button = document.querySelector("button");
  function once() {
    console.log("Done.");
    button.removeEventListener("click", once);
  }
  button.addEventListener("click", once);
</script>
----

(((function,as value)))Чтобы это провернуть, мы даём функции имя (в данном случае, `once`), чтобы её можно было передать и в `addEventListener`, и в `removeEventListener`.

== Объекты событий ==

(((which property)))(((event handling)))В примерах мы проигнорировали тот факт, что функциям-обработчикам передаётся аргумент – _((объект события))_. В нём хранится дополнительная информация о событии. К примеру, если надо узнать, _какая_ ((кнопка мыши)) была нажата, мы можем обратиться к свойству `which` этого объекта.

[source,text/html]
----
<button>Жми меня, чем хочешь!</button>
<script>
  var button = document.querySelector("button");
  button.addEventListener("mousedown", function(event) {
    if (event.which == 1)
      console.log("Левая");
    else if (event.which == 2)
      console.log("Средняя");
    else if (event.which == 3)
      console.log("Правая");
  });
</script>
----

(((event type)))(((type property)))Хранящаяся в объекте информация – разная для каждого типа событий. Мы обсудим эти типы позже. Свойство объекта `type` всегда содержит строку, описывающую событие (например, `"click"` или `"mousedown"`).

== Распространение ==

indexsee:[bubbling,event propagation]
indexsee:[propagation,event propagation]
(((event propagation)))(((parent node)))События, зарегистрированные на узлах, имеющих дочерние узлы, получат и некоторые события, случившиеся с их детьми. Если кликнуть на кнопку внутри параграфа, обработчики событий параграфа получат событие `click`.

(((event handling)))Если и у параграфа и у кнопки есть обработчики, то первым запустится более конкретный – то есть, обработчик кнопки. Событие как бы _распространяется_ наружу, от узла, где оно случилось, до его родительского и далее до корня документа. После отработки всех обработчиков всех промежуточных узлов, очередь среагировать на событие доходит и до самого ((окна)).

(((stopPropagation method)))(((click event)))В любой момент обработчик может вызвать метод `stopPropagation` объекта события, чтобы “высшие” узлы не получили его. Это может быть полезным, когда у вас есть кнопка внутри другого кликабельного элемента, и вы не хотите, чтобы клики по кнопке активировали поведение внешнего элемента.

(((mousedown event)))Следующий пример регистрирует обработчики `"mousedown"` как на кнопке, так и на окружающем параграфе. При щелчке правой кнопкой обработчик кнопки вызывает `stopPropagation`, который предотвращает запуск обработчика параграфа. При клике другой ((кнопкой)) запускаются оба обработчика.

[source,text/html]
----
<p>Параграф с <button>кнопкой</button>.</p>
<script>
  var para = document.querySelector("p");
  var button = document.querySelector("button");
  para.addEventListener("mousedown", function() {
    console.log("Обработчик параграфа.");
  });
  button.addEventListener("mousedown", function(event) {
    console.log("Обработчик кнопки.");
    if (event.which == 3)
      event.stopPropagation();
  });
</script>
----

(((event propagation)))(((target property)))У большинства объектов событий есть свойство `target`, ссылающееся на узел, который запустил обработку. Его можно использовать для проверки того, что вы не обрабатываете что-то, пришедшее с ненужного вам узла.

Также возможно использовать свойство `target`, чтобы распространить обработку конкретного типа события. К примеру, если у вас есть узел, содержащий длинный список кнопок, было бы удобнее зарегистрировать один обработчик событий для узла, и в нём выяснять, нажали ли на кнопку – вместо того, чтобы регистрировать обработчики каждой кнопки по отдельности.

[source,text/html]
----
<button>A</button>
<button>B</button>
<button>C</button>
<script>
  document.body.addEventListener("click", function(event) {
    if (event.target.nodeName == "BUTTON")
      console.log("Clicked", event.target.textContent);
  });
</script>
----

== Действия по умолчанию ==

(((scrolling)))(((default behavior)))(((event handling)))У многих событий есть действия по умолчанию. При клике на ((ссылку)) вы перейдёте по ней. При нажатии на стрелку вниз браузер прокрутит страницу вниз. По правому клику мыши вы увидите контекстное меню. И так далее.

(((preventDefault method)))Для большинства типов событий обработчики событий вызываются _до_ того, как сработает действие по умолчанию. Если обработчик не хочет, чтобы это действие происходило (часто потому, что он уже обработал его), он может вызвать метод `preventDefault` объекта события.

(((expectation)))Это можно использовать для создания своих горячих ((клавиш)) или ((контекстного меню)). Также это можно использовать для поломки привычного пользователю интерфейса. К примеру, вот ссылка, по которой нельзя пройти:

[source,text/html]
----
<a href="https://developer.mozilla.org/">MDN</a>
<script>
  var link = document.querySelector("a");
  link.addEventListener("click", function(event) {
    console.log("Фигушки.");
    event.preventDefault();
  });
</script>
----

Не делайте так, если у вас нет очень серьёзной причины! Пользователям вашей страницы будет очень неудобно, когда они столкнутся с неожиданными результатами своих действий.

В зависимости от браузера, некоторые события перехватить нельзя. В Chrome нельзя обрабатывать горячие ((клавиши)) закрытия текущей закладки (Ctrl-W или Command-W).

== События от кнопок клавиатуры ==

(((keyboard)))(((keydown event)))(((keyup event)))(((event handling)))При нажатии кнопки на клавиатуре браузер запускает событие `"keydown"`. Когда она отпускается, происходит событие `"keyup"`.

[source,text/html]
[focus="yes"]
----
<p>Страница по нажатию V офиолетивает.</p>
<script>
  addEventListener("keydown", function(event) {
    if (event.keyCode == 86)
      document.body.style.background = "violet";
  });
  addEventListener("keyup", function(event) {
    if (event.keyCode == 86)
      document.body.style.background = "";
  });
</script>
----

(((repeating key)))Несмотря на название, `"keydown"` происходит не только тогда, когда на кнопку нажимают. Если нажать и удерживать кнопку, событие будет происходить каждый раз по приходу _повторного_ сигнала от клавиши. Если вам, к примеру, надо увеличивать ускорение ((игрового)) персонажа, когда нажата кнопка со стрелкой, и уменьшать его, когда она отпущена – надо быть осторожным, чтобы не увеличить ускорение каждый раз при повторе сигнала от кнопки, иначе оно возрастёт очень сильно.

(((keyCode property)))(((key code)))В примере упомянуто свойство `keyCode` объекта события. Так вы можете узнать, какая именно кнопка нажата или отпущена. К сожалению, не всегда очевидно, как преобразовать числовые коды в нужную кнопку.

(((event object)))(((charCodeAt method)))Для цифр и букв код будет кодом символа ((Unicode)), связанного с прописным символом, изображённым на кнопке. Метод ((строки)) `charCodeAt` даёт нам этот код.

[source,javascript]
----
console.log("Violet".charCodeAt(0));
// → 86
console.log("1".charCodeAt(0));
// → 49
----

У других кнопок ((код))ы менее предсказуемы. Лучший способ их выяснить – ((эксперимент))альный. Зарегистрировать обработчик, который записывает коды клавиш, и нажать нужную кнопку.

(((modifier key)))(((shift key)))(((control key)))(((alt key)))(((meta key)))(((command key)))(((ctrlKey property)))(((shiftKey property)))(((altKey property)))(((metaKey property)))Кнопки-модификаторы типа Shift, Ctrl, Alt, и Meta (Command на Mac) создают события, как и нормальные кнопки. Но при разборе комбинаций клавиш можно выяснить, были ли нажаты модификаторы, через свойства `shiftKey`, `ctrlKey`, `altKey`, и `metaKey` событий клавиатуры и мыши.

[source,text/html]
[focus="yes"]
----
<p>Нажмите Ctrl-Space для продолжения.</p>
<script>
  addEventListener("keydown", function(event) {
    if (event.keyCode == 32 && event.ctrlKey)
      console.log("Продолжаем!");
  });
</script>
----

(((typing)))(((fromCharCode function)))(((charCode property)))(((keydown event)))(((keyup event)))(((keypress event)))События `"keydown"` и `"keyup"` дают информацию о физическом нажатии кнопок. А если вам нужно узнать, какой ((текст)) вводит пользователь? Создавать его из нажатий кнопок – неудобно. Для этого существует событие `"keypress"`, происходящее сразу после `"keydown"` (и повторяющееся вместе с `"keydown"`, если клавишу продолжают удерживать), но только для тех кнопок, которые выдают символы. Свойство объекта события `charCode` содержит код, который можно интерпретировать как код ((Unicode)). Мы можем использовать функцию `String.fromCharCode` для превращения кода в ((строку)) из одного ((символ))а.

[source,text/html]
[focus="yes"]
----
<p>Переведите фокус на страницу и печатайте.</p>
<script>
  addEventListener("keypress", function(event) {
    console.log(String.fromCharCode(event.charCode));
  });
</script>
----

(((button (HTML tag))))(((tabindex attribute)))Источником события нажатия клавиши узел становится в зависимости от того, где находился ((фокус)) ввода во время нажатия. Обычные узлы не могут получить фокус ввода (если только вы не задали им атрибут `tabindex`), а такие, как ((ссылки)), кнопки и поля форм – могут. Мы вернёся к ((полям)) ввода в link:18_forms.html#forms[главе 18]. Когда ни у чего нет фокуса, в качестве целевого узла событий работает `document.body`.

== Щелчки мышью ==

(((mousedown event)))(((mouseup event)))(((mouse cursor)))Нажатие ((кнопки мыши)) тоже запускает несколько событий. События `"mousedown"` и `"mouseup"` похожи на `"keydown"` и `"keyup"`, и запускаются, когда кнопка нажата и когда отпущена. События происходят у тех узлов DOM, над которыми находился курсор мыши.

(((click event)))После события `"mouseup"` на узле, на который пришлись и нажатие, и отпускание кнопки, запускается событие `"click"`. Например, если я нажал кнопку над одним параграфом, потом передвинул мышь на другой параграф и отпустил кнопку, событие `"click"` случится у элемента, который содержал в себе оба эти параграфа.

(((dblclick event)))(((double click)))Если два щелчка происходят достаточно быстро друг за другом, запускается событие `"dblclick"` (double-click), сразу после второго запуска `"click"`.

(((pixel)))(((pageX property)))(((pageY property)))(((event object)))Для получения точных координат места, где произошло событие мыши, обратитесь к свойствам `pageX` и `pageY` – они содержат ((координаты)) в пикселях относительно верхнего левого угла документа.

[[mouse_drawing]]
(((border-radius (CSS))))(((absolute positioning)))(((drawing program example)))В примере создана примитивная программа для рисования. Каждый раз по клику на документе он добавляет точку под вашим курсором. В link:19_paint.html#paint[главе 19] будет представлена менее примитивная программа для рисования.

[source,text/html]
----
<style>
  body {
    height: 200px;
    background: beige;
  }
  .dot {
    height: 8px; width: 8px;
    border-radius: 4px; /* скруглённые углы */
    background: blue;
    position: absolute;
  }
</style>
<script>
  addEventListener("click", function(event) {
    var dot = document.createElement("div");
    dot.className = "dot";
    dot.style.left = (event.pageX - 4) + "px";
    dot.style.top = (event.pageY - 4) + "px";
    document.body.appendChild(dot);
  });
</script>
----

(((clientX property)))(((clientY property)))(((getBoundingClientRect method)))(((event object)))Свойства `clientX` и `clientY` похожи на `pageX` и `pageY`, но дают координаты относительно части документа, которая видна сейчас (если документ был прокручен). Это удобно при сравнении координат мыши с ((координатами)), которые возвращает `getBoundingClientRect` – его возврат тоже связан с относительными координатами ((видимой части)) документа.

== Движение мыши ==

(((mousemove event)))Каждый раз при сдвиге курсора мыши запускается событие `"mousemove"`. Его можно использовать для отслеживания позиции мыши. Обычно это нужно при создании некоей функциональности, связанной с ((перетаскивание))м объектов мышью.

(((draggable bar example)))К примеру, следующая программа отображает полоску и устанавливает обработку событий так, что движение влево и вправо уменьшает или увеличивает её ширину:

[source,text/html]
----
<p>Переместите мышь для изменения ширины полосы:</p>
<div style="background: orange; width: 60px; height: 20px">
</div>
<script>
  var lastX; // Последняя позиция X мыши
  var rect = document.querySelector("div");
  rect.addEventListener("mousedown", function(event) {
    if (event.which == 1) {
      lastX = event.pageX;
      addEventListener("mousemove", moved);
      event.preventDefault(); // Запретим выделение
    }
  });

  function buttonPressed(event) {
    if (event.buttons == null)
      return event.which != 0;
    else
      return event.buttons != 0;
  }
  function moved(event) {
    if (!buttonPressed(event)) {
      removeEventListener("mousemove", moved);
    } else {
      var dist = event.pageX - lastX;
      var newWidth = Math.max(10, rect.offsetWidth + dist);
      rect.style.width = newWidth + "px";
      lastX = event.pageX;
    }
  }
</script>
----

ifdef::book_target[]

Получившаяся страница выглядит так:

image::img/drag-bar.png[alt="A draggable bar",width="5.3cm"]

endif::book_target[]

(((mouseup event)))(((mousemove event)))Обратите внимание – обработчик `"mousemove"` зарегистрирован у всего ((окна)). Даже если мышь уходит за пределы полоски, нам надо обновлять её размер и прекращать это, когда кнопку отпускают.

(((buttons property)))(((which property)))We must stop resizing the
bar when the mouse button is released. Unfortunately, not all browsers
give `"mousemove"` events a meaningful `which` property. There is a
standard property called `buttons`, which provides similar
information, but that is also not supported on all browsers.
Fortunately, all major browsers support either `buttons` or `which`,
so the `buttonPressed` function in the example first tries `buttons`,
and falls back to `which` when that isn't available.

(((mouseover event)))(((mouseout event)))Когда курсор попадает на узел и уходит с него, происходят события `"mouseover"` или `"mouseout"`. Их можно использовать, кроме прочего, для создания ((эффектов проведения)) мыши, показывая или меняя стиль чего-либо, когда курсор находится над этим элементом.

(((event propagation)))К сожалению, создание такого эффекта не ограничивается запуском его при событии `"mouseover"` и завершением при событии `"mouseout"`. При движении мыши от узла к его дочерним узлам на родительском узле происходит событие `"mouseout"`, хотя мышь, вообще говоря, его и не покидала. Что ещё хуже, эти события распространяются как и все другие, поэтому вы всё равно получаете `"mouseout"` при уходе курсора с одного их ((дочерних узлов)) того узла, где вы зарегистрировали обработчик.

(((isInside function)))(((relatedTarget property)))(((target property)))Для обхода проблемы можно использовать свойство `relatedTarget` объекта событий. Он сообщает, на каком узле была до этого мышь при возникновении события `"mouseover"`, и на какой элемент она переходит при событии `"mouseout"`. Нам надо менять эффект, только когда `relatedTarget` находится вне нашего целевого узла. Только в этом случае событие на самом деле представляет собой _переход_ на наш узел (или уход с узла).

[source,text/html]
----
<p>Наведите мышь на этот <strong>параграф</strong>.</p>
<script>
  var para = document.querySelector("p");
  function isInside(node, target) {
    for (; node != null; node = node.parentNode)
      if (node == target) return true;
  }
  para.addEventListener("mouseover", function(event) {
    if (!isInside(event.relatedTarget, para))
      para.style.color = "red";
  });
  para.addEventListener("mouseout", function(event) {
    if (!isInside(event.relatedTarget, para))
      para.style.color = "";
  });
</script>
----

Функция `isInside` перебирает всех предков узла, пока не доходит до верха документа (и тогда узел равен `null`), или же не находит заданного ей родителя.

Должен добавить, что такой эффект достижим гораздо проще через _((псевдоселектор))_ ((CSS)) под названием `:hover`, как показано ниже. Но когда при наведении вам надо делать что-то более сложное, чем изменение стиля узла, придётся использовать трюк с событиями `"mouseover"` и `"mouseout"`.

[source,text/html]
----
<style>
  p:hover { color: red }
</style>
<p>Наведите мышь на этот <strong>параграф</strong>.</p>
----

== События прокрутки ==

(((scrolling)))(((scroll event)))(((event handling)))Когда элемент прокручивается, запускается событие `"scroll"`. Это используется во многих случаях, например чтобы узнать, на что сейчас пользователь смотрит (чтобы останавливать ((анимацию)), не попавшую на экран, или отправлять секретные ((шпион))ские донесения в ваш злодейский штаб), или визуально демонстрировать прогресс (подсвечивая часть содержания или показывая номер страницы).

В примере в правом верхнем углу документа создаётся ((индикатор процесса)), который заполняется по мере прокрутки элемента вниз:

[source,text/html]
----
<style>
  .progress {
    border: 1px solid blue;
    width: 100px;
    position: fixed;
    top: 10px; right: 10px;
  }
  .progress > div {
    height: 12px;
    background: blue;
    width: 0%;
  }
  body {
    height: 2000px;
  }
</style>
<div class="progress"><div></div></div>
<p>Scroll me...</p>
<script>
  var bar = document.querySelector(".progress div");
  addEventListener("scroll", function() {
    var max = document.body.scrollHeight - innerHeight;
    var percent = (pageYOffset / max) * 100;
    bar.style.width = percent + "%";
  });
</script>
----

(((unit (CSS))))(((scrolling)))(((position (CSS))))(((fixed positioning)))(((absolute positioning)))(((percent)))Позиция элемента `fixed` означает почти то же, что `absolute`, но ещё и предотвращает прокручивание элемента вместе с остальным документом. Смысл в том, чтобы оставить наш индикатор в углу. Внутри него находится другой элемент, который изменяет размер, отражая текущий прогресс. Мы используем проценты вместо `px` для задания ширины, чтобы размер элемента изменялся относительно размера всего индикатора.

(((innerHeight property)))(((innerWidth property)))(((pageYOffset property)))Глобальная переменная `innerHeight` даёт высоту окна, которую надо вычесть из полной высоты прокручиваемого элемента – при достижении конца элемента прокрутка заканчивается. (Также в дополнение к `innerHeight` есть переменная `innerWidth`). Поделив текущую позицию прокрутки `pageYOffset` на максимальную позицию прокрутки, и умножив на 100, мы получили процент для индикатора.

(((preventDefault method)))Вызов `preventDefault` не предотвращает прокрутку. Обработчик события вызывается уже _после_ того, как прокрутка случилась.

== События, связанные с фокусом ==

(((event handling)))(((focus event)))(((blur event)))При получении элементом ((фокус))а браузер запускает событие `"focus"`. Когда он теряет фокус, запускается событие `"blur"`.

(((event propagation)))В отличие от предыдущих событий, эти два не распространяются. Обработчик родительского узла не уведомляется о получении или утрате фокуса дочерним элементом.

(((input (HTML tag))))(((help text example)))Следующий пример демонстрирует текст подсказки для того ((текстового поля)), у которого в данный момент фокус:

[source,text/html]
----
<p>Имя: <input type="text" data-help="Ваше полное имя"></p>
<p>Возраст: <input type="text" data-help="Возраст в годах"></p>
<p id="help"></p>

<script>
  var help = document.querySelector("#help");
  var fields = document.querySelectorAll("input");
  for (var i = 0; i < fields.length; i++) {
    fields[i].addEventListener("focus", function(event) {
      var text = event.target.getAttribute("data-help");
      help.textContent = text;
    });
    fields[i].addEventListener("blur", function(event) {
      help.textContent = "";
    });
  }
</script>
----

ifdef::book_target[]

In the following screenshot, the help text for the age field is shown.

image::img/help-field.png[alt="Providing help when a field is focused",width="4.4cm"]

endif::book_target[]

(((focus event)))(((blur event)))Объект `((window))` получает события `"focus"` и `"blur"`, когда пользователь выделяет или убирает фокус с закладки браузера или окна браузера, в котором показан документ.

== Событие загрузки ==

(((script (HTML tag))))(((load event)))Когда заканчивается загрузка страницы, на объектах `window` и `body` запускается событие `"load"`. Это часто используется для планирования ((инициализирующих)) действий, которым необходим полностью построенный ((документ)). Вспомните, что содержимое тегов `<script>` запускается сразу, как только тег встречается. Иногда это слишком рано – например, когда скрипту нужно что-то сделать с теми частями документа, которые находятся после тега `<script>`.

(((event propagation)))(((img (HTML tag))))У элементов типа ((картинок)) или тегов скрипта, которые загружают внешний файл, тоже есть событие `"load"`, которое показывает, что файл загружен. Как и события фокуса, события загрузки не распространяются.

(((beforeunload event)))(((page reload)))(((preventDefault method)))Когда страница закрывается или с неё уходят (например, по ссылке), запускается событие `"beforeunload"`. Основная цель – защитить пользователя от случайной потери данных при закрытии документа. Предотвращение закрытия страницы не производится, как вы могли подумать, при помощи `preventDefault`. Вместо этого используется возврат строки из обработчика. Строка будет использована в диалоге, который спрашивает пользователя, хочет ли он остаться на странице или покинуть её. Этот механизм гарантирует, что пользователь может покинуть страницу, даже если на ней работает ((зловредный скрипт)), который бы хотел не отпускать пользователя, а вместо этого показывал бы ему мошенническую рекламу по снижению веса.

[[timeline]]
== График выполнения скрипта ==

(((requestAnimationFrame function)))(((event handling)))(((timeline)))(((script (HTML tag))))Несколько вещей могут привести к старту скрипта. Чтение тега `<script>` — одна из них. Запуск события – ещё одна. В link:13_dom.html#animationFrame[главе 13] обсуждается функция `requestAnimationFrame`, которая планирует запуск функции перед следующей перерисовкой страницы. Это ещё один способ запустить скрипт.

(((parallelism)))(((concurrency)))(((blocking)))Важно понять, что хотя события и запускаются в любой момент, два разных скрипта одновременно работать не могут. Если скрипт работает, обработчики событий и запланированные другим способом куски кода будут ждать своей очереди. Поэтому документ подвисает, когда скрипт работает слишком долго. Браузер не обрабатывает щелчки и другие события внутри документа потому, что он не может запустить обработчики событий, пока работает текущий скрипт.

(((performance)))(((complexity)))В некоторых программных окружениях можно запускать несколько _((поток))ов_ одновременно. Можно сделать программу быстрее, если выполнять несколько вещей одновременно. Но когда несколько действующих лиц трогают одни и те же части системы в одно и то же время, продумывать программу становится на порядок сложнее.

То, что программы JavaScript делают по одной вещи за раз, облегчает нашу жизнь. Если вам _очень_ надо сделать в фоне что-то тяжёлое, не подвешивая при этом страницу, браузеры предоставляют штуку под названием _((сетевые рабочие))_ (_((web worker))s_) – изолированное ((окружение)) JavaScript, работающее вместе с главной программой над документом, которое может общаться с ней только посредством ((сообщений)).

Предположим, у нас есть следующий код в файле `code/squareworker.js`:

[source,javascript]
----
addEventListener("message", function(event) {
  postMessage(event.data * event.data);
});
----

Представьте, что возведение в квадрат – очень тяжёлое, долго работающее вычисление, которое нам надо запустить фоновым ((поток))ом. Такой код порождает рабочего, отправляет ему несколько сообщений, и выводит результаты.

// test: no

[source,javascript]
----
var squareWorker = new Worker("code/squareworker.js");
squareWorker.addEventListener("message", function(event) {
  console.log("The worker responded:", event.data);
});
squareWorker.postMessage(10);
squareWorker.postMessage(24);
----

(((postMessage method)))(((message event)))Функция `postMessage` отправляет сообщение, которое запускает событие `"message"` у принимающей стороны. Скрипт, создавший рабочего, отправляет и получает сообщения через объект `Worker`, тогда как рабочий общается со скриптом, создавшим его, отправляя и получая сообщения через его собственное ((глобальное окружение)) – которое является _отдельным_ окружением, не связанным с оригинальным скриптом.

== Установка таймеров ==

(((timeout)))(((setTimeout function)))Функция `setTimeout` схожа с `requestAnimationFrame`. Она планирует запуск другой функции в будущем. Но вместо вызова функции при следующей перерисовке страницы, она ждёт заданное в миллисекундах время. Эта страница через две секунды превращается из синей в жёлтую:

[source,text/html]
----
<script>
  document.body.style.background = "blue";
  setTimeout(function() {
    document.body.style.background = "yellow";
  }, 2000);
</script>
----

(((clearTimeout function)))Иногда вам надо отменить запланированную функцию. Это можно сделать, сохранив значение, возвращаемое `setTimeout`, и затем вызвав с ним `clearTimeout`.

[source,javascript]
----
var bombTimer = setTimeout(function() {
  console.log("BOOM!");
}, 500);

if (Math.random() < 0.5) { // 50% chance
  console.log("Defused.");
  clearTimeout(bombTimer);
}
----

(((cancelAnimationFrame function)))(((requestAnimationFrame function)))Функция `cancelAnimationFrame` работает так же, как `clearTimeout` – вызов её со значением, возвращённым `requestAnimationFrame`, отменит этот кадр (если он уже не был вызван).

(((setInterval function)))(((clearInterval function)))(((repetition)))Похожий набор функций, `setInterval` и `clearInterval` используется для установки таймеров, которые будут повторяться каждые _X_ миллисекунд.

[source,javascript]
----
var ticks = 0;
var clock = setInterval(function() {
  console.log("tick", ticks++);
  if (ticks == 10) {
    clearInterval(clock);
    console.log("stop.");
  }
}, 200);
----

== Устранение помех ==

(((optimization)))(((mousemove event)))(((scroll event)))(((blocking)))У некоторых событий есть возможность выполняться быстро и много раз подряд (например, `"mousemove"` и `"scroll"`). При обработке таких событий надо быть осторожным и не делать ничего долгого, или ваш обработчик займёт столько времени на выполнение, что взаимодействие с документом будет медленным и прерывистым.

(((setTimeout function)))Если в таком обработчике надо сделать что-то нетривиальное, можно использовать `setTimeout`, чтобы гарантировать, что вы делаете это не слишком часто. Это обычно называют _((устранением помех))_ (или _((debouncing))_) в событии. К этому существует несколько слегка различающихся подходов.

(((textarea (HTML tag))))(((clearTimeout function)))(((keydown event)))В первом примере надо сделать что-то, когда пользователь печатает, но не надо делать это сразу после запуска каждого события нажатия на клавиши. Когда они быстро ((печатают)), нам надо подождать, когда возникнет пауза. Вместо немедленного выполнения действия в обработчике, мы устанавливаем таймаут. Также мы очищаем предыдущий таймаут, если он был, так что если события близко одно от другого (ближе, чем задержка таймера), предыдущее событие будет отменено.

[source,text/html]
----
<textarea>Напишите тут что-нибудь...</textarea>
<script>
  var textarea = document.querySelector("textarea");
  var timeout;
  textarea.addEventListener("keydown", function() {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      console.log("Вы остановились.");
    }, 500);
  });
</script>
----

(((sloppy programming)))Если задать `undefined` для `clearTimeout`, или вызвать его с таймаутом, который уже произошёл, то ничего не произойдёт. Таким образом, не надо осторожничать при его вызове, и мы просто поступаем так для каждого события.

(((mousemove event)))Можно использовать немного другой подход, если нам надо разделить ответы минимальными промежутками ((времени)), но при этом запускать их в _то_ время, когда происходят события, а не после. К примеру, надо реагировать на события `"mousemove"`, показывая текущие координаты мыши, но только каждые 250 миллисекунд.

[source,text/html]
----
<script>
  function displayCoords(event) {
    document.body.textContent =
      "Мышь на " + event.pageX + ", " + event.pageY;
  }

  var scheduled = false, lastEvent;
  addEventListener("mousemove", function(event) {
    lastEvent = event;
    if (!scheduled) {
      scheduled = true;
      setTimeout(function() {
        scheduled = false;
        displayCoords(lastEvent);
      }, 250);
    }
  });
</script>
----

== Итог ==

Обработчики событий позволяют обнаруживать и реагировать на события, над которыми мы не властны. Для их регистрации используется метод `addEventListener`.

У событий есть определяющий их тип (`"keydown"`, `"focus"`, и так далее). Большинство событий вызываются конкретными узлами DOM, и затем _распространяются_ на их предков, позволяя связанными с ними обработчикам обрабатывать их.

При вызове обработчика ему передаётся объект события с дополнительной информацией о событии. У объекта также есть методы, позволяющие остановить дальнейшее распространение (`stopPropagation`) и предотвратить обработку события браузером по умолчанию (`preventDefault`).

Нажатия на клавиши запускают события `"keydown"`, `"keypress"` и `"keyup"`. Нажатия на кнопки мыши запускают события `"mousedown"`, `"mouseup"` и `"click"`. Движения мыши запускают события `"mousemove"`, и возможно `"mouseenter"` и `"mouseout"`.

Прокрутку можно обнаружить через событие `"scroll"`, а изменения фокуса через события `"focus"` и `"blur"`. Когда заканчивается загрузка документа, у объекта `window` запускается событие `"load"`.

В одно и то же время может работать один участок программы. Поэтому обработчики событий и другие запланированные скрипты будут ждать окончания работы текущих.

== Упражнения ==

=== Цензура клавиатуры ===

(((Turkish)))(((Kurds)))(((censored keyboard (exercise))))В промежутке с 1928 по 2013 год турецкие законы запрещали использование букв _Q_, _W_ и _X_ в официальных документах. Это являлось частью общей инициативы подавления курдской культуры – эти буквы используются в языке курдов, но не у турков.

(((typing)))(((input (HTML tag))))В качестве упражнения на тему странного использования технологий, я прошу вас запрограммировать ((поле)) для ввода ((текст))а (тег `<input type="text">`) так, чтобы эти буквы нельзя было туда вписать.

(((clipboard)))Насчет копирования и вставки и других подобных возможных обходов правила не беспокойтесь.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<input type="text">
<script>
  var field = document.querySelector("input");
  // Ваш код
</script>
----

endif::interactive_target[]

!!hint!!

(((keypress event)))(((keydown event)))(((preventDefault
method)))(((censored keyboard (exercise))))The solution to this
exercise involves preventing the ((default behavior)) of key events.
You can handle either `"keypress"` or `"keydown"`. If either of them
has `preventDefault` called on it, the letter will not appear.

(((keyCode property)))(((charCode
property)))(((capitalization)))Identifying the letter typed requires
looking at the `keyCode` or `charCode` property and comparing that
with the codes for the letters you want to filter. In `"keydown"`, you
do not have to worry about lowercase and uppercase letters, since it
identifies only  the key pressed. If you decide to handle `"keypress"`
instead, which identifies the actual character typed, you have to make
sure you test for both cases. One way to do that would be this:

----
/[qwx]/i.test(String.fromCharCode(event.charCode))
----

!!hint!!

=== След мыши ===

(((animation)))(((mouse trail (exercise))))В ранние дни JavaScript, когда было время ((кричащих домашних страниц)) с обилием анимированных картинок, люди использовали язык очень вдохновляющими способами. Одним из них был “след мыши” — серия картинок, которые следовали за курсором при его движении по странице.

(((absolute positioning)))(((background (CSS))))Я хочу, что бы вы в упражнении сделали такой след. Используйте элементы `<div>` с абсолютным позиционированием, фиксированным размером и цветом фона (см. пример link:14_event.html#mouse_drawing[кода] в разделе “Щелчки мышью”). Создайте кучку элементов и при движении мыши показывайте их следом за курсором.

(((mousemove event)))К этому можно подойти многими способами. Можно сделать очень простое или очень сложное решение, как угодно. Простое – хранить фиксированное количество элементов и проходить по ним в цикле, двигая каждый следующий на текущее место курсора, каждый раз когда случается событие `"mousemove"`.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<style>
  .trail { /* className для элементов, летящих за курсором */
    position: absolute;
    height: 6px; width: 6px;
    border-radius: 3px;
    background: teal;
  }
  body {
    height: 300px;
  }
</style>

<script>
  // Ваш код.
</script>
----

endif::interactive_target[]

!!hint!!

(((mouse trail (exercise))))Creating the elements is best done in a
loop. Append them to the document to make them show up. To be
able to access them later to change their position, store the trail
elements in an array.

(((mousemove event)))(((array,indexing)))(((remainder operator)))(((%
operator)))Cycling through them can be done by keeping a ((counter
variable)) and adding 1 to it every time the `"mousemove"` event
fires. The remainder operator (`% 10`) can then be used to get a valid
array index to pick the element you want to position during a given
event.

(((simulation)))(((requestAnimationFrame function)))Another
interesting effect can be achieved by modeling a simple ((physics))
system. Use the `"mousemove"` event only to update a pair of variables
that track the mouse position. Then use `requestAnimationFrame` to
simulate the trailing elements being attracted to the position of the
mouse pointer. At every animation step, update their position based on
their position relative to the pointer (and, optionally, a speed that
is stored for each element). Figuring out a good way to do this is up
to you.

!!hint!!

=== Закладки ===

(((tabbed interface (exercise))))Интерфейс закладок встречается часто. Он позволяет вам выбирать панель интерфейса, выбирая одну из нескольких “торчащих” закладок над элементом.

(((button (HTML tag))))(((display (CSS))))(((hidden element)))(((data attribute)))В упражнении вам нужно сделать простой интерфейс закладок. Напишите функцию `asTabs`, которая принимает узел DOM, и создаёт закладочный интерфейс, показывая дочерние элементы этого узла. Ей нужно вставлять список элементов `<button>` вверху узла, по одному на каждый дочерний элемент, содержащих текст, полученный из атрибута `data-tabname`. Все, кроме одного из дочерних элементов, должны быть спрятаны (при помощи значения `none` свойства стиля `display`), а текущий видимый узел можно выбирать нажатием кнопки.

Когда оно заработает, расширьте функционал, чтобы у текущей активной кнопки был свой стиль.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<div id="wrapper">
  <div data-tabname="one">Закладка один</div>
  <div data-tabname="two">Закладка два</div>
  <div data-tabname="three">Закладка три</div>
</div>
<script>
  function asTabs(node) {
    // Ваш код.
  }
  asTabs(document.querySelector("#wrapper"));
</script>
----

endif::interactive_target[]

!!hint!!

(((text node)))(((childNodes property)))(((live data
structure)))(((tabbed interface (exercise))))One pitfall you'll
probably run into is that you can't directly use the node's
`childNodes` property as a collection of tab nodes. For one thing,
when you add the buttons, they will also become child nodes and end
up in this object because it is live. For another, the text nodes
created for the ((whitespace)) between the nodes are also in there
and should not get their own tabs.

(((TEXT_NODE code)))(((nodeType property)))To work around this, start
by building up a real array of all the children in the wrapper that
have a `nodeType` of 1.

(((event handling)))(((closure)))When registering event handlers on
the buttons, the handler functions will need to know which tab element
is associated with the button. If they are created in a normal loop,
you can access the loop index variable from inside the function, but
it won't give you the correct number because that variable will have
been further changed by the loop.

(((forEach method)))(((local variable)))(((loop)))A simple workaround
is to use the `forEach` method and create the handler functions from
inside the function passed to `forEach`. The loop index, which is
passed as a second argument to that function, will be a normal local
variable there and won't be overwritten by further iterations.

!!hint!!
