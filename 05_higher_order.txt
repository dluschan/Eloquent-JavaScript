:chap_num: 5
:prev_link: 04_data
:next_link: 06_object
:load_files: ["code/ancestry.js", "code/chapter/05_higher_order.js", "code/intro.js"]
:zip: node/html

= Функции высшего порядка =

ifdef::interactive_target[]

[chapterquote="true"]
[quote, Мастер Юнь-Ма, Книга программирования]
____
Цу-ли и Цу-су похвалялись размерами своих новых программ. «Двести тысяч строк»,- сказал Цу-ли,- «не считая комментариев!» Цу-су ответил: «Пф-ф, моя – почти *миллион* строк». Мастер Юнь-Ма сказал: «Моя лучшая программа занимает пятьсот строк». Услышав это, Цу-ли и Цу-су испытали просветление.
____

endif::interactive_target[]

[chapterquote="true"]
[quote, Энтони Хоар, 1980 лекция на вручении премии Тьюринга]
____
(((Hoare+++,+++ C.A.R.)))Есть два способа построения программ: сделать их настолько простыми, что там очевидно не будет ошибок, или же настолько сложными, что там не будет очевидных ошибок.
____

(((program size)))Большая программа – затратная программа, и не только из-за времени её написания. Большой размер обычно означает ((сложность)), а сложность сбивает с толку программистов. Сбитые с толку программисты делают ошибки (_((баги))_) в программах. Большая программа означает, что багам есть где спрятаться и их получается труднее отыскать.

(((summing example)))Вернёмся ненадолго к двум примерам из введения. Первый самодостаточен, и занимает шесть строк.

[source,javascript]
----
var total = 0, count = 1;
while (count <= 10) {
  total += count;
  count += 1;
}
console.log(total);
----

Второй основан на двух внешних функциях и занимает одну строку.

[source,javascript]
----
console.log(sum(range(1, 10)));
----

В каком из них скорее встретится ошибка?

(((program size)))Если мы добавим размер определений `sum` и `range`, вторая программа тоже получится большой – больше первой. Но я всё равно утверждаю, что она скорее всего будет правильной.

(((abstraction)))(((domain-specific language)))Это будет потому, что решение выражено в терминах, относящихся непосредственно к решаемой задаче. Суммирование числового промежутка – это не циклы и счётчики. Это суммы и промежутки.

Определения этого ((словаря)) (функции `sum` и `range`) будут включать циклы, счётчики и другие случайные детали. Но потому, что они выражают более простые концепции, чем вся программа, их проще сделать правильно.

== Абстракции ==

В контексте программирования эти “словарные” определения часто называют _((абстракция))ми_. Абстракции прячут детали и дают нам возможность разговаривать о задачах на высоком, или более абстрактном, уровне.

(((recipe analogy)))(((pea soup)))Сравните два рецепта горохового супа:

____
Добавьте в ёмкость по одной чашке сухого гороха на порцию. Добавьте воды так, чтобы она покрыла горох. Оставьте его так минимум на 12 часов. Выньте горох из воды и поместите его на сковороду. Добавьте 4 чашки воды на порцию. Закройте сковороду и тушите горох два часа. Возьмите по половине луковицы на порцию. Порежьте на куски ножом, добавьте к гороху. Возьмите по одному стеблю сельдерея на порцию. Порежьте на куски ножом, добавьте к гороху. Возьмите по морковке на порцию. Порежьте на куски. Ножом! Добавьте к гороху. Готовьте ещё 10 минут.
____

Второй рецепт:
____
На порцию: 1 чашка сухого гороха, половина луковицы, стебель сельдерея, морковка.

Вымачивайте горох 12 часов. Тушите 2 часа в 4 чашках воды на порцию. Порежьте и добавьте овощи. Готовьте ещё 10 минут.
____

(((vocabulary)))Второй – короче и проще. Но вам нужно знать чуть больше понятий, связанных с готовкой – _вымачивание_, _тушение_, _резка_ (и _овощи_).

Программируя, мы не можем рассчитывать на то, что все необходимые слова будут в нашем словаре. Из-за этого вы можете скатиться до шаблона первого рецепта: диктовать компьютеру все мелкие шажки друг за другом, не замечая понятий более высокого уровня, которые они выражают.

(((abstraction)))Второй натурой программиста должно стать умение замечать, когда понятие умоляет придумать для него новое слово и вынести в абстракцию.

== Абстрагируем обход массива ==

(((array)))Простые функции, которые мы использовали раньше, хороши для построения абстракций. Но иногда их бывает недостаточно.

(((for loop)))В link:04_data.html#data[предыдущей главе] мы несколько раз встречали такой цикл:

[source,javascript]
----
var array = [1, 2, 3];
for (var i = 0; i < array.length; i++) {
  var current = array[i];
  console.log(current);
}
----

(((length property,for array)))(((array,indexing)))(((readability)))Код пытается сказать: “для каждого элемента в массиве – вывести его в консоль”. Но он использует обходной путь – с переменной для подсчёта `i`, проверкой длины массива, и объявлением дополнительной переменной `current`. Мало того, что он не очень красив, он ещё и является почвой для потенциальных ошибок. Мы можем случайно повторно использовать переменную `i`, вместо `length` написать `lenght`, перепутать переменные `i` и `current`, и т.п.

Давайте абстрагируем его в функцию. Можете придумать способ сделать это?

Довольно просто написать функцию, обходящую массив и вызывающую для каждого элемента `console.log`.

[source,javascript]
----
function logEach(array) {
  for (var i = 0; i < array.length; i++)
    console.log(array[i]);
}
----

[[forEach]]
indexsee:[higher-order function,function+++,+++ higher-order](((function,higher-order)))(((loop)))(((array,traversal)))(((function,as value)))(((forEach method)))Но что, если нам надо делать что-то другое, нежели выводить элементы в консоль? Поскольку “делать что-то” можно представить как функцию, а функции – это просто переменные, мы можем передать это действие как аргумент.

[source,javascript]
----
function forEach(array, action) {
  for (var i = 0; i < array.length; i++)
    action(array[i]);
}

forEach(["Тили", "Мили", "Трямдия"], console.log);
// → Тили
// → Мили
// → Трямдия
----

(In some browsers, calling `console.log` in this way does not work.
You can use `alert` instead of `console.log` if this example fails to
work.)

Часто можно не передавать заранее определённую функцию в `forEach`, а создавать функцию прямо на месте.

[source,javascript]
----
var numbers = [1, 2, 3, 4, 5], sum = 0;
forEach(numbers, function(number) {
  sum += number;
});
console.log(sum);
// → 15
----

(((loop body)))(((curly braces)))Выглядит похоже на классический цикл `for`, с телом цикла, записанным в блоке. Однако, теперь тело находится внутри функции, и также внутри ((скобок)) вызова `forEach`. Поэтому его нужно закрыть как фигурной, _так и_ круглой скобкой.

(((local variable)))(((parameter)))Используя этот шаблон, мы можем задать имя переменной для текущего элемента массива (`number`), без необходимости выбирать его из массива вручную.

(((array,methods)))(((function,higher-order)))(((forEach method)))(((array)))Вообще, нам даже не нужно писать самим `forEach`. Это стандартный метод массивов. Так как массив уже передан в качестве переменной, над которой мы работаем, `forEach` принимает только один аргумент – функцию, которую нужно выполнить для каждого элемента.

Для демонстрации удобства этого подхода вернёмся к функции из link:04_data.html#analysis[предыдущей главы]. Она содержит два ((цикл))а, проходящих по массивам.

[source,javascript]
----
function gatherCorrelations(journal) {
  var phis = {};
  for (var entry = 0; entry < journal.length; entry++) {
    var events = journal[entry].events;
    for (var i = 0; i < events.length; i++) {
      var event = events[i];
      if (!(event in phis))
        phis[event] = phi(tableFor(event, journal));
    }
  }
  return phis;
}
----

(((forEach method)))Используя `forEach` мы делаем запись чуть короче и гораздо чище.

[source,javascript]
----
function gatherCorrelations(journal) {
  var phis = {};
  journal.forEach(function(entry) {
    entry.events.forEach(function(event) {
      if (!(event in phis))
        phis[event] = phi(tableFor(event, journal));
    });
  });
  return phis;
}
----

== Функции высшего порядка ==

(((function,higher-order)))(((function,as value)))Функции, оперирующие другими функциями — либо принимая их в качестве аргументов, либо возвращая их, называются _функциями высшего порядка_. Если вы уже поняли, что функции – это всего лишь переменные, ничего особенного в существовании таких функций нет. Термин происходит из ((математики)), где различия между функциями и другими значениями воспринимаются более строго.

(((abstraction)))Функции высшего порядка позволяют нас абстрагировать _действия_, а не только значения. Они бывают разными. Например, можно сделать функцию, создающую новые функции.

[source,javascript]
----
function greaterThan(n) {
  return function(m) { return m > n; };
}
var greaterThan10 = greaterThan(10);
console.log(greaterThan10(11));
// → true
----

Можно сделать функцию, меняющую другие функции.

[source,javascript]
----
function noisy(f) {
  return function(arg) {
    console.log("calling with", arg);
    var val = f(arg);
    console.log("called with", arg, "- got", val);
    return val;
  };
}
noisy(Boolean)(0);
// → calling with 0
// → called with 0 - got false
----

Можно даже делать функции, создающие новые типы ((управления потоком)) выполнения программы.

[source,javascript]
----
function unless(test, then) {
  if (!test) then();
}
function repeat(times, body) {
  for (var i = 0; i < times; i++) body(i);
}

repeat(3, function(n) {
  unless(n % 2, function() {
    console.log(n, "is even");
  });
});
// → 0 is even
// → 2 is even
----

(((inner function)))(((nesting,of functions)))((({} (block))))(((local variable)))(((closure)))Правила ((лексических областей)) видимости, которые мы обсуждали в link:03_functions.html#scoping[Главе 3], работают нам на пользу в таких случаях. В последнем примере переменная `n` – это ((аргумент)) внешней функции. Поскольку внутренняя функция живёт в окружении внешней, она может использовать `n`. Тела таких внутренних функций имеют доступ к переменным, окружающим их. Они могут играть роль блоков `{}`, используемых в обычных циклах и условных выражениях. Важное отличие в том, что переменные, объявленные внутри внутренних функций, не попадают в окружение внешней. И обычно это только к лучшему.

== Передача аргументов ==

(((function,wrapping)))(((arguments object)))Функция `noisy`, объявленная ранее, которая передаёт свой аргумент в другую функцию, не совсем удобна.

[source,javascript]
----
function noisy(f) {
  return function(arg) {
    console.log("calling with", arg);
    var val = f(arg);
    console.log("called with", arg, "- got", val);
    return val;
  };
}
----

Если `f` принимает больше одного ((параметр))а, она получит только первый. Можно было бы добавить кучу аргументов к внутренней функции (`arg1`, `arg2` и т.д.) и передать всех их в `f`, но ведь неизвестно, какого количества нам хватит. Кроме того, функция `f` не могла бы корректно работать с `arguments.length`. Так как мы всё время передавали бы одинаковое число аргументов, было бы неизвестно, сколько аргументов нам было задано изначально.

(((apply method)))(((array-like object)))(((function,application)))Для таких случаев у функций в JavaScript есть метод `apply`. Ему передают массив (или объект в виде массива) из аргументов, а он вызывает функцию с этими аргументами.

[source,javascript]
----
function transparentWrapping(f) {
  return function() {
    return f.apply(null, arguments);
  };
}
----

(((null)))Данная функция бесполезна, но она демонстрирует интересующий нас шаблон – возвращаемая ею функция передаёт в `f` все полученные ею аргументы, но не более того. Происходит это при помощи передачи её собственных аргументов, хранящихся в объекте `arguments`, в метод `apply`. Первый аргумент метода `apply`, которому мы в данном случае присваиваем `null`, можно использовать для эмуляции вызова ((метод))а. Мы вернёмся к этому вопросу в link:06_object.html#call_method[следующей главе].

== JSON ==

(((array)))(((function,higher-order)))(((forEach method)))(((data set)))Функции высшего порядка, которые каким-то образом применяют функцию к элементам массива, широко распространены в JavaScript. Метод `forEach` – одна из самых примитивных подобных функций. В качестве методов массивов нам доступно много других вариантов функций. Для знакомства с ними давайте поиграем с другим набором данных.

(((ancestry example)))Несколько лет назад кто-то обследовал много архивов и сделал целую книгу по истории моей фамилии. Я открыл её, надеясь найти там рыцарей, пиратов и алхимиков… Но оказалось, что она заполнена в основном фламандскими ((фермер))ами. Для развлечения я извлёк информацию по моим непосредственным предкам и оформил в формате, пригодном для чтения компьютером.

(((data format)))(((JSON)))Файл выглядит примерно так:

[source,application/json]
----
[
  {"name": "Emma de Milliano", "sex": "f",
   "born": 1876, "died": 1956,
   "father": "Petrus de Milliano",
   "mother": "Sophia van Damme"},
  {"name": "Carolus Haverbeke", "sex": "m",
   "born": 1832, "died": 1905,
   "father": "Carel Haverbeke",
   "mother": "Maria van Brussel"},
  … и так далее
]
----

indexsee:[JavaScript Object Notation,JSON](((World Wide Web)))Этот формат называется JSON, что означает JavaScript Object Notation (разметка объектов JavaScript). Он широко используется в хранении данных и сетевых коммуникациях.

(((array)))(((object)))(((quoting,in JSON)))(((comment)))JSON похож на JavaScript по способу записи массивов и объектов – с некоторыми ограничениями. Все имена свойств должны быть заключены в двойные кавычки, а также допускаются только простые величины – никаких вызовов функций, переменных, ничего что включало бы вычисления. Также не допускаются комментарии.

(((JSON.stringify function)))(((JSON.parse function)))(((serialization)))(((deserialization)))(((parsing)))JavaScript предоставляет функции `JSON.stringify` и `JSON.parse`, которые преобразовывают данные из этого формата и в этот формат. Первая принимает значение и возвращает строчку с JSON. Вторая принимает такую строчку и возвращает значение.

[source,javascript]
----
var string = JSON.stringify({name: "X", born: 1980});
console.log(string);
// → {"name":"X","born":1980}
console.log(JSON.parse(string).born);
// → 1980
----

(((ANCESTRY_FILE data set)))Переменная `ANCESTRY_FILE` доступна в ((песочнице)) к этой главе и в http://eloquentjavascript.net/2nd_edition/code/ancestry.js[скачиваемом файле] на сайте(!book (http://eloquentjavascript.net/2nd_edition/code#5[_eloquentjavascript.net/2nd_edition/code#5_])!). Она содержит ((JSON)) файл в виде строки. Давайте её раскодируем и посчитаем количество упомянутых людей.

// include_code strip_log

[source,javascript]
----
var ancestry = JSON.parse(ANCESTRY_FILE);
console.log(ancestry.length);
// → 39
----

== Фильтруем массив ==

(((array,methods)))(((array,filtering)))(((filter method)))(((function,higher-order)))(((predicate function)))Чтобы найти людей, которые были молоды в 1924 году, может пригодиться следующая функция. Она отфильтровывает элементы массива, которые не проходят проверку.

[source,javascript]
----
function filter(array, test) {
  var passed = [];
  for (var i = 0; i < array.length; i++) {
    if (test(array[i]))
      passed.push(array[i]);
  }
  return passed;
}

console.log(filter(ancestry, function(person) {
  return person.born > 1900 && person.born < 1925;
}));
// → [{name: "Philibert Haverbeke", …}, …]
----

(((function,as value)))(((function,application)))Используется аргумент с именем `test` – это функция, которая производит вычисления для проверки. Она вызывается для каждого элемента, а возвращаемое ею значение определяет, попадает ли этот элемент в возвращаемый массив.

(((ancestry example)))В файле оказалось три человека, которые были молоды в 1924 – дедушка, бабушка и двоюродная бабушка.

(((filter method)))(((pure function)))(((side effect)))Обратите внимание — функция `filter` не удаляет элементы из существующего массива, а строит новый, содержащий только прошедшие проверку элементы. Это _чистая_ функция, потому что она не портит переданный ей массив.

Как и `forEach`, `filter` – это один из ((стандарт))ных методов массива. В примере мы описали такую функцию, только чтобы показать, что она делает внутри. Отныне мы будем использовать её просто:

[source,javascript]
----
console.log(ancestry.filter(function(person) {
  return person.father == "Carel Haverbeke";
}));
// → [{name: "Carolus Haverbeke", …}]
----

== Преобразования при помощи map ==

(((array,methods)))(((map method)))(((ancestry example)))Допустим, есть у нас архив объектов, представляющих людей, который был получен фильтрацией массива предков. Но нам нужен массив имён, который было бы проще прочесть.

(((function,higher-order)))Метод `map` преобразовывает массив, применяя функцию ко всем его элементам и строя новый массив из возвращаемых значений. У нового массива будет та же длина, что у входного, но его содержимое будет преобразовано в новый формат.

// test: join

[source,javascript]
----
function map(array, transform) {
  var mapped = [];
  for (var i = 0; i < array.length; i++)
    mapped.push(transform(array[i]));
  return mapped;
}

var overNinety = ancestry.filter(function(person) {
  return person.died - person.born > 90;
});
console.log(map(overNinety, function(person) {
  return person.name;
}));
// → ["Clara Aernoudts", "Emile Haverbeke",
//    "Maria Haverbeke"]
----

Что интересно, люди, которые прожили хотя бы до 90 лет – это те самые, что мы видели ранее, которые были молоды в 1920-х годах. Это как раз самое новое поколение в моих записях. Видимо, ((медицина)) серьёзно улучшилась.

Как и `forEach` и `filter`, `map` также является стандартным методом у массивов.

== Суммирование с reduce ==

(((array,methods)))(((summing example)))(((reduce method)))(((ancestry example)))Другой популярный пример работы с массивами – получение одиночного значения на основе данных в массиве. Один пример – уже знакомое нам суммирование списка номеров. Другой – поиск человека, родившегося раньше всех.

(((function,higher-order)))(((fold function)))Операция высшего порядка такого типа называется _уменьшение_ (_reduce_) или иногда _свёртывание_ (_fold_). Можно представить её в виде складывания массива, по одному элементу за раз. При суммировании чисел мы начинали с нуля, и для каждого элемента комбинировали его с текущей суммой при помощи сложения.

Параметры функции `reduce`, кроме массива – комбинирующая функция и начальное значение. Эта функция чуть менее понятная, чем `filter` или `map`, поэтому обратите на неё пристальное внимание.

[source,javascript]
----
function reduce(array, combine, start) {
  var current = start;
  for (var i = 0; i < array.length; i++)
    current = combine(current, array[i]);
  return current;
}

console.log(reduce([1, 2, 3, 4], function(a, b) {
  return a + b;
}, 0));
// → 10
----

(((reduce method)))Стандартный метод массивов `reduce`, который, конечно, работает так же, ещё более удобен. Если массив содержит хотя бы один элемент, вы можете не указывать аргумент `start`. Метод возьмёт в качестве стартового значения первый элемент массива и начнёт работу со второго.

(((ancestry example)))(((minimum)))Чтобы при помощи `reduce` найти самого древнего из известных моих предков, мы можем написать нечто вроде:

// test: no

[source,javascript]
----
console.log(ancestry.reduce(function(min, cur) {
  if (cur.born < min.born) return cur;
  else return min;
}));
// → {name: "Pauwels van Haverbeke", born: 1535, …}
----

== Компонуемость ==

(((loop)))(((minimum)))(((ancestry example)))Как бы мы могли написать предыдущий пример (поиск человека с самой ранней датой рождения) без функций высшего порядка? На самом деле, код не такой уж и ужасный.

// test: no

[source,javascript]
----
var min = ancestry[0];
for (var i = 1; i < ancestry.length; i++) {
  var cur = ancestry[i];
  if (cur.born < min.born)
    min = cur;
}
console.log(min);
// → {name: "Pauwels van Haverbeke", born: 1535, …}
----

Чуть больше ((переменных)), на две строчки длиннее – но пока достаточно понятный код.

[[average_function]]
(((average function)))(((composability)))(((function,higher-order)))Функции высшего порядка раскрывают свои возможности по-настоящему, когда вам приходится _комбинировать_ функции. К примеру, напишем код, находящий средний возраст мужчин и женщин в наборе.

// test: clip

[source,javascript]
----
function average(array) {
  function plus(a, b) { return a + b; }
  return array.reduce(plus) / array.length;
}
function age(p) { return p.died - p.born; }
function male(p) { return p.sex == "m"; }
function female(p) { return p.sex == "f"; }

console.log(average(ancestry.filter(male).map(age)));
// → 61.67
console.log(average(ancestry.filter(female).map(age)));
// → 54.56
----

(((plus function)))(((+ operator)))(((function,as value)))(Глупо, что нам приходится определять сложение как функцию `plus`, но операторы в JavaScript не являются значениями, поэтому их не передашь в качестве аргументов.)

(((abstraction)))(((vocabulary)))Вместо того чтобы впутывать алгоритм в большой ((цикл)), всё распределено по концепциям, которые нас интересуют – определение пола, подсчёт возраста и усреднение чисел. Мы применяем их по очереди для получения результата.

Для написания понятного кода это прямо-таки _сказочная_ возможность. Конечно, ясность не достаётся бесплатно.

== Цена ==

(((efficiency)))(((optimization)))В счастливом краю элегантного кода и красивых радуг живёт гадское чудище по имени _Неэффективность_.

(((elegance)))(((array,creation)))(((pure function)))(((composability)))Программа, обрабатывающая массив, красивее всего представляется в виде последовательности явно разделённых шагов, каждый из которых что-то делает с массивом и возвращает новый массив. Но наслоение всех этих промежуточных массивов стоит дорого.

(((readability)))(((function,application)))(((forEach method)))(((function,as value)))Точно так же, передача функции в `forEach`, чтобы та прошлась по массиву за нас, удобна и проста в понимании. Но вызов функций в JavaScript обходится дороже по сравнению с циклами.

(((abstraction)))Так же обстоят дела со многими техниками, улучшающими читаемость программ. Абстракции добавляют слои между чистой работой компьютера и теми концепциями, с которыми мы работаем – и в результате компьютер делает больше работы. Это не железное правило – есть языки, которые позволяют добавлять абстракции без ухудшения эффективности, и даже в JavaScript опытный программист может найти способы писать абстрактный и быстрый код. Но эта проблема встречается часто.

(((profiling)))К счастью, большинство компьютеров безумно быстрые. Если ваш набор данных не слишком велик, или время работы должно быть всего лишь достаточно быстрым с точки зрения человека (например, делать что-то каждый раз, когда пользователь жмёт на кнопку) — тогда _не имеет значения_, написали вы красивое решение, которое работает половину миллисекунды, или очень оптимизированное, которое работает одну десятую миллисекунды.

(((nesting,of loops)))(((inner loop)))(((complexity)))Удобно примерно подсчитывать, как часто будет вызываться данный кусочек кода. Если у вас есть ((цикл)) в цикле (напрямую, или же через вызов в цикле функции, которая внутри также работает с циклом), то код будет выполнен __N__×__M__ раз, где _N_ – количество повторений внешнего цикла, а _M_ – внутреннего. Если во внутреннем цикле есть ещё один цикл, повторяющийся _P_ раз, тогда мы уже получим __M__×__N__×__P__ – и так далее. Это может приводить к большим числам, и когда программа тормозит, проблему часто можно свести к небольшому кусочку кода, находящемуся внутри самого внутреннего цикла.

== Пра-пра-пра-пра-пра-… ==

(((ancestry example)))Мой ((дед)), Филиберт Хавербеке, упомянут в файле с данными. Начиная с него, я могу отследить свой род в поисках самого древнего из предков, Паувелса ван Хавербеке, моего прямого предка. Теперь я хочу подсчитать, какой процент ((ДНК)) у меня от него (в теории).

(((byName object)))(((map)))(((data structure)))(((object,as map)))Чтобы пройти от имени предка до объекта, представляющего его, мы строим объект, который сопоставляет имена и людей.

// include_code strip_log

[source,javascript]
----
var byName = {};
ancestry.forEach(function(person) {
  byName[person.name] = person;
});

console.log(byName["Philibert Haverbeke"]);
// → {name: "Philibert Haverbeke", …}
----

Задача – не просто найти у каждой из записей отца и посчитать, сколько шагов получается до Паувелса. В истории семьи было несколько браков между двоюродными родственниками (ну, маленькие деревни и т.д.). В связи с этим ветви семейного ((дерева)) в некоторых местах соединяются с другими, поэтому генов у меня получается больше, чем 1/2^_G_^ (_G_ – количество поколений между Паувелсом и мною). Эта формула исходит из предположения, что каждое поколение расщепляет генетический фонд надвое.

(((reduce method)))(((data structure)))Разумно будет провести аналогию с `reduce`, где массив низводится до единственного значения путём последовательного комбинирования данных слева направо. Здесь нам тоже надо получить единственное число, но при этом нужно следовать линиям наследственности. А они _формируют_ не простой список, а дерево.

Мы считаем это значение для конкретного человека, комбинируя эти значения его предков. Это можно сделать рекурсивно. Если нам нужен какой-то человек, нам надо подсчитать нужную величину для его родителей, что в свою очередь требует подсчёта её для его прародителей, и т.п. По идее нам придётся обойти бесконечное множество узлов дерева, но так как наш набор данных конечен, нам надо будет где-то остановиться. Мы просто назначим ((значение по умолчанию)) для всех людей, которых нет в нашем списке. Логично будет назначить им нулевое значение – люди, которых нет в списке, не несут в себе ДНК нужного нам предка.

(((recursion)))(((reduceAncestors function)))Принимая человека, функцию для комбинирования значений от двух предков и значение по умолчанию, функция `reduceAncestors` “конденсирует” значение из семейного древа.

// include_code

[source,javascript]
----
function reduceAncestors(person, f, defaultValue) {
  function valueFor(person) {
    if (person == null)
      return defaultValue;
    else
      return f(person, valueFor(byName[person.mother]),
                       valueFor(byName[person.father]));
  }
  return valueFor(person);
}
----

(((function,higher-order)))Внутренняя функция `valueFor` работает с одним человеком. Благодаря рекурсивной ((магии)) она может вызвать себя для обработки отца и матери этого человека. Результаты вместе с объектом `person` передаются в `f`, которая и вычисляет нужное значение для этого человека.

Теперь мы можем использовать это для подсчёта процента ((ДНК)), которое мой ((дедушка)) разделил с Паувелсом ванн Хавербеке, и поделить это на четыре.

// start_code bottom_lines: 2
// test: clip
// include_code top_lines: 6

[source,javascript]
----
function sharedDNA(person, fromMother, fromFather) {
  if (person.name == "Pauwels van Haverbeke")
    return 1;
  else
    return (fromMother + fromFather) / 2;
}
var ph = byName["Philibert Haverbeke"];
console.log(reduceAncestors(ph, sharedDNA, 0) / 4);
// → 0.00049
----

Человек по имени Паувелс ванн Хавербеке, очевидно, делит 100% ДНК с Паувелсом ванн Хавербеке (полных тёзок в списке данных нет), поэтому для него функция возвращает 1. Все остальные делят средний процент их родителей.

Статистически у меня примерно 0.05% ((ДНК)) совпадает с моим предком из 16 века. Это, конечно, приблизительное число. Это довольно мало, но так как наш генетический материал составляет примерно 3 миллиарда базовых пар, во мне есть что-то от моего предка.

(((ancestry example)))(((reduceAncestors function)))(((abstraction)))Можно было бы подсчитать это число и без использования `reduceAncestors`. Но разделение общего подхода (обход древа) и конкретного случая (подсчёт ДНК) позволяет нам писать более понятный код и использовать вновь части кода для других задач. Например, следующий код выясняет процент известных предков данного человека, доживших до 70 лет:

// test: clip

[source,javascript]
----
function countAncestors(person, test) {
  function combine(current, fromMother, fromFather) {
    var thisOneCounts = current != person && test(current);
    return fromMother + fromFather + (thisOneCounts ? 1 : 0);
  }
  return reduceAncestors(person, combine, 0);
}
function longLivingPercentage(person) {
  var all = countAncestors(person, function(person) {
    return true;
  });
  var longLiving = countAncestors(person, function(person) {
    return (person.died - person.born) >= 70;
  });
  return longLiving / all;
}
console.log(longLivingPercentage(byName["Emile Haverbeke"]));
// → 0.129
----

Не нужно относиться к таким расчётам слишком серьёзно, так как наш набор содержит произвольную выборку людей. Но код демонстрирует, что `reduceAncestors` – полезная часть общего ((словаря)) для работы со структурой данных типа фамильного древа.

== Связывание ==

(((bind method)))(((partial application)))(((function,application)))Метод `bind`, который есть у всех функций, создаёт новую функцию, которая вызовет оригинальную, но с некоторыми фиксированными аргументами.

(((filter method)))(((function,as value)))Следующий пример показывает, как это работает. В нём мы определяем функцию `isInSet`, которая говорит, есть ли имя человека в заданном наборе. Для вызова `filter` мы можем либо написать выражение с функцией, которое вызывает `isInSet`, передавая ей набор строк в качестве первого аргумента, или применить функцию `isInSet` _частично_.

[source,javascript]
----
var theSet = ["Carel Haverbeke", "Maria van Brussel",
              "Donald Duck"];
function isInSet(set, person) {
  return set.indexOf(person.name) > -1;
}

console.log(ancestry.filter(function(person) {
  return isInSet(theSet, person);
}));
// → [{name: "Maria van Brussel", …},
//    {name: "Carel Haverbeke", …}]
console.log(ancestry.filter(isInSet.bind(null, theSet)));
// → … same result
----

Вызов `bind` возвращает функцию, которая вызовет `isInSet` с первым аргументом `theSet`, и последующими аргументами такими же, какие были переданы в связанную функцию.

(((null)))Первый аргумент, который сейчас установлен в `null`, используется для ((вызовов методов)) – так же, как было в `apply`. Мы поговорим об этом в link:06_object.html#call_method[следующей главе].

== Итог ==

Возможность передавать вызов функции другим функциям – не просто игрушка, но очень полезное свойство JavaScript. Мы можем писать выражения “с пробелами” в них, которые затем будут заполнены при помощи функций, описывающих пропущенные вычисления.

У массивов есть несколько полезных методов высшего порядка – `forEach`, чтобы сделать что-то с каждым элементом, `filter` – чтобы построить новый массив, где некоторые значения отфильтрованы, `map` – чтобы построить новый массив, каждый элемент которого пропущен через функцию, `reduce` – для комбинации всех элементов массива в одно значение.

У функций есть метод `apply`, для передачи им аргументов в виде массива. Также у них есть метод `bind` для создания копии функции с частично заданными аргументами.

== Упражнения ==

=== Свёртка ===

(((flattening (exercise))))(((reduce method)))(((concat method)))(((array)))Используйте метод `reduce` в комбинации с `concat` для “свёртки” массива массивов в один массив, у которого есть все элементы входных массивов.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
var arrays = [[1, 2, 3], [4, 5], [6]];
// Ваш код тут.
// → [1, 2, 3, 4, 5, 6]
----
endif::interactive_target[]

=== Разница в возрасте матерей и их детей ===

(((ancestry example)))(((age difference (exercise))))(((average function)))Используя набор данных из примера, подсчитайте среднюю разницу в возрасте между матерями и их детьми (это возраст матери во время появления ребёнка). Можно использовать функцию `average`, приведённую link:05_higher_order.html#average_function[ранее] в главе.

(((byName object)))Обратите внимание – не все матери, упомянутые в наборе, присутствуют в нём. Здесь может пригодиться объект `byName`, который упрощает процедуру поиска объекта человека по имени.

ifdef::interactive_target[]

// test: no
// include_code

[source,javascript]
----
function average(array) {
  function plus(a, b) { return a + b; }
  return array.reduce(plus) / array.length;
}

var byName = {};
ancestry.forEach(function(person) {
  byName[person.name] = person;
});

// Ваш код тут.

// → 31.2
----
endif::interactive_target[]

!!hint!!

(((age difference (exercise))))(((filter method)))(((map
method)))(((null)))(((average function)))Because not all elements in
the `ancestry` array produce useful data (we can't compute the age
difference unless we know the birth date of the mother), we will have
to apply `filter` in some manner before calling `average`. You could
do it as a first pass, by defining a `hasKnownMother` function and
filtering on that first. Alternatively, you could start by calling
`map` and in your mapping function return either the age difference
or `null` if no mother is known. Then, you can call `filter` to remove
the `null` elements before passing the array to `average`.

!!hint!!

=== Историческая ожидаемая продолжительность жизни ===

(((life expectancy (exercise))))Мы считали, что только последнее поколение людей дожило до 90 лет. Давайте рассмотрим этот феномен поподробнее.

(((average function)))Подсчитайте средний возраст людей для каждого из столетий. Назначаем ((столетию)) людей, беря их год смерти, деля его на 100 и округляя: `Math.ceil(person.died / 100)`.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
function average(array) {
  function plus(a, b) { return a + b; }
  return array.reduce(plus) / array.length;
}

// Your code here.

// → 16: 43.5
//   17: 51.2
//   18: 52.8
//   19: 54.8
//   20: 84.7
//   21: 94
----
endif::interactive_target[]

!!hint!!

(((life expectancy (exercise))))The essence of this example lies in
((grouping)) the elements of a collection by some aspect of
theirs—splitting the array of ancestors into smaller arrays with the
ancestors for each century.

(((array)))(((map)))(((object,as map)))During the grouping
process, keep an object that associates ((century)) names (numbers)
with arrays of either person objects or ages. Since we do not know in
advance what categories we will find, we'll have to create them on the
fly. For each person, after computing their century, we test whether
that century was already known. If not, add an array for it. Then add
the person (or age) to the array for the proper century.

(((for/in loop)))(((average function)))Finally, a `for`/`in` loop can
be used to print the average ages for the individual centuries.

!!hint!!

(((grouping)))(((map)))(((object,as map)))(((groupBy function)))В качестве призовой игры напишите функцию `groupBy`, абстрагирующую операцию группировки. Она должна принимать массив и функцию, которая подсчитывает группу для элементов массива, и возвращать объект, который сопоставляет названия групп массивам членов этих групп.

=== Every и some ===

(((predicate function)))(((every and some (exercise))))(((every method)))(((some method)))(((array,methods)))(((&& operator)))(((|| operator)))У массивов есть ещё стандартные методы `every` и `some`. Они принимают как аргумент некую функцию, которая, будучи вызванной с элементом массива в качестве аргумента, возвращает true или false. Так же, как `&&` возвращает true, только если выражения с обеих сторон оператора возвращают true, метод `every` возвращает true, когда функция возвращает true для _всех_ элементов массива. Соответственно, `some` возвращает true, когда заданная функция возвращает true при работе с _любым_ из элементов массива. Они не обрабатывают больше элементов, чем необходимо – например, если `some` получает true для первого элемента, он не обрабатывает оставшиеся.

Напишите функции `every` и `some`, которые работают так же, как эти методы, только принимают массив в качестве аргумента.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.

console.log(every([NaN, NaN, NaN], isNaN));
// → true
console.log(every([NaN, NaN, 4], isNaN));
// → false
console.log(some([NaN, 3, 4], isNaN));
// → true
console.log(some([2, 3, 4], isNaN));
// → false
----
endif::interactive_target[]

!!hint!!

(((every and some (exercise))))(((short-circuit evaluation)))(((return
keyword)))The functions can follow a similar pattern to the
link:05_higher_order.html#forEach[definition] of `forEach` at the
start of the chapter, except that they must return immediately (with
the right value) when the predicate function returns false—or true.
Don't forget to put another `return` statement after the loop so that
the function also returns the correct value when it reaches the end of
the array.

!!hint!!
