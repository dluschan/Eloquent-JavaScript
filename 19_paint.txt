:chap_num: 19
:prev_link: 18_forms
:next_link: 20_node
:load_files: ["code/chapter/19_paint.js"]
:zip: html include=["css/paint.css"]

= Проект: программа Paint =

[quote,Жоан Миро,]
____
Я смотрю на многообразие цветов. Я смотрю на пустой холст. Затем я пытаюсь нанести цвета как слова, из которых возникают поэмы, как ноты, из которых возникает музыка.
____

(((Miro+++,+++ Joan)))(((drawing program example)))(((project chapter)))Материал предыдущих глав даёт вам всё необходимое для создания простого ((веб-приложения)). Именно этим мы и займёмся.

Наше приложение будет программой для ((рисования)) в браузере, схожей с ((Microsoft Paint)). С его помощью можно будет открывать ((файлы)) с изображениями, малевать на них мышкой и сохранять обратно. Вот, как это будет выглядеть:

image::img/paint.png[alt="A simple paint program"]

Рисовать на компьютере клёво. Не надо волноваться насчёт материалов, ((умения)), таланта. Просто берёшь, и начинаешь калякать.

== Реализация ==

(((drawing)))(((select (HTML tag))))(((canvas (HTML tag))))Интерфейс программы выводит вверху большой элемент `<canvas>`, под которым есть несколько ((поле))й ввода. Пользователь рисует на ((картинке)), выбирая инструмент из поля `<select>`, а затем нажимая на холсте мышь. Есть ((инструмент))ы для рисования линий, стирания кусочков картинки, добавления текста и т.п.

(((line tool)))(((mouse)))(((mousedown event)))(((mousemove event)))(((mouseup event)))Щелчок на холсте передаёт событие `"mousedown"` текущему инструменту, который обрабатывает его, как считает нужным. ((Рисование)) линий, например, будет слушать события `"mousemove"`, пока кнопка мыши не будет отпущена, и нарисует линию по пути мыши текущим ((цвет))ом и ((размер))ом кисти.

(((fillStyle property)))(((strokeStyle property)))(((lineWidth property)))(((change event)))Цвет и размер кисти выбираются в дополнительных полях ввода. Они выполняют обновление свойств контекста рисования на холсте `fillStyle`, `strokeStyle`, и `lineWidth` каждый раз при их изменении.

Загрузить ((картинку)) в программу можно двумя способами. Первый использует поле `file`, где пользователь выбирает файл из своей файловой системы. Вторая запрашивает ((URL)) и скачивает картинку из интернета.

(((saving)))Картинки хранятся нестандартным способом. ((Ссылка)) `save` с правой стороны ведёт на текущую картинку. По ней можно проходить, делиться ей или сохранять файл через неё. Я скоро объясню, как это работает.

== Строим DOM ==

Интерфейс программы состоит из более чем 30 элементов ((DOM)). Нужно их как-то собрать вместе.

(((HTML)))(((querySelector method)))(((event handling)))Очевидным форматом для сложных структур DOM является HTML. Но разделять программу на HTML и скрипт неудобно – для элементов DOM понадобится множество обработчиков событий или других необходимых вещей, которые надо будет как-то обрабатывать из скрипта. Для этого придётся делать много вызовов `querySelector` и им подобных, чтобы найти нужный элемент DOM для работы.

(((DOM,construction)))(((readability)))(((verbosity)))(((createElement method)))Было бы удобно определять части DOM рядом с теми частями кода JavaScript, которые ими управляют. Поэтому я решил создавать всю конструкцию DOM прямо в JavaScript. Как мы видели в link:13_dom.html#standard[главе 13], встроенный интерфейс для создания структур DOM ужасно многословен. Поскольку нам придётся создать много конструкций, нам понадобится вспомогательная функция.

(((elt function)))Эта функция – расширенная версия функции `elt` из link:13_dom.html#elt[главы 13]. Она создаёт элемент с заданным именем и ((атрибут))ами, и добавляет все остальные аргументы, которые получает, в качестве дочерних узлов, автоматически преобразовывая строки в ((текстовые узлы)).

// include_code

[sandbox="paint"]
[source,javascript]
----
function elt(name, attributes) {
  var node = document.createElement(name);
  if (attributes) {
    for (var attr in attributes)
      if (attributes.hasOwnProperty(attr))
        node.setAttribute(attr, attributes[attr]);
  }
  for (var i = 2; i < arguments.length; i++) {
    var child = arguments[i];
    if (typeof child == "string")
      child = document.createTextNode(child);
    node.appendChild(child);
  }
  return node;
}
----

Так мы легко и просто создаём элементы, не раздувая код до размеров лицензионного соглашения.

== Основание ==

(((createPaint function)))(((controls object)))Ядро нашей программы – функция `createPaint`, добавляющая интерфейс рисования к элементу DOM, который передаётся в качестве аргумента. Так как мы создаём программу последовательно, мы определяем объект `controls`, который будет содержать функции для инициализации разных элементов управления под картинкой.

// include_code

[sandbox="paint"]
[source,javascript]
----
var controls = Object.create(null);

function createPaint(parent) {
  var canvas = elt("canvas", {width: 500, height: 300});
  var cx = canvas.getContext("2d");
  var toolbar = elt("div", {class: "toolbar"});
  for (var name in controls)
    toolbar.appendChild(controls[name](cx));

  var panel = elt("div", {class: "picturepanel"}, canvas);
  parent.appendChild(elt("div", null, panel, toolbar));
}
----

(((fillStyle property)))(((lineWidth property)))(((canvas property)))(((context)))У каждого элемента управления есть доступ к контексту рисования на ((холст))е, а через него – к элементу `<canvas>` через свойство `canvas`. Основное состояние программы хранится в этом холсте – он содержит текущую картинку, выбранный цвет (в свойстве `fillStyle`) и размер кисти (в свойстве `lineWidth`).

(((class attribute)))(((CSS)))Мы обернём холст и элементы управления в элементы `<div>` с классами, чтобы можно было добавить им стили, например серую рамку вокруг картинки.

== Выбор инструмента ==

(((mouse)))(((tools object)))(((hard-coding)))(((select (HTML tag))))Первый элемент управления, который мы добавим – элемент `<select>`, позволяющий выбирать ((инструмент)) рисования. Как и в случае с `controls`, мы будем использовать объект для сбора необходимых инструментов, чтобы не надо было описывать их работу в коде по отдельности, и чтобы можно было легко добавлять новые. Этот объект связывает названия инструментов с функцией, которая вызывается при их выборе и при клике на холсте.

// include_code

[sandbox="paint"]
[source,javascript]
----
var tools = Object.create(null);

controls.tool = function(cx) {
  var select = elt("select");
  for (var name in tools)
    select.appendChild(elt("option", null, name));

  cx.canvas.addEventListener("mousedown", function(event) {
    if (event.which == 1) {
      tools[select.value](event, cx);
      event.preventDefault();
    }
  });

  return elt("span", null, "Tool: ", select);
};
----

(((preventDefault method)))(((selection)))(((option (HTML tag))))(((mousedown event)))В поле `tool` есть элементы `<option>` для всех определённых нами инструментов, а обработчик события `"mousedown"` на холсте берёт на себя обязанность вызывать функцию текущего инструмента, передавая ей объекты `event` и `context`. Также он вызывает `preventDefault`, чтобы зажатие и перетаскивание мыши не вызывало выделения участков страницы.

(((relativePos function)))(((event object)))(((getBoundingClientRect method)))(((clientX property)))(((clientY property)))Самый простой инструмент – ((линия)), который рисует линии за ((мышью)). Чтобы рисовать линию, нам надо сопоставить ((координаты)) курсора мыши с координатами точек на холсте. Вскользь упомянутый в link:13_dom.html#boundingRect[главе 13] метод `getBoundingClientRect` может нам в этом помочь. Он говорит, где находится элемент, относительно левого верхнего угла экрана. Свойства события мыши `clientX` и `clientY` также содержат координаты относительно этого угла, поэтому мы можем вычесть верхний левый угол холста из них и получить позицию относительно этого угла.

// include_code

[sandbox="paint"]
[source,javascript]
----
function relativePos(event, element) {
  var rect = element.getBoundingClientRect();
  return {x: Math.floor(event.clientX - rect.left),
          y: Math.floor(event.clientY - rect.top)};
}
----

(((mouseup event)))(((mousemove event)))(((trackDrag function)))Несколько инструментов рисования должны слушать событие `"mousemove"`, пока кнопка мыши нажата. Функция `trackDrag` регистрирует и убирает событие для данных ситуаций.

// include_code

[sandbox="paint"]
[source,javascript]
----
function trackDrag(onMove, onEnd) {
  function end(event) {
    removeEventListener("mousemove", onMove);
    removeEventListener("mouseup", end);
    if (onEnd)
      onEnd(event);
  }
  addEventListener("mousemove", onMove);
  addEventListener("mouseup", end);
}
----

У неё два аргумента. Один – функция, которая вызывается при каждом событии `"mousemove"`, а другая – функция, которая вызывается при отпускании кнопки. Любой аргумент может быть не задан.

(((line tool)))Инструмент для рисования линий использует две вспомогательные функции для самого рисования.

// include_code

[sandbox="paint"]
[source,javascript]
----
tools.Line = function(event, cx, onEnd) {
  cx.lineCap = "round";

  var pos = relativePos(event, cx.canvas);
  trackDrag(function(event) {
    cx.beginPath();
    cx.moveTo(pos.x, pos.y);
    pos = relativePos(event, cx.canvas);
    cx.lineTo(pos.x, pos.y);
    cx.stroke();
  }, onEnd);
};
----

(((path,canvas)))(((lineCap property)))(((line)))Функция сначала устанавливает свойство контекста `lineCap` в `"round"`, из-за чего концы нарисованного пути становятся закруглёнными, а не квадратными, как это происходит по умолчанию. Этот трюк обеспечивает непрерывность линий, когда они нарисованы в несколько приёмов. Если рисовать линии большой ширины, вы увидите разрывы в углах линий, если будете использовать установку `lineCap` по умолчанию.

(((mousemove event)))(((strokeStyle property)))(((lineWidth property)))Затем, по каждому событию `"mousemove"`, которое случается, пока кнопка нажата, рисуется простая линия между старой и новой позициями мыши, с использованием тех значений параметров `strokeStyle` и `lineWidth`, которые заданы в данный момент.

(((erase tool)))Аргумент `onEnd` функции `tools.Line` просто передаётся дальше, в `trackDrag`. При обычном вызове третий аргумент передаваться не будет, и при использовании функции он будет содержать `undefined`, поэтому в конце перетаскивания ничего не произойдёт. Но он поможет нам организовать ещё один инструмент, ластик, используя очень небольшое дополнение к коду.

// include_code

[sandbox="paint"]
[source,javascript]
----
tools.Erase = function(event, cx) {
  cx.globalCompositeOperation = "destination-out";
  tools.Line(event, cx, function() {
    cx.globalCompositeOperation = "source-over";
  });
};
----

(((globalCompositeOperation property)))(((compositing)))(((erase tool)))Свойство `globalCompositeOperation` влияет на то, как операции рисования на холсте меняют цвет пикселей. По умолчанию, значение свойства `"source-over"`, что означает, что цвет, которым рисуют, накладывается поверх существующего. Если ((цвет)) непрозрачный, он просто заменит существующий, но если он частично прозрачный, они будут смешаны.

Инструмент “ластик” устанавливает `globalCompositeOperation` в `"destination-out"`, что имеет эффект ластика, и делает пиксели снова прозрачными.

(((drawing)))Вот у нас уже есть два инструмента для рисования. Мы можем рисовать чёрные линии в один пиксель шириной (это задано значениями свойств холста `strokeStyle` и `lineWidth` по умолчанию), и стирать их. Работающий, хотя и примитивный, прототип программы.

== Цвет и размер кисти ==

(((controls object)))Предполагая, что пользователи захотят рисовать не только чёрным ((цвет))ом и не только одним размером ((кисти)), добавим элементы управления для этих настроек.

(((color picker)))(((HTML5 form fields)))(((date field)))(((time field)))(((email field)))(((number field)))(((compatibility)))В link:18_forms.html#forms[главе 18] я обсуждал разные варианты ((полей)) формы. Среди них не было полей для выбора цвета. По традиции у браузеров нет встроенных полей для выбора цвета, но за последнее время в ((стандарт)) включили несколько новых типов полей форм. Один из них — `<input type="color">`. Среди других — `"date"`, `"email"`, `"url"` и `"number"`. Пока ещё их поддерживают не все ((браузер))ы. Для тега `<input>` тип по умолчанию – `"text"`, и при использовании нового тега, который ещё не поддерживается, браузеры будут обрабатывать его как текстовое поле. Значит, пользователям таких браузеров необходимо будет вписывать название цвета вместо того, чтобы выбирать его через удобный элемент управления.

ifdef::book_target[]

This is what a color picker may look like:

image::img/color-field.png[alt="A color field",width="6cm"]

endif::book_target[]

// include_code

[sandbox="paint"]
[source,javascript]
----
controls.color = function(cx) {
  var input = elt("input", {type: "color"});
  input.addEventListener("change", function() {
    cx.fillStyle = input.value;
    cx.strokeStyle = input.value;
  });
  return elt("span", null, "Color: ", input);
};
----

(((fillStyle property)))(((strokeStyle property)))(((change event)))При смене значения поля `color` значения свойств контекста холста `fillStyle` и `strokeStyle` заменяются на новое значение.

Настройка размера ((кисти)) работает сходным образом.

// include_code

[sandbox="paint"]
[source,javascript]
----
controls.brushSize = function(cx) {
  var select = elt("select");
  var sizes = [1, 2, 3, 5, 8, 12, 25, 35, 50, 75, 100];
  sizes.forEach(function(size) {
    select.appendChild(elt("option", {value: size},
                           size + " pixels"));
  });
  select.addEventListener("change", function() {
    cx.lineWidth = select.value;
  });
  return elt("span", null, "Brush size: ", select);
};
----

(((lineWidth property)))Код создаёт варианты размеров кистей из массива, и убеждается в том, что свойство холста `lineWidth` обновлено при выборе кисти.

== Сохранение ==

(((save link)))Чтобы объяснить, как работает ссылка на сохранение, сначала мне нужно рассказать про _((URL с данными))_. ((URL)) с данными - это URL с _data:_ в качестве ((протокол))а. В отличие от обычных _http:_ и _https:_, URL с данными не указывают на ресурс, а содержат весь ресурс в себе. Это URL с данными, содержащий простой HTML документ:

----
data:text/html,<h1 style="color:red">Hello!</h1>
----

Такие URL полезны для разных вещей, как, например, включение небольших картинок прямо в файл ((стилей)). Они также позволяют нам ссылаться на создаваемые файлы на стороне клиента, в браузере, не перемещая их сперва на какой-либо сервер.

(((canvas)))(((toDataURL method)))(((optimization)))(((href attribute)))У элемента холста есть удобный метод `toDataURL`, который возвращает URL с данными, содержащий картинку на холсте в виде графического файла. Но нам не следует обновлять ссылку для сохранения при каждом изменении картинки. В случае больших картинок перемещение данных в URL занимает много времени. Вместо этого мы подключаем обновление к ссылке, чтоб она обновляла свой атрибут `href` каждый раз, когда она получает фокус с клавиатуры или над ней появляется курсор мыши.

// include_code

[sandbox="paint"]
[source,javascript]
----
controls.save = function(cx) {
  var link = elt("a", {href: "/"}, "Save");
  function update() {
    try {
      link.href = cx.canvas.toDataURL();
    } catch (e) {
      if (e instanceof SecurityError)
        link.href = "javascript:alert(" +
          JSON.stringify("Can't save: " + e.toString()) + ")";
      else
        throw e;
    }
  }
  link.addEventListener("mouseover", update);
  link.addEventListener("focus", update);
  return link;
};
----

(((mouseover event)))(((focus event)))(((magic)))Таким образом, ссылка просто сидит себе тихонечко и указывает на неправильные данные, но как только пользователь приблизится к нему, он волшебным образом обновляет себя так, чтобы указывать на текущую картинку.

Если вы загрузите большую картинку, некоторые ((браузер))ы поперхнутся слишком большим URL с данными, который получится в результате. Для маленьких картинок система работает без проблем.

(((security)))(((privacy)))(((cross-domain request)))Но здесь мы опять сталкиваемся с деталями реализации ((песочницы)) в браузере. Когда ((картинка)) грузится с URL с другого ((домен))а, если ответ сервера не содержит заголовок, разрешающий использование ресурса с других доменов (см. link:17_http.html#http_sandbox[главу 17]), ((холст)) будет содержать информацию, которая будет видна _пользователю_, но не видна _скрипту_.

Мы могли запросить картинку с приватной информацией (график изменений банковского счёта). Если бы скрипт мог получить к ней доступ, он мог бы шпионить за пользователем.

(((tainting)))(((pixel)))Для предотвращения таких ((утечек)) информации, когда картинка, невидимая скрипту, будет загружена на холст, ((браузер))ы пометят его как _испорченный_. Пиксельные данные, включая URL с данными, нельзя будет получить с испорченного холста. На него можно писать, но с него нельзя читать.

(((try keyword)))(((toDataURL method)))(((exception handling)))(((SecurityError type)))Поэтому нам нужна обработка `try/catch` в функции `update` для ссылки сохранения. Когда холст портится, вызов `toDataURL` выбросит исключение, являющееся экземпляром `SecurityError`. В этом случае мы перенаправляем ссылку на ещё один вид URL с протоколом _javascript:_. Такие ссылки просто выполняют скрипт, стоящий после двоеточия, и наша ссылка покажет предупреждение, сообщающее о проблеме.

== Загрузка картинок ==

(((img (HTML tag))))(((load event)))(((file system)))Последние два элемента управления используются для загрузки картинок с локального диска и с URL. Нам потребуется вспомогательная функция, которая пробует загрузить картинку с ((URL)) и заменить ею содержимое холста:

// include_code

[sandbox="paint"]
[source,javascript]
----
function loadImageURL(cx, url) {
  var image = document.createElement("img");
  image.addEventListener("load", function() {
    var color = cx.fillStyle, size = cx.lineWidth;
    cx.canvas.width = image.width;
    cx.canvas.height = image.height;
    cx.drawImage(image, 0, 0);
    cx.fillStyle = color;
    cx.strokeStyle = color;
    cx.lineWidth = size;
  });
  image.src = url;
}
----

(((resize)))(((context)))(((canvas,context)))Нам надо поменять размер холста, чтобы он соответствовал картинке. Почему-то при смене размера холста его контекст забывает свои настройки (`fillStyle` и `lineWidth`), в связи с чем функция сохраняет их и загружает обратно после обновления размера холста.

(((FileReader type)))(((readAsDataURL method)))Элемент управления для загрузки локального файла использует технику `FileReader` из link:18_forms.html#filereader[главы 18]. Кроме используемого там метода `readAsText` у таких объектов есть метод под названием `readAsDataURL` – а это то, что нам нужно. Мы загружаем ((файл)), который пользователь выбирает, как URL с данными, и передаём его в `loadImageURL` для вывода на холст.

// include_code

[sandbox="paint"]
[source,javascript]
----
controls.openFile = function(cx) {
  var input = elt("input", {type: "file"});
  input.addEventListener("change", function() {
    if (input.files.length == 0) return;
    var reader = new FileReader();
    reader.addEventListener("load", function() {
      loadImageURL(cx, reader.result);
    });
    reader.readAsDataURL(input.files[0]);
  });
  return elt("div", null, "Open file: ", input);
};
----

(((change event)))(((form (HTML tag))))(((submit event)))(((enter key)))Загружать файл с URL ещё проще. Но с ((текстовым полем)) мы не знаем, закончил ли пользователь набирать в нём URL, поэтому мы не можем просто слушать события `"change"`. Вместо этого мы обернём поле в форму и среагируем, когда она будет отправлена – либо по нажатию Enter, либо по нажатию на ((кнопку)) `load`.

// include_code

[sandbox="paint"]
[source,javascript]
----
controls.openURL = function(cx) {
  var input = elt("input", {type: "text"});
  var form = elt("form", null,
                 "Open URL: ", input,
                 elt("button", {type: "submit"}, "load"));
  form.addEventListener("submit", function(event) {
    event.preventDefault();
    loadImageURL(cx, input.value);
  });
  return form;
};
----

Теперь мы определили все элементы управления, требующиеся нашей программе, но нужно добавить ещё несколько инструментов.

== Закругляемся ==

(((prompt function)))Мы легко можем добавить ((текст))овый ((инструмент)), который рисует запрошенную у пользователя с помощью `prompt` строку.

// include_code

[sandbox="paint"]
[source,javascript]
----
tools.Text = function(event, cx) {
  var text = prompt("Text:", "");
  if (text) {
    var pos = relativePos(event, cx.canvas);
    cx.font = Math.max(7, cx.lineWidth) + "px sans-serif";
    cx.fillText(text, pos.x, pos.y);
  }
};
----

Можно было бы добавить дополнительные поля для размера ((шрифт))а и его начертания, но для простоты мы всегда используем шрифт без засечек (sans-serif) с базовым размером, как у текущей кисти. Минимальный размер – 7 пикселей, потому что меньше текст будет нечитаемый.

(((spray paint tool)))(((random number)))Ещё один необходимый инструмент для каляк-маляк – аэрозоль. Она рисует случайные точки под ((кисть))ю, пока нажата кнопка мыши, создавая более или менее густые точки в зависимости от скорости движения курсора.

// include_code

[sandbox="paint"]
[source,javascript]
----
tools.Spray = function(event, cx) {
  var radius = cx.lineWidth / 2;
  var area = radius * radius * Math.PI;
  var dotsPerTick = Math.ceil(area / 30);

  var currentPos = relativePos(event, cx.canvas);
  var spray = setInterval(function() {
    for (var i = 0; i < dotsPerTick; i++) {
      var offset = randomPointInRadius(radius);
      cx.fillRect(currentPos.x + offset.x,
                  currentPos.y + offset.y, 1, 1);
    }
  }, 25);
  trackDrag(function(event) {
    currentPos = relativePos(event, cx.canvas);
  }, function() {
    clearInterval(spray);
  });
};
----

(((setInterval function)))(((trackDrag function)))Аэрозоль использует `setInterval` для выплёвывания цветных точек каждые 25 миллисекунд, пока нажата кнопка мыши. Функция `trackDrag` используется для того, чтобы `currentPos` указывала на текущее положение курсора, и для выключения интервала при отпускании кнопки.

Чтобы посчитать, сколько точек нужно нарисовать каждый раз по окончанию интервала, функция подсчитывает ((размер)) области текущей кисти и делит его на 30. Для поиска случайного положения под кистью используется функция `randomPointInRadius`.

// include_code

[sandbox="paint"]
[source,javascript]
----
function randomPointInRadius(radius) {
  for (;;) {
    var x = Math.random() * 2 - 1;
    var y = Math.random() * 2 - 1;
    if (x * x + y * y <= 1)
      return {x: x * radius, y: y * radius};
  }
}
----

(((Pythagoras)))Эта функция создаёт точки в квадрате между (-1,-1) и (1,1). Используя теорему Пифагора, она проверяет, лежит ли созданная точка внутри ((круг))а с ((радиус))ом 1. Когда такая точка находится, она возвращает её координаты, умноженные на радиус.

(((uniformity)))(((Math.sin function)))(((Math.cos function)))Цикл нужен для равномерного распределения точек. Проще было бы создавать точки в круге, взяв случайный ((угол)) и радиус и вызвав `Math.sin` и `Math.cos` для создания точки. Но тогда точки с большей вероятностью появлялись бы ближе к центру круга. Это ограничение можно обойти, но результат будет сложнее, чем предыдущий цикл.

Теперь наша программа для рисования готова.(!interactive  Запустите код и попробуйте.!)
We now have a functioning paint program.(!interactive  Run the code below to try it.!)

ifdef::interactive_target[]

// start_code

[sandbox="paint"]
[source,text/html]
----
<link rel="stylesheet" href="css/paint.css">

<body>
  <script>createPaint(document.body);</script>
</body>
----

endif::interactive_target[]

== Упражнения ==

В программе ещё очень много чего можно улучшить. Давайте добавим ей возможностей.

=== Прямоугольники ===

(((fillRect method)))(((rectangle tool (exercise))))Определите ((инструмент)) `Rectangle`, заполняющий прямоугольник (см. метод `fillRect` из link:16_canvas.html#fill_stroke[главы 16]) текущим цветом. Прямоугольник должен появляться из той точки, где пользователь нажал кнопку ((мыши)), и до той точки, где он отпустил кнопку. Заметьте, что последнее действие может произойти левее или выше первого.

(((user experience)))Как только это заработает, вы заметите, что некомфортно не видеть прямоугольник, когда вы перетаскиваете мышь, чтобы указать его размер. Можете ли вы придумать способ показать прямоугольник во время перетаскивания без фактического рисования на холсте, пока кнопка мыши не будет отпущена?

(((position (CSS))))(((event object)))(((pageX property)))(((pageY property)))(((left (CSS))))(((height (CSS))))(((top (CSS))))(((width (CSS))))Если не придумаете, вспомните о стиле `position: absolute`, который мы обсуждали в link:13_dom.html#animation[главе 13], который можно использовать, чтобы выводить узел поверх остального документа. Свойства `pageX` и `pageY` событий мыши можно использовать для точного расположения элемента под мышью, записывая нужные значения в пикселях для свойств `left`, `top`, `width` и `height`.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<script>
  tools.Rectangle = function(event, cx) {
    // Ваш код
  };
</script>

<link rel="stylesheet" href="css/paint.css">
<body>
  <script>createPaint(document.body);</script>
</body>
----

endif::interactive_target[]

!!hint!!

(((relativePos function)))(((trackDrag function)))(((rectangle tool
(exercise))))You can use `relativePos` to find the corner
corresponding to the start of the mouse drag. Figuring out where the
drag ends can be done with `trackDrag` or by registering your own
event handler.

(((fillRect method)))(((Math.min function)))(((Math.abs
function)))When you have two corners of the rectangle, you must
somehow translate these into the arguments that `fillRect` expects:
the top-left corner, width, and height of the rectangle. `Math.min`
can be used to find the leftmost x-coordinate and topmost
y-coordinate. To get the width or height, you can call `Math.abs` (the
absolute value) on the difference between two sides.

(((coordinates)))Showing the rectangle during the mouse drag requires
a similar set of numbers but in the context of the whole page rather
than relative to the canvas. Consider writing a function `findRect`,
which converts two points into an object with `top`, `left`, `width`,
and `height` properties so that you don't have to write the same
logic twice.

(((position (CSS))))You can then create a `<div>` node and set its
`style.position` to `absolute`. When setting positioning styles, do
not forget to append `"px"` to the numbers. The node must be added to
the document (you can append it to `document.body`) and also removed
again when the drag ends and the actual rectangle gets drawn onto the
canvas.

!!hint!!

=== Пипетка ===

(((color picker (exercise))))Ещё один часто встречающийся инструмент – ((пипетка)), которая позволяет щелчком мыши на картинке выбрать цвет, который находится под курсором. Сделайте такой инструмент.

(((getImageData method)))(((toDataURL method)))Для его изготовления понадобится доступ к содержимому ((холст))а. Метод `toDataURL` примерно это и делал, но получить информацию о ((пикселе)) из URL с данными сложно. Вместо этого мы возьмём метод контекста `getImageData`, возвращающий прямоугольный кусок картинки в виде объекта со свойствами `width`, `height` и `data`. Свойство `data` содержит массив чисел от 0 до 255, используя четвёрку чисел для представления красного, зелёного, синего и альфа (непрозрачность) компонентов каждого пикселя.

Этот пример получает числа из одного пикселя холста, один раз, когда тот пуст (все пиксели – прозрачные чёрные), и один раз, когда пиксель окрашен в красный цвет.

// test: no

[source,javascript]
----
function pixelAt(cx, x, y) {
  var data = cx.getImageData(x, y, 1, 1);
  console.log(data.data);
}

var canvas = document.createElement("canvas");
var cx = canvas.getContext("2d");
pixelAt(cx, 10, 10);
// → [0, 0, 0, 0]

cx.fillStyle = "red";
cx.fillRect(10, 10, 1, 1);
pixelAt(cx, 10, 10);
// → [255, 0, 0, 255]
----

Аргументы `getImageData` показывают начальные координаты прямоугольника x и y, которые нам надо получить, за которыми идут ширина и высота.

(((transparent)))Игнорируйте прозрачность в этом упражнении, работайте только с первыми тремя компонентами для заданного пикселя. Также не волнуйтесь по поводу обновления поля `color` при выборе цвета. Просто убедитесь, что `fillStyle` и `strokeStyle` контекста установлены в цвет, оказавшийся под курсором.

(((rgb (CSS))))Помните, что эти свойства принимают любой цвет, который понимает CSS, включая запись вида `rgb(R, G, B)`, которую вы видели в link:15_game.html#game_css[главе 15].

(((cross-domain request)))(((sandbox)))(((getImageData method)))Метод `getImageData` имеет те же ограничения, что и `toDataURL` – он выдаст ошибку, когда на холсте содержатся пиксели картинки, скачанной с другого домена. Используйте запись `try/catch` для сообщения об этих ошибках через окно `alert`.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<script>
  tools["Pick color"] = function(event, cx) {
    // Ваш код
  };
</script>

<link rel="stylesheet" href="css/paint.css">
<body>
  <script>createPaint(document.body);</script>
</body>
----

endif::interactive_target[]

!!hint!!

(((color picker (exercise))))(((relativePos function)))(((rgb
(CSS))))You'll again need to use `relativePos` to find out which
pixel was clicked. The `pixelAt` function in the example demonstrates how to get
the values for a given pixel. Putting those into an `rgb` string
merely requires some string ((concatenation)).

(((SecurityError type)))(((exception handling)))Make sure you verify
that the exception you catch is an instance of `SecurityError` so
that you don't accidentally handle the wrong kind of exception.

!!hint!!

=== Заливка ===

(((flood fill (exercise))))Это упражнение более сложное, чем предыдущие, и оно потребует разработки нетривиального решения хитрой задачи. Убедитесь, что у вас есть свободное время и ((терпение)) перед началом работы, и не отчаивайтесь, если сразу у вас что-то не будет получаться.

(((bucket fill)))Инструмент заливки окрашивает пиксель под курсором мыши и окружающие его пиксели того же цвета. Для целей нашего упражнения мы будем считать, что эта группа включает все пиксели, до которых можно добраться от начального, двигаясь по одному пикселю по горизонтали и вертикали (но не по диагонали), не прикасаясь к пикселям, чей цвет отличается от исходного.

Следующая картинка демонстрирует множество пикселей, окрашиваемых, когда инструмент заливки применяется к помеченному пикселю:

image::img/flood-grid.svg[alt="Flood fill example",width="6cm"]

Заливка не протекает через диагональные разрывы и не касается пикселей, которых нельзя достичь, даже если они того же цвета, что и исходный.

(((array,as grid)))(((getImageData method)))Вам вновь понадобится `getImageData` для выяснения цвета ((пикселя)). Скорее всего, удобнее будет получить всю картинку за раз, а потом уже получать данные по пикселям из получившегося массива. Пиксели в массиве организованы схожим образом с ((решёткой)) из link:07_elife.html#grid[главы 7], по рядам, только каждый пиксель описывается четырьмя значениями. Первое значение для пикселя с координатами (_x_, _y_) находится на позиции (_x_ + _y_ × width) × 4.

(((alpha)))(((transparent)))Включайте в рассмотрение четвёртое число (альфа), потому что нам нужно будет различать чёрные и пустые (прозрачные) пиксели.

(((searching)))Поиск соседних пикселей того же цвета требует “пройти” по поверхности пикселей вверх, вниз, влево и вправо, пока там находятся пиксели того же цвета. За первый проход всю группу пикселей найти не получится. Вместо этого нужно будет сделать что-то похожее на отслеживание в регулярных выражениях, описанное в link:09_regexp.html#backtracking[главе 9]. Когда у вас есть больше одного возможного направления, нужно сохранить все те, по которым вы прямо сейчас не идёте, и просмотреть их позже, по окончанию текущего шага.

(((performance)))(((optimization)))У картинки среднего размера _много_ пикселей. Постарайтесь свести работу программы к минимуму, или же она будет работать слишком долго. К примеру, игнорируйте пиксели, которые вы уже обрабатывали.

(((fillRect method)))Рекомендую для окраски отдельных пикселей вызывать `fillRect`, и хранить какую-то структуру данных, где записано, какие пиксели вы уже обошли.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<script>
  tools["Flood fill"] = function(event, cx) {
    // Ваш код
  };
</script>

<link rel="stylesheet" href="css/paint.css">
<body>
  <script>createPaint(document.body);</script>
</body>
----

endif::interactive_target[]

!!hint!!

(((algorithm)))(((bucket fill)))(((flood fill (exercise))))Given a
pair of starting ((coordinates)) and the image data for the whole
canvas, this approach should work:

 1. Create an array to hold information about already colored
    coordinates.

 2. Create a ((work list)) array to hold coordinates that must be looked
    at. Put the start position in it.

 3. When the work list is empty, we are done.

 4. Remove one pair of coordinates from the work list.

 5. If those coordinates are already in our array of colored pixels, go
    back to step 3.

 6. Color the pixel at the current coordinates and add the
    coordinates to the array of colored pixels.

 7. Add the coordinates of each adjacent pixel whose color is the same
    as the starting pixel's original color to the work list.

 8. Return to step 3.

The work list can simply be an array of vector objects. The data
structure that tracks colored pixels will be consulted _very_ often.
Searching through the whole thing every time a new pixel is visited
will take a lot of time. You could instead create an array that has a
value in it for every pixel, using again the x + y × width scheme for
associating positions with pixels. When checking whether a pixel has
been colored already, you could directly access the field corresponding to the
current pixel.

(((comparison,of colors)))You can compare colors by running over
the relevant part of the data array, comparing one field at a time. Or
you can “condense” a color to a single number or string and
compare those. When doing this, ensure that every color produces a
unique value. For example, simply adding the color's components is not
safe since multiple colors will have the same sum.

When enumerating the neighbors of a given point, take care to exclude
neighbors that are not inside of the canvas or your program might run
off into one direction forever.

!!hint!!
