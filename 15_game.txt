:chap_num: 15
:prev_link: 14_event
:next_link: 16_canvas
:load_files: ["code/chapter/15_game.js", "code/game_levels.js"]
:zip: html include=["css/game.css"]

= Проект: Игра-платформер =

[quote,Иэн Бэнкс,Игрок]
____
Вся наша жизнь – игра.
____

(((Banks+++,+++ Ian)))(((project chapter)))(((simulation)))Впервые я увлёкся компьютерами, как и большинство детей, через компьютерные ((игры)). Меня затянуло во вселенную симулированных ((мир))ов, которыми можно было управлять, и в которых рассказывались истории – мне кажется больше потому, что в них был дан простор моему ((воображению)), чем из-за реальных возможностей, которые они предоставляли.

Никому бы не пожелал ((карьеру)) игрового программиста. Как и в ((музыка))льной индустрии, несоответствие между количеством молодых людей, желающих попасть туда и реальным спросом на них, создаёт нездоровую среду. Но написание игр для развлечения – это очень здорово.

(((jump-and-run game)))(((dimensions)))В этой главе мы изучим реализацию простого ((платформер))а. В платформерах (или “прыгай и беги”) от ((игрок))а требуется двигать фигурку по (обычно) двумерному ((мир))у, который мы видим сбоку, и часто перепрыгивать через разные штуки.

== Игра ==

(((minimalism)))(((Palef+++,+++ Thomas)))(((Dark Blue (game))))Наша ((игра)) будет примерно базироваться на игре http://www.lessmilk.com/games/10[Dark Blue](!book  (_www.lessmilk.com/games/10_)!) от Томаса Палефа (Thomas Palef). Я выбрал её, потому что она как развлекательная, так и минималистичная, и её можно сделать минимумом ((код))а. Выглядит она так:

image::img/darkblue.png[alt="The game Dark Blue"]

(((coin)))(((lava)))Чёрный ((прямоугольник)) представляет ((игрок))а, чья задача – собирать жёлтые квадраты (монеты), избегая красных участков (лава?). ((Уровень)) заканчивается, когда игрок собрал все монеты.

(((keyboard)))(((jumping)))Игрок может ходить клавишами влево и вправо, и прыгать клавишей вверх. Прыжки – это специальность нашего персонажа. Он может прыгать в несколько раз выше своего роста и менять направление движения в воздухе. Это не очень-то реалистично, но помогает игроку почувствовать полный контроль над его экранным ((аватар))ом.

(((fractional number)))(((discretization)))(((artificial life)))(((electronic life)))У ((игры)) фиксированный ((фон)) в виде ((решётки)), где движущиеся элементы накладываются на фон. Каждая ячейка решётки либо пустая, либо является стеной, либо ((лавой)). Движущиеся элементы – игрок, монеты, и некоторые кусочки лавы. В отличие от симуляции жизни из link:07_elife.html#elife[главы 7], позиции этих элементов не привязаны к решётке. Их координаты могут быть дробными, обеспечивая плавное ((движение)).

== Технология ==

(((event handling)))(((keyboard)))Мы используем ((DOM)) ((браузер))а для графики, и читаем ввод пользователя, обслуживая события клавиатуры.

(((rectangle)))(((background (CSS))))(((position (CSS))))(((graphics)))Код, относящийся к экрану и клавиатуре – небольшая часть работы, которую нам надо проделать для создания ((игры)). Так как всё состоит из цветных ((квадрат))иков, рисовать это просто: мы создаём элементы DOM и используем стили, чтобы задать им цвет фона, размер и расположение.

(((table (HTML tag))))Мы представляем фон как таблицу, поскольку это – неизменная ((решётка)) из квадратов. Свободно двигающиеся элементы можно накладывать сверху, используя абсолютное позиционирование.

(((performance)))В играх и других интерактивных программах с ((графической)) анимацией, которые должны реагировать на ((действия)) пользователя без задержки, очень важна ((эффективность)). Хотя ((DOM)) не был задуман для вывода высокоскоростной графики, он справляется с этим лучше, чем можно ожидать. В link:13_dom.html#animation[главе 13] вы видели немножко ((анимации)). На современном компьютере такая простая игра идёт неплохо, даже если не сильно мучиться с ((оптимизацией)).

(((canvas)))В link:16_canvas.html#canvas[следующей главе] мы изучим другую технологию ((браузер))а, тег `<canvas>`, который предоставляет более традиционный способ для рисования, и работает с формами и ((пикселями)) вместо элементов ((DOM)).

== Уровни ==

(((dimensions)))В link:07_elife.html#plan[главе 7] мы использовали массивы строк для описания двумерной ((решётки)). Мы можем сделать то же и здесь. Это позволит нам разрабатывать ((уровни)) без того, чтобы сначала писать ((редактор)) уровней.

Простой уровень может выглядеть так:

// include_code

[source,javascript]
----
var simpleLevelPlan = [
  "                      ",
  "                      ",
  "  x              = x  ",
  "  x         o o    x  ",
  "  x @      xxxxx   x  ",
  "  xxxxx            x  ",
  "      x!!!!!!!!!!!!x  ",
  "      xxxxxxxxxxxxxx  ",
  "                      "
];
----

Фиксированная ((решётка)) и движущиеся элементы включены. Символы `x` обозначают ((стены)), пробелы – пустое место, а восклицательные знаки – фиксированная лава.

(((level)))Символ `@` отмечает место, где ((игрок)) начинает. ((Монетки)) - это `o`, знак равенства `=` означает блок движущейся ((лавы)), который двигается по горизонтали туда и сюда. Заметьте, что ((решётка)) на этих позициях будет содержать пустое пространство, и для отслеживания позиции этих подвижных элементов используется ещё одна структура данных.

(((bouncing)))Мы будем поддерживать ещё два вида движущейся ((лавы)): вертикальная черта `|` — для кусочков, двигающихся по вертикали, и `v` для _капающей_ лавы. Она будет двигаться вниз, но не отскакивать обратно, а просто перепрыгивать на начальную позицию по достижению пола.

((Игра)) состоит из нескольких ((уровней)), которые надо закончить. Уровень закончен, когда собраны все ((монетки)). Если игрок касается ((лавы)), текущий уровень возвращается к исходному состоянию, и игрок начинает заново.

[[level]]
== Чтение уровня ==

(((Level type)))Следующий ((конструктор)) создаёт объект ((уровня)). Аргументом должен быть массив строк, задающих уровень.

// include_code

[source,javascript]
----
function Level(plan) {
  this.width = plan[0].length;
  this.height = plan.length;
  this.grid = [];
  this.actors = [];

  for (var y = 0; y < this.height; y++) {
    var line = plan[y], gridLine = [];
    for (var x = 0; x < this.width; x++) {
      var ch = line[x], fieldType = null;
      var Actor = actorChars[ch];
      if (Actor)
        this.actors.push(new Actor(new Vector(x, y), ch));
      else if (ch == "x")
        fieldType = "wall";
      else if (ch == "!")
        fieldType = "lava";
      gridLine.push(fieldType);
    }
    this.grid.push(gridLine);
  }

  this.player = this.actors.filter(function(actor) {
    return actor.type == "player";
  })[0];
  this.status = this.finishDelay = null;
}
----

(((validation)))Для краткости код не проверяет входящие данные. Он предполагает, что план ((уровня)) допустимый, что там есть стартовая позиция игрока и другие необходимые вещи.

(((array)))Уровень сохраняет свои ширину и высоту и ещё два массива – один для ((решётки)), и один для движущихся частей. Решётку представляет массив массивов, где каждый вложенный массив представляет горизонтальную линию, а каждый квадрат содержит либо `null` для пустых квадратов, либо строку, отражающую тип квадрата – `"wall"` или `"lava"`.

Массив `actors` содержит объекты, отслеживающие положения и ((состояния)) динамических ((элемент))ов. У каждого из них должно быть свойство `pos`, содержащее позицию (((координаты)) верхнего левого угла), свойство `size` с размером, и свойство `type` со строчкой, описывающей его тип (`"lava"`, `"coin"`, или `"player"`).

(((filter method)))После построения решётки мы используем метод `filter`, чтобы найти объект ((игрок))а, хранящийся в свойстве уровня. Свойство `status` отслеживает, выиграл игрок или проиграл. Когда это случается, используется `finishDelay`, которое держит уровень активным некоторое время для показа простой ((анимации)) (просто сразу восстанавливать состояние уровня или начинать следующий – это выглядит некрасиво). Этот метод можно использовать, чтобы узнать, закончен ли ((уровень)):

// include_code

[source,javascript]
----
Level.prototype.isFinished = function() {
  return this.status != null && this.finishDelay < 0;
};
----

== Действующие лица ==

[[vector]]
(((Vector type)))(((coordinates)))Для хранения позиции и размера наших актёров мы вернёмся к нашему верному типу `Vector`, который группирует координаты `x` и `y` в объект.

// include_code

[source,javascript]
----
function Vector(x, y) {
  this.x = x; this.y = y;
}
Vector.prototype.plus = function(other) {
  return new Vector(this.x + other.x, this.y + other.y);
};
Vector.prototype.times = function(factor) {
  return new Vector(this.x * factor, this.y * factor);
};
----

(((times method)))(((multiplication)))Метод `times` умножает (масштабирует) вектор на заданную величину. Это будет удобно, когда нам надо будет умножать вектор скорости на временной интервал, чтобы узнать пройденный путь за это время.

(((map)))(((object,as map)))В предыдущей секции конструктором `Level` был использован объект `actorChars`, чтобы связать символы с функциями конструктора. Объект выглядит так:

// include_code

[source,javascript]
----
var actorChars = {
  "@": Player,
  "o": Coin,
  "=": Lava, "|": Lava, "v": Lava
};
----

(((lava)))(((bouncing)))Три символа ссылаются на `Lava`. Конструктор `Level` передаёт исходный символ актёра в качестве второго аргумента конструктора, и конструктор `Lava` использует его для корректировки своего поведения (прыгать по горизонтали, прыгать по вертикали или капать).

(((simulation)))(((Player type)))Тип `Player` построен следующим конструктором. У него есть свойство `speed`, хранящее его текущую скорость, что поможет нам симулировать импульс и гравитацию.

// include_code

[source,javascript]
----
function Player(pos) {
  this.pos = pos.plus(new Vector(0, -0.5));
  this.size = new Vector(0.8, 1.5);
  this.speed = new Vector(0, 0);
}
Player.prototype.type = "player";
----

Поскольку высотой игрок в полтора квадратика, его начальная позиция задаётся на полквадрата выше позиции, где расположен символ `@`. Таким образом его низ совпадает с низом квадрата, в котором он появляется.

(((Lava type)))(((bouncing)))При создании динамического объекта `Lava`, нам надо проинициализировать объект в зависимости от символа. Динамическая лава двигается с заданной скоростью, пока не встретит препятствие. Затем, если у неё есть свойство `repeatPos`, она отпрыгнет назад на стартовую позицию (капающая). Если нет, она инвертирует скорость и продолжает двигаться в обратном направлении (отскакивает). Конструктор задаёт только необходимые свойства. link:15_game.html#actors[Позже] мы напишем метод, который занимается самим движением.

// include_code

[source,javascript]
----
function Lava(pos, ch) {
  this.pos = pos;
  this.size = new Vector(1, 1);
  if (ch == "=") {
    this.speed = new Vector(2, 0);
  } else if (ch == "|") {
    this.speed = new Vector(0, 2);
  } else if (ch == "v") {
    this.speed = new Vector(0, 3);
    this.repeatPos = pos;
  }
}
Lava.prototype.type = "lava";
----

(((Coin type)))(((animation)))Монеты просты в реализации. Они просто сидят на месте. Но для оживления игры они будут “подрагивать”, слегка двигаясь по вертикали туда-сюда. Для отслеживания этого, объект `Coin` хранит основную позицию вместе со свойством `wobble`, которое отслеживает ((фазу)) движения. Вместе они определяют положение монеты (хранящееся в свойстве `pos`).

// include_code

[source,javascript]
----
function Coin(pos) {
  this.basePos = this.pos = pos.plus(new Vector(0.2, 0.1));
  this.size = new Vector(0.6, 0.6);
  this.wobble = Math.random() * Math.PI * 2;
}
Coin.prototype.type = "coin";
----

(((Math.random function)))(((random number)))(((Math.sin function)))(((sine)))(((wave)))В link:13_dom.html#sin_cos[главе 13] мы видели, что `Math.sin` даёт координату `y` точки на круге. Она движется туда и обратно в виде плавной волны, пока мы движемся по кругу, что делает функцию синуса пригодной для моделирования волнового движения.

(((pi)))Чтобы избежать случая, когда все монетки двигаются синхронно, начальная фаза каждой будет случайной. _((Фаза))_ волны `Math.sin` и ширина волны — 2π. Мы умножаем значение, возвращаемое `Math.random`, на это значение, чтобы задать монете случайное начальное положение в волне.

Теперь мы написали всё, что необходимо для представления состояния уровня.

// include_code strip_log

[source,javascript]
----
var simpleLevel = new Level(simpleLevelPlan);
console.log(simpleLevel.width, "by", simpleLevel.height);
// → 22 by 9
----

Нам предстоит выводить эти уровни на экран и моделировать время и движение внутри них.

== Бремя инкапсуляции ==

(((programming style)))(((program size)))(((complexity)))В большинстве случаев код данной главы не заботится об ((инкапсуляции)). Во-первых, инкапсуляция требует дополнительных усилий. Программы становятся больше, требуют больше концепций и интерфейсов. А так как от слишком большого объёма кода глаза читателя стекленеют, я постарался сохранить программу небольшой.

(((interface)))Во-вторых, различные элементы игры так связаны вместе, что если бы менялось поведение одного из них, вряд ли оставшийся код оставался бы неизменным. Создание интерфейсов между элементами привело бы к использованию слишком большого количества предположений по поводу того, как работает игра. И тогда они были бы неэффективными – меняя одну часть системы, вам приходилось бы думать, как это влияет на другие части, потому что их интерфейсы не охватывали бы новую ситуацию.

Некоторые части системы хорошо поддаются разделению на кусочки со строго прописанными интерфейсами, а другие – нет. В попытках инкапсулировать нечто, не имеющее чётких границ, вы гарантированно потратите много сил. Совершив такую ошибку, вы увидите, что интерфейсы становятся чересчур большими и детальными, и что их надо часто менять в процессе эволюции программы.

(((graphics)))(((encapsulation)))(((graphics)))Одну вещь мы _всё-таки_ инкапсулируем – подсистему ((рисования)). Это сделано специально для того, чтобы в link:16_canvas.html#canvasdisplay[следующей главе] мы могли ((выводить)) на экран ту же игру другим способом. Спрятав рисование за интерфейс, мы можем просто загрузить ту же программу и подключить к ней новый ((модуль)) вывода на экран.

[[domdisplay]]
== Рисование ==

(((DOMDisplay type)))Инкапсулировать код для ((рисования)) мы будем, введя объект `display`, который выводит ((уровень)) на экран. Тип экрана, который мы определяем, зовётся `DOMDisplay`, потому что он использует элементы ((DOM)) для показа уровня.

(((style attribute)))Мы используем ((таблицу стилей)) для задания цветов и других фиксированных свойств элементов, составляющих игру. Было бы возможно непосредственно назначать стиль элементу через свойство `style` при его создании, но программа в этом случае стала бы излишне многословной.

(((class attribute)))Следующая вспомогательная функция даёт простой способ создания элемента с назначением класса:

// include_code

[source,javascript]
----
function elt(name, className) {
  var elt = document.createElement(name);
  if (className) elt.className = className;
  return elt;
}
----

Экран создаём, передавая ему родительский элемент, к которому необходимо подсоединиться, и объект ((уровня)).

// include_code

[source,javascript]
----
function DOMDisplay(parent, level) {
  this.wrap = parent.appendChild(elt("div", "game"));
  this.level = level;

  this.wrap.appendChild(this.drawBackground());
  this.actorLayer = null;
  this.drawFrame();
}
----

(((appendChild method)))Используя тот факт, что `appendChild` возвращает добавленный элемент, мы создаём окружающий элемент и сохраняем его в свойстве `wrap` в единственной инструкции.

(((level)))Неизменный ((фон)) уровня рисуется единожды. Актёры перерисовываются каждый раз при обновлении экрана. Свойство `actorLayer` используется в `drawFrame` для отслеживания элемента, содержащего актёра – чтобы их было легко удалять и заменять.

(((scaling)))(((DOMDisplay type)))((Координаты)) и размеры измеряются в единицах, относительных к размеру ((решётки)) так, что дистанция в единицу означает один элемент решётки. Когда мы задаём размеры в ((пикселях)), нам нужно будет масштабировать координаты – игра была бы очень мелкой, если б один квадратик задавался одним пикселем. Переменная `scale` даёт количество пикселей, которое занимает один элемент решётки.

// include_code

[source,javascript]
----
var scale = 20;

DOMDisplay.prototype.drawBackground = function() {
  var table = elt("table", "background");
  table.style.width = this.level.width * scale + "px";
  this.level.grid.forEach(function(row) {
    var rowElt = table.appendChild(elt("tr"));
    rowElt.style.height = scale + "px";
    row.forEach(function(type) {
      rowElt.appendChild(elt("td", type));
    });
  });
  return table;
};
----

[[game_css]]
(((style sheet)))(((CSS)))(((table (HTML tag))))Как мы уже упоминали, фон рисуется через элемент `<table>`. Это удобно соответствует тому факту, что уровень задан в виде решётки – каждый ряд решётки превращается в ряд таблицы (элемент `<tr>`). Строки решётки используются как имена классов ячеек таблицы (`<td>`). Следующий CSS приводит фон к необходимому нам внешнему виду:

[source,text/css]
----
.background    { background: rgb(52, 166, 251);
                 table-layout: fixed;
                 border-spacing: 0;              }
.background td { padding: 0;                     }
.lava          { background: rgb(255, 100, 100); }
.wall          { background: white;              }
----

(((padding (CSS))))Некоторые из настроек (`table-layout`, `border-spacing` и `padding`) используются для подавления нежелательного поведения по умолчанию. Не нужно, чтобы вид ((таблицы)) зависел от содержимого ячеек, и не нужны пробелы между ячейками или отступы внутри них.

(((background (CSS))))(((rgb (CSS))))(((CSS)))Правило `background` задаёт цвет фона. CSS разрешает задавать цвета словами (`white`) и в формате `rgb(R, G, B)`, где красная, зелёная и синяя компоненты разделены на три числа от 0 до 255. То есть, в записи `rgb(52, 166, 251)` красный компонент равен 52, зелёный 166 и синий 251. Поскольку синий компонент самый большой, результирующий цвет будет синеватым. Вы можете видеть, что самый большой компонент в правиле `.lava` – красный.

Каждый ((актёр)) рисуется созданием элемента ((DOM)) и заданием позиции и размера, основываясь на свойства актёра. Значения надо умножать на масштаб `scale`, чтобы переходить от единиц игры к пикселям.

// include_code

[source,javascript]
----
DOMDisplay.prototype.drawActors = function() {
  var wrap = elt("div");
  this.level.actors.forEach(function(actor) {
    var rect = wrap.appendChild(elt("div",
                                    "actor " + actor.type));
    rect.style.width = actor.size.x * scale + "px";
    rect.style.height = actor.size.y * scale + "px";
    rect.style.left = actor.pos.x * scale + "px";
    rect.style.top = actor.pos.y * scale + "px";
  });
  return wrap;
};
----

(((position (CSS))))(((class attribute)))Чтобы задать элементу больше одного класса, мы разделяем их имена пробелами. В коде ((CSS)) класс `actor` задаёт позицию `absolute`. Имя типа используется в дополнительном классе для задания цвета. Нам не надо заново определять класс `lava`, потому что мы повторно используем класс для лавы из решётки, который мы определили ранее.

[source,text/css]
----
.actor  { position: absolute;            }
.coin   { background: rgb(241, 229, 89); }
.player { background: rgb(64, 64, 64);   }
----

(((graphics)))(((optimization)))(((efficiency)))При обновлении экрана метод `drawFrame` удаляет старое изображение актёра, если оно было, и затем перерисовывает его на новой позиции. Напрашивается использование элементов ((DOM)) в качестве актёров, но для этого нам потребовалось бы передавать слишком много дополнительной информации между кодом дисплея и кодом симуляции. Надо было бы связать актёров с элементами DOM, и код ((рисования)) должен был бы удалять элементы при исчезновении актёров. Так как обычно в игре актёров совсем немного, их перерисовка отнимает немного ресурсов.

// include_code

[source,javascript]
----
DOMDisplay.prototype.drawFrame = function() {
  if (this.actorLayer)
    this.wrap.removeChild(this.actorLayer);
  this.actorLayer = this.wrap.appendChild(this.drawActors());
  this.wrap.className = "game " + (this.level.status || "");
  this.scrollPlayerIntoView();
};
----

(((level)))(((class attribute)))(((style sheet)))Добавив в обёртку текущий статус уровня в виде класса, мы можем стилизовать персонажа по-разному в зависимости от того, выиграна игра или проиграна. Мы добавим правило ((CSS)), которое работает, только когда у игрока есть ((предок)) с заданным классом.

[source,text/css]
----
.lost .player {
  background: rgb(160, 64, 64);
}
.won .player {
  box-shadow: -4px -7px 8px white, 4px -7px 8px white;
}
----

(((player)))(((box shadow (CSS))))После прикосновения к ((лаве)) цвета игрока становятся тёмно-красными, будто он сгорел. Когда последняя монетка собрана, мы используем размытые тени для создания эффекта сияния.

[[viewport]]

(((position (CSS))))(((max-width (CSS))))(((overflow (CSS))))(((max-height (CSS))))(((viewport)))Нельзя предполагать, что уровни всегда вмещаются в окно просмотра. Поэтому нам нужен `scrollPlayerIntoView` – он нужен для гарантии того, что если уровень не влезает в окно, он будет прокручен, чтобы игрок всегда был близко к центру. Следующий ((CSS)) задаёт обёртке максимальный размер, и гарантирует, что всё вылезающее за него не видно. Также мы задаём элементу позицию `relative`, чтобы актёры внутри него располагались относительно его левого верхнего угла.

[source,text/css]
----
.game {
  overflow: hidden;
  max-width: 600px;
  max-height: 450px;
  position: relative;
}
----

(((scrolling)))В методе `scrollPlayerIntoView` мы находим положение игрока и обновляем позицию прокрутки обёртывающего элемента. Мы меняем позицию, работая со свойствами `scrollLeft` и `scrollTop`, когда игрок подходит близко к краю.

// include_code

[source,javascript]
----
DOMDisplay.prototype.scrollPlayerIntoView = function() {
  var width = this.wrap.clientWidth;
  var height = this.wrap.clientHeight;
  var margin = width / 3;

  // The viewport
  var left = this.wrap.scrollLeft, right = left + width;
  var top = this.wrap.scrollTop, bottom = top + height;

  var player = this.level.player;
  var center = player.pos.plus(player.size.times(0.5))
                 .times(scale);

  if (center.x < left + margin)
    this.wrap.scrollLeft = center.x - margin;
  else if (center.x > right - margin)
    this.wrap.scrollLeft = center.x + margin - width;
  if (center.y < top + margin)
    this.wrap.scrollTop = center.y - margin;
  else if (center.y > bottom - margin)
    this.wrap.scrollTop = center.y + margin - height;
};
----

(((center)))(((coordinates)))(((readability)))Метод нахождения центра игрока показывает, как методы наших типов `Vector` позволяют записывать расчёты, производимые с объектами, наглядно. Чтобы найти центр актёра, мы добавляем его позицию (его левый верхний угол) и половину высоты. Это центр в координатах уровня, но нам он нужен в координатах пикселей, поэтому мы умножаем результирующий вектор на наш масштаб.

(((validation)))Затем серия проверок подтверждает, что игрок не находится вне доступного пространства. Иногда в результате будут заданы неправильные координаты прокрутки, ниже нуля или больше, чем размер прокручиваемого элемента. Но это не страшно – DOM автоматически ограничит их допустимыми значениями. Если назначить `scrollLeft` значение -10, он будет равен 0.

Было бы немного проще пробовать прокручивать позицию игрока в центр ((окна просмотра)) – но это создаёт неприятный дрожащий эффект. Во время прыжков вид будет постоянно двигаться вверх и вниз. Гораздо приятнее иметь “нейтральную” зону в середине экрана, где можно двигаться, не вызывая прокрутки.

(((cleaning up)))Ещё нам необходимо очищать уровень, когда мы переходим на следующий или начинаем заново.

// include_code

[source,javascript]
----
DOMDisplay.prototype.clear = function() {
  this.wrap.parentNode.removeChild(this.wrap);
};
----

(((game,screenshot)))Теперь мы можем показать наш уровень.

[source,text/html]
----
<link rel="stylesheet" href="css/game.css">

<script>
  var simpleLevel = new Level(simpleLevelPlan);
  var display = new DOMDisplay(document.body, simpleLevel);
</script>
----

ifdef::book_target[]

image::img/game_simpleLevel.png[alt="Our level rendered",width="7cm"]

endif::book_target[]

(((link (HTML tag))))(((style sheet)))(((CSS)))Тэг `<link>` при использовании с `rel="stylesheet"` позволяет загружать файл с CSS. Файл `game.css` содержит необходимые для игры стили.

== Движение и столкновение ==

(((physics)))(((animation)))Теперь нам надо добавить обработку движений – самое интересное в игре. Простой подход, который используют большинство игр – разделить ((время)) на небольшие отрезки, и на каждом шаге сдвигать актёров на дистанцию, соответствующую их скорости (расстояние в секунду), умноженное на длительность временного отрезка (в секундах).

(((obstacle)))(((collision detection)))Это просто. Сложность в том, что надо обрабатывать взаимодействие предметов. Когда игрок касается пола или стены, он не должен проходить насквозь. Игра должна замечать, когда движение одного объекта приводит к столкновению с другим и реагировать соответственно. Стены останавливают движение, монеты собираются, и так далее.

В общем случае эта задача не такая простая. Можно найти библиотеки, обычно называющиеся _((физическими движками))_, симулирующие взаимодействия между физическими объектами в двух или трёх ((измерениях)). В этой главе мы поступим проще, так как нам нужно обрабатывать столкновения только прямоугольных объектов.

(((bouncing)))(((collision detection)))(((animation)))Перед тем, как сдвинуть ((игрок))а или блок ((лавы)), мы проверяем, не приведёт ли нас движение внутрь непустой части ((фон))а. Если да – мы отменяем движение. Реакция на это будет зависеть от типа актёра – игрок останавливается, лава отскакивает.

(((discretization)))Подход требует использования небольших отрезков ((времени)), чтобы объекты останавливались до соприкосновения. Если взять слишком большие отрезки, игрок будет зависать над землёй. Можно было бы использовать более сложный вариант – вычислить место непосредственного соприкосновения и подвинуть актёра туда. Мы поступим проще, и скроем его проблемы, выбрав небольшие временные отрезки.

(((obstacle)))(((obstacleAt method)))(((collision detection)))Метод сообщает, не пересекается ли ((прямоугольник)) (заданный позицией и размером) с каким-либо непустым пространством фоновой решётки:

// include_code

[source,javascript]
----
Level.prototype.obstacleAt = function(pos, size) {
  var xStart = Math.floor(pos.x);
  var xEnd = Math.ceil(pos.x + size.x);
  var yStart = Math.floor(pos.y);
  var yEnd = Math.ceil(pos.y + size.y);

  if (xStart < 0 || xEnd > this.width || yStart < 0)
    return "wall";
  if (yEnd > this.height)
    return "lava";
  for (var y = yStart; y < yEnd; y++) {
    for (var x = xStart; x < xEnd; x++) {
      var fieldType = this.grid[y][x];
      if (fieldType) return fieldType;
    }
  }
};
----

(((Math.floor function)))(((Math.ceil function)))Метод вычисляет занимаемые телом ячейки решётки, применяя `Math.floor` и `Math.ceil` на ((координатах)) тела. Помните, что размеры ячеек – 1х1 единиц. ((Округляя)) границы тела вверх и вниз, мы получаем промежуток из ячеек ((фон))а, которых касается тело.

image::img/game-grid.svg[alt="Finding collisions on a grid",width="3cm"]

Если тело высовывается из уровня, мы всегда возвращаем `"wall"` для двух сторон и верха и `"lava"` для низа. Это обеспечит гибель игрока при выходе за пределы уровня. Когда тело внутри решётки, мы в цикле проходим блок квадратов ((решётки)), найденный ((округление))м ((координат)), и возвращаем содержимое первого непустого квадратика.

(((coin)))(((lava)))(((collision detection)))Столкновения ((игрок))а с другими ((актёр))ами (монеты, движущаяся лава) обрабатываются _после_ сдвига игрока. Когда движение приводит его к другому актёру, срабатывает соответствующий эффект (сбор монет или гибель).

(((actorAt method)))Этот метод сканирует массив актёров, в поисках того, который накладывается на заданный аргумент:

// include_code

[source,javascript]
----
Level.prototype.actorAt = function(actor) {
  for (var i = 0; i < this.actors.length; i++) {
    var other = this.actors[i];
    if (other != actor &&
        actor.pos.x + actor.size.x > other.pos.x &&
        actor.pos.x < other.pos.x + other.size.x &&
        actor.pos.y + actor.size.y > other.pos.y &&
        actor.pos.y < other.pos.y + other.size.y)
      return other;
  }
};
----

[[actors]]
== Актёры и действия ==

(((animate method)))(((animation)))(((keyboard)))Метод `animate` типа `Level` даёт возможность всем актёрам уровня сдвинуться. Аргумент `step` задаёт ((временной)) промежуток в секундах. Объект `keys` содержит информацию про стрелки клавиатуры, нажатые игроком.

// include_code

[source,javascript]
----
var maxStep = 0.05;

Level.prototype.animate = function(step, keys) {
  if (this.status != null)
    this.finishDelay -= step;

  while (step > 0) {
    var thisStep = Math.min(step, maxStep);
    this.actors.forEach(function(actor) {
      actor.act(thisStep, this, keys);
    }, this);
    step -= thisStep;
  }
};
----

(((level)))(((animation)))Когда у свойства уровня `status` есть значение, отличное от `null` (а это бывает, когда игрок выиграл или проиграл), мы уменьшить до нуля счётчик `finishDelay`, считающий время между моментом, когда произошёл выигрыш или проигрыш и моментом, когда надо заканчивать показ уровня.

(((while loop)))(((discretization)))Цикл `while` делит временной интервал на удобные мелкие куски. Он следит, чтобы промежутки были не больше `maxStep`. К примеру, шаг в 0.12 секунды будет нарезан на два шага по 0.05 секунды и остаток в 0.02.

(((actor)))(((Lava type)))(((lava)))У объектов актёров есть метод `act`, который принимает временной шаг, объект `level` и объект `keys`. Вот он для типа `Lava`, который игнорирует объект `keys`:

// include_code

[source,javascript]
----
Lava.prototype.act = function(step, level) {
  var newPos = this.pos.plus(this.speed.times(step));
  if (!level.obstacleAt(newPos, this.size))
    this.pos = newPos;
  else if (this.repeatPos)
    this.pos = this.repeatPos;
  else
    this.speed = this.speed.times(-1);
};
----

(((bouncing)))(((multiplication)))(((Vector type)))(((collision detection)))Он считает новую позицию, добавляя результат умножения временного промежутка и текущей скорости к старой позиции. Если новую позицию не занимает препятствие, происходит перемещение. Если препятствие существует, поведение зависит от типа блока ((лавы)). У капающей лавы есть свойство `repeatPos`, куда она прыгает назад при встрече с препятствием. Прыгающая лава просто инвертирует скорость (умножает на -1), чтобы продолжить движение в обратном направлении.

(((Coin type)))(((coin)))(((wave)))Монеты используют метод `act`, чтобы дрожать. Столкновения они игнорируют, поскольку они просто подрагивают внутри своего квадрата, а столкновения с ((игрок))ом будут обрабатываться методом `act` _игрока_.

// include_code

[source,javascript]
----
var wobbleSpeed = 8, wobbleDist = 0.07;

Coin.prototype.act = function(step) {
  this.wobble += step * wobbleSpeed;
  var wobblePos = Math.sin(this.wobble) * wobbleDist;
  this.pos = this.basePos.plus(new Vector(0, wobblePos));
};
----

(((Math.sin function)))(((sine)))(((phase)))Свойство `wobble` обновляется, чтобы следить за временем, и потом используется как аргумент `Math.sin` для создания ((волны)), которая используется для подсчёта новой позиции.

(((collision detection)))(((Player type)))Остаётся ((игрок)). Движение игрока обрабатывается по разным ((осям)) отдельно, потому что встреча с полом не должна мешать горизонтальному перемещению, а встреча со стеной – падению или прыжку. Этот метод работает с горизонтальным перемещением:

// include_code

[source,javascript]
----
var playerXSpeed = 7;

Player.prototype.moveX = function(step, level, keys) {
  this.speed.x = 0;
  if (keys.left) this.speed.x -= playerXSpeed;
  if (keys.right) this.speed.x += playerXSpeed;

  var motion = new Vector(this.speed.x * step, 0);
  var newPos = this.pos.plus(motion);
  var obstacle = level.obstacleAt(newPos, this.size);
  if (obstacle)
    level.playerTouched(obstacle);
  else
    this.pos = newPos;
};
----

(((animation)))(((keyboard)))Горизонтальное перемещение подсчитывается на основе состояния клавиш “направо” и “налево”. Когда перемещение приводит к встрече с препятствием, вызывается метод уровня `playerTouched`, который обрабатывает гибель в ((лаве)) и сбор ((монеток)). В ином случае объект обновляет свою позицию.

Движение по вертикали работает сходным образом, но симулирует ((прыжки)) и ((гравитацию)).

// include_code

[source,javascript]
----
var gravity = 30;
var jumpSpeed = 17;

Player.prototype.moveY = function(step, level, keys) {
  this.speed.y += step * gravity;
  var motion = new Vector(0, this.speed.y * step);
  var newPos = this.pos.plus(motion);
  var obstacle = level.obstacleAt(newPos, this.size);
  if (obstacle) {
    level.playerTouched(obstacle);
    if (keys.up && this.speed.y > 0)
      this.speed.y = -jumpSpeed;
    else
      this.speed.y = 0;
  } else {
    this.pos = newPos;
  }
};
----

(((acceleration)))(((physics)))В начале метода игрок ускоряется по вертикали, чтобы обеспечить ((гравитацию)). Гравитация, скорость ((прыжка)) и все остальные ((константы)) в игре были подобраны методом ((проб и ошибок)). Я проверял разные значения, пока меня не удовлетворил результат.

(((collision detection)))(((keyboard)))(((jumping)))Затем мы снова проверяем препятствия. Если мы его встретили, возможны два варианта. Когда нажата клавиша “вверх”, _и_ мы двигаемся вниз (то есть, мы встретились с чем-то, что находится под нами), скорости присваивается довольно большое отрицательное значение. В результате игрок прыгает. В ином случае, мы просто во что-то врезались и скорость обнуляется.

Сам метод `act` следующий:

// include_code

[source,javascript]
----
Player.prototype.act = function(step, level, keys) {
  this.moveX(step, level, keys);
  this.moveY(step, level, keys);

  var otherActor = level.actorAt(this);
  if (otherActor)
    level.playerTouched(otherActor.type, otherActor);

  // Losing animation
  if (level.status == "lost") {
    this.pos.y += step;
    this.size.y -= step;
  }
};
----

(((player)))После движения метод проверяет других актёров, с которыми игрок сталкивается, и опять вызывает `playerTouched`, если таковой нашёлся. В этот раз он передаёт вторым аргументом объект `actor`, так как если другим актёром была ((монетка)), метод `playerTouched` должен знать, _какую_ именно монетку мы собрали.

(((animation)))В финале, когда игрок погибает (дотронувшись до лавы), мы делаем небольшую анимацию, из-за которой персонаж “сжимается” (или “тонет”), уменьшая высоту объекта `player`.

(((collision detection)))Вот метод, обрабатывающий столкновения между игроком и другими объектами:

// include_code

[source,javascript]
----
Level.prototype.playerTouched = function(type, actor) {
  if (type == "lava" && this.status == null) {
    this.status = "lost";
    this.finishDelay = 1;
  } else if (type == "coin") {
    this.actors = this.actors.filter(function(other) {
      return other != actor;
    });
    if (!this.actors.some(function(actor) {
      return actor.type == "coin";
    })) {
      this.status = "won";
      this.finishDelay = 1;
    }
  }
};
----

Когда мы тронули ((лаву)), статус игры устанавливается в `"lost"`. Когда собрана ((монетка)), она удаляется из массива актёров, а если это была последняя – статус игры меняется на `"won"`.

Всё это даёт нам уровень, пригодный для анимации. Не хватает только кода, её _обрабатывающего_.

== Отслеживание клавиш ==

(((keyboard)))Для такой ((игры)) нам не нужны клавиши, эффект которых работает однократно после `keypress`. Нам нужен эффект, продолжающийся всё время, пока клавиша нажата (движущаяся фигурка).

(((preventDefault method)))Нам надо сделать обработчик клавиш, хранящий текущее состояние кнопок влево, вправо и вверх. Также нам надо вызывать для них `preventDefault`, чтобы они не ((прокручивали)) страницу.

(((trackKeys function)))(((key code)))(((event handling)))(((addEventListener method)))Следующая функция, когда ей дают объект с кодами клавиш в виде имён свойств и названиями клавиш в виде значений, возвращает другой объект, который отслеживает текущее состояние кнопок. Он регистрирует обработчики событий для событий `"keydown"` и `"keyup"`, и когда код клавиши события совпадает с отслеживаемым кодом, обновляет объект.

// include_code

[source,javascript]
----
var arrowCodes = {37: "left", 38: "up", 39: "right"};

function trackKeys(codes) {
  var pressed = Object.create(null);
  function handler(event) {
    if (codes.hasOwnProperty(event.keyCode)) {
      var down = event.type == "keydown";
      pressed[codes[event.keyCode]] = down;
      event.preventDefault();
    }
  }
  addEventListener("keydown", handler);
  addEventListener("keyup", handler);
  return pressed;
}
----

(((keydown event)))(((keyup event)))Обратите внимание, как одна функция обработчика используется для событий обоих типов. Она проверяет свойство `type` объекта события, определяя, надо ли обновлять состояние кнопки на `true` (`"keydown"`) или `false` (`"keyup"`).

[[runAnimation]]
== Запуск игры ==

(((requestAnimationFrame function)))(((animation)))Функция `requestAnimationFrame`, которую мы видели в link:13_dom.html#animationFrame[главе 13], предоставляет хороший способ анимировать игру. Но интерфейс её примитивен – его использование заставляет нас отслеживать момент времени, в который она была вызвана в прошлый раз, и вызывать `requestAnimationFrame` каждый раз после каждого кадра.

(((runAnimation function)))(((callback function)))(((function,as value)))(((function,higher-order)))Давайте определим вспомогательную функцию, оборачивающую эти скучные операции в удобный интерфейс, и позволяющую нам просто вызвать `runAnimation`, задавая ей функцию, которая принимает разницу во времени и рисует один кадр. Когда функция `frame` возвращает `false`, анимация останавливается.

// include_code

[source,javascript]
----
function runAnimation(frameFunc) {
  var lastTime = null;
  function frame(time) {
    var stop = false;
    if (lastTime != null) {
      var timeStep = Math.min(time - lastTime, 100) / 1000;
      stop = frameFunc(timeStep) === false;
    }
    lastTime = time;
    if (!stop)
      requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}
----

(((time)))(((discretization)))Я назначил максимальное время для кадра в 100 миллисекунд (1/10 секунды). Когда закладка или окно браузера спрятано, вызовы `requestAnimationFrame` прекратятся, пока закладка или окно не станут снова активны. В этом случае, разница между `lastTime` и текущим временем будет равна тому времени, в течение которого страница была спрятана. Продвигать игру на всё это время было бы глупо и затратно (вспомните разделение времени в link:15_game.html#actors[методе `animate`]).

Эта функция также преобразовывает временные отрезки в секунды, которыми проще оперировать, чем миллисекундами.

(((callback function)))(((runLevel function)))Функция `runLevel` принимает объект `Level`, конструктор для `display`, и, необязательным параметром – функцию. Она выводит уровень в `document.body` и позволяет пользователю играть на нём. Когда уровень закончен (победа или поражение), `runLevel` очищает экран, останавливает ((анимацию)), а если задана функция `andThen`, вызывает её со статусом уровня.

// include_code

[source,javascript]
----
var arrows = trackKeys(arrowCodes);

function runLevel(level, Display, andThen) {
  var display = new Display(document.body, level);
  runAnimation(function(step) {
    level.animate(step, arrows);
    display.drawFrame(step);
    if (level.isFinished()) {
      display.clear();
      if (andThen)
        andThen(level.status);
      return false;
    }
  });
}
----

(((runGame function)))Игра – это последовательность ((уровней)). Когда ((игрок)) погибает, уровень начинается заново. Когда уровень закончен, мы переходим на следующий. Это можно выразить следующей функцией, принимающей массив планов уровней (массив строк) и конструктор `display`:

// include_code

[source,javascript]
----
function runGame(plans, Display) {
  function startLevel(n) {
    runLevel(new Level(plans[n]), Display, function(status) {
      if (status == "lost")
        startLevel(n);
      else if (n < plans.length - 1)
        startLevel(n + 1);
      else
        console.log("You win!");
    });
  }
  startLevel(0);
}
----

(((function,higher-order)))(((function,as value)))Эти функции демонстрируют необычный стиль программирования. Обе функции `runAnimation` и `runLevel` – функции высшего порядка, но не в том стиле, что мы видели в link:05_higher_order.html#higher_order[главе 5]. Аргумент функций используется, чтобы подготовить вещи, которые произойдут когда-либо в будущем, и функции не возвращают ничего полезного. Их задача – запланировать действия. Оборачивая эти действия в функции, мы сохраняем их как значения, чтобы их можно было вызвать в нужный момент.

(((asynchronous programming)))(((event handling)))Такой стиль программирования обычно называют _асинхронным_. Обработка событий – тоже пример такого стиля, и мы с ним встретимся ещё не раз, когда будем работать с задачами, которые могут занять произвольные промежутки ((времени)) – например, ((сетевые)) запросы в link:17_http.html#http[главе 17], или ввод и вывод общего назначения в link:20_node.html#node[главе 20].

(((game)))(((GAME_LEVELS data set)))В переменной `GAME_LEVELS` хранится набор планов ((уровней)) (!book (доступно для загрузки с http://eloquentjavascript.net/2nd_edition/code#15[_eloquentjavascript.net/2nd_edition/code#15_])!). Такая страница скармливает их в `runGame`, которая запускает саму игру:

// start_code

[sandbox="null"]
[focus="yes"]
[source,text/html]
----
<link rel="stylesheet" href="css/game.css">

<body>
  <script>
    runGame(GAME_LEVELS, DOMDisplay);
  </script>
</body>
----

ifdef::interactive_target[]

Попробуйте выиграть. Я здорово повеселился, сочиняя их.

endif::interactive_target[]

== Упражнения ==

=== Конец игры ===

(((lives (exercise))))(((game)))По традиции, ((платформер))ы дают игроку ограниченное количество _жизней_, и вычитают по одной каждый раз при гибели игрока. Когда жизни кончаются, игра начинается заново.

(((runGame function)))Подредактируйте `runGame`, чтобы она поддерживала жизни. Пусть игрок начинает с трёх.

ifdef::interactive_target[]

// test: no

[focus="yes"]
[source,text/html]
----
<link rel="stylesheet" href="css/game.css">

<body>
<script>
  // Старая функция runGame – поменяйте её...
  function runGame(plans, Display) {
    function startLevel(n) {
      runLevel(new Level(plans[n]), Display, function(status) {
        if (status == "lost")
          startLevel(n);
        else if (n < plans.length - 1)
          startLevel(n + 1);
        else
          console.log("You win!");
      });
    }
    startLevel(0);
  }
  runGame(GAME_LEVELS, DOMDisplay);
</script>
</body>
----

endif::interactive_target[]

!!hint!!

(((lives (exercise))))(((runGame function)))The most obvious solution
would be to make `lives` a variable that lives in `runGame` and is
thus visible to the `startLevel` ((closure)).

Another approach, which fits nicely with the spirit of the rest of the
function, would be to add a second ((parameter)) to `startLevel` that
gives the number of lives. When the whole ((state)) of a system is stored
in the arguments to a ((function)), calling that function provides an
elegant way to transition to a new state.

In any case, when a ((level)) is lost, there should now be two
possible state transitions. If that was the last life, we go back to
level zero with the starting amount of lives. If not, we repeat the
current level with one less life remaining.

!!hint!!

=== Пауза ===

(((pausing (exercise))))(((escape key)))(((keyboard)))Сделайте возможным ставить и снимать игру с паузы по нажатию клавиши Esc.

(((runLevel function)))(((event handling)))Этого можно достичь, поменяв функцию `runLevel`, чтобы она использовала другой обработчик событий клавиатуры, и прерывала и возобновляла анимацию по нажатию Esc.

(((runAnimation function)))На первый взгляд может показаться, что интерфейс `runAnimation` не предназначен для этого – но если вы поменяете его вызов из `runLevel`, всё получится.

(((variable,global)))(((trackKeys function)))Когда получится, можете попробовать ещё кое-что. Мы регистрируем события с клавиатуры не самым лучшим способом. Объект `arrows` – глобальная переменная, и его обработчики событий находятся в памяти, даже если игра не запущена. Можно сказать, они _((утекают))_ из системы. Расширьте `trackKeys`, чтоб можно было разрегистрировать обработчики и затем поменяйте `runLevel`, чтоб она регистрировала их на старте, и разрегистрировала на финише.

ifdef::interactive_target[]

// test: no

[focus="yes"]
[source,text/html]
----
<link rel="stylesheet" href="css/game.css">

<body>
<script>
  // Старая функция runLevel – поменяйте её...
  function runLevel(level, Display, andThen) {
    var display = new Display(document.body, level);
    runAnimation(function(step) {
      level.animate(step, arrows);
      display.drawFrame(step);
      if (level.isFinished()) {
        display.clear();
        if (andThen)
          andThen(level.status);
        return false;
      }
    });
  }
  runGame(GAME_LEVELS, DOMDisplay);
</script>
</body>
----

endif::interactive_target[]

!!hint!!

(((pausing (exercise))))An ((animation)) can be interrupted by
returning `false` from the function given to `runAnimation`. It can be
continued by calling `runAnimation` again.

(((closure)))To communicate that the animation should be
interrupted to the function passed to `runAnimation` so that it can
return `false`, you can use a variable that both the event handler and
that function have access to.

(((event handling)))(((removeEventListener method)))(((function,as
value)))When finding a way to unregister the handlers registered by
`trackKeys`, remember that the _exact_ same function value that was
passed to `addEventListener` must be passed to `removeEventListener`
to successfully remove a handler. Thus, the `handler` function value
created in `trackKeys` must be available to the code that unregisters
the handlers.

You can add a property to the object returned by `trackKeys`,
containing either that function value or a method that handles the
unregistering directly.

!!hint!!
