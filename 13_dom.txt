:chap_num: 13
:prev_link: 12_browser
:next_link: 14_event
:load_files: ["code/mountains.js", "code/chapter/13_dom.js"]

= Объектная модель документа =

(((drawing)))(((parsing)))Когда вы открываете веб-страницу в браузере, он получает исходный текст ((HTML)) и разбирает (парсит) его примерно так, как наш парсер из link:11_language.html#parsing[главы 11] разбирал программу. Браузер строит модель ((структуры)) документа и использует её, чтобы нарисовать страницу на экране.

(((live data structure)))Это представление ((документ))а и есть одна из игрушек, доступных в ((песочнице)) JavaScript. Вы можете читать её и изменять. Она изменяется в _реальном времени_ – как только вы её подправляете, страница на экране обновляется, отражая изменения.

== Структура документа ==

Можно представить ((HTML)) как набор вложенных ((коробок)). Теги вроде `<body>` и `</body>` включают в себя другие ((тег))и, которые в свою очередь включают теги, или ((текст)). Вот вам пример документа из link:12_browser.html#browser[предыдущей главы]:

[sandbox="homepage"]
[source,text/html]
----
<!doctype html>
<html>
  <head>
    <title>Моя домашняя страничка</title>
  </head>
  <body>
    <h1>Моя домашняя страничка</h1>
    <p>Привет, я Марийн и это моя домашняя страничка.</p>
    <p>А ещё я книжку написал! Читайте её
      <a href="http://eloquentjavascript.net">здесь</a>.</p>
  </body>
</html>
----

У этой страницы следующая структура:

image::img/html-boxes.svg[alt="HTML document as nested boxes",width="7cm"]

indexsee:[Document Object Model,DOM]
Структура данных, использующаяся браузером для представления документа, отражает его форму. Для каждой коробки есть ((объект)), с которым мы можем взаимодействовать и узнавать про него разные данные – какой тег он представляет, какие коробки и текст содержит. Это представление называется _Document Object Model_ (объектная модель документа), или сокращённо ((DOM)).

(((documentElement property)))(((head property)))(((body property)))(((html (HTML tag))))(((body (HTML tag))))(((head (HTML tag))))Мы можем получить доступ к этим объектам через глобальную переменную ((document)). Её свойство `documentElement` ссылается на объект, представляющий тег `<html>`. Он также предоставляет свойства `head` и `body`, в которых содержатся объекты для соответствующих элементов.

== Деревья ==

(((nesting,of objects)))Вспомните ((синтаксические деревья)) из link:11_language.html#parsing[главы 11]. Их структура удивительно похожа на структуру документа браузера. Каждый _((узел))_ может ссылаться на другие узлы, _потомки_, которые, в свою очередь, могут иметь своих собственных потомков. Эта структура – типичный пример вложенных структур, где элементы содержат подэлементы, похожие на них самих.

(((documentElement property)))Мы зовём структуру данных _((дерево))м_, когда она разветвляется, не имеет ((цикл))ов (узел не может содержать сам себя явно или неявно), и имеет единственный ярко выраженный “((корень))”. В случае ((DOM)) в качестве корня выступает `document.documentElement`.

(((sorting)))(((data structure)))(((syntax tree)))Деревья часто встречаются в вычислительной науке. В дополнение к представлению рекурсивных структур вроде документа HTML или программ, они часто используются для работы с сортированными ((набор))ами данных, потому что элементы обычно проще найти или вставлять в отсортированное дерево, чем в отсортированный одномерный массив.

(((leaf node)))(((Egg language)))У типичного дерева есть разные ((узлы)). У синтаксического дерева link:11_language.html#language[языка Egg] были переменные, значения и приложения. У приложений всегда были дочерние ветви, а переменные и значения были _листьями_, то есть узлами без дочерних ответвлений.

(((body property)))То же и у DOM. Узлы для обычных _((элемент))ов_, представляющих теги ((HTML)), определяют структуру документа. У них могут быть ((дочерние узлы)). Пример такого узла — `document.body`. Некоторые из этих дочерних узлов могут оказаться ((лист))ьями – например, ((текст)) или ((комментарии)) (в HTML комментарии записываются между символами `<!--` и `-->`).

(((text node)))(((ELEMENT_NODE code)))(((COMMENT_NODE code)))(((TEXT_NODE code)))(((nodeType property)))У каждого узлового объекта DOM есть свойство `nodeType`, содержащее цифровой код, определяющий тип узла. У обычных элементов он равен 1, что также определено в виде свойства-константы `document.ELEMENT_NODE`. У текстовых узлов, представляющих отрывки текста, он равен 3 (`document.TEXT_NODE`). У комментариев — 8 (`document.COMMENT_NODE`).

То есть, вот ещё один способ графически представить ((дерево)) документа:

image::img/html-tree.svg[alt="HTML document as a tree",width="8cm"]

Листья – текстовые узлы, а стрелки показывают взаимоотношения отец-ребёнок между узлами.

[[standard]]
== Стандарт ==

(((programming language)))(((interface,design)))Использовать загадочные цифры для представления типа узла – это подход не в стиле JavaScript. Позже мы встретимся с другими частями интерфейса ((DOM)), которые тоже кажутся чуждыми и нескладными. Причина в том, что DOM разрабатывался не только для JavaScript. Он пытается определить ((интерфейс)), не зависящий от языка, который можно использовать и в других системах – не только в HTML, но и в ((XML)), который представляет из себя ((формат данных)) общего назначения с синтаксисом, напоминающим HTML.

(((consistency)))(((integration)))Получается неудобно. Хотя стандарты – и весьма полезная штука, в нашем случае преимущество независимости от языка не такое уж и полезное. Лучше иметь интерфейс, хорошо приспособленный к языку, который вы используете, чем интерфейс, который будет знаком при использовании разных языков.

(((array-like object)))(((NodeList type)))Чтобы показать неудобную интеграцию с языком, рассмотрим свойство `childNodes`, которое есть у узлов DOM. В нём содержится объект, похожий на массив, со свойством `length`, и пронумерованные свойства для доступа к дочерним узлам. Но это – экземпляр типа `NodeList`, не настоящий массив, поэтому у него нет методов вроде `slice` или `forEach`.

(((interface,design)))(((DOM,construction)))(((side effect)))Есть также проблемы, связанные с плохой продуманностью системы. К примеру, нельзя создать новый узел и сразу добавить к нему свойства или дочерние узлы. Сначала нужно его создать, затем добавить дочерние по одному, и в конце назначить свойства по одному, с использованием побочных эффектов. Код, плотно работающий с DOM, получается длинным, некрасивым и со множеством повторов.

(((library)))Но эти проблемы не фатальные. JavaScript позволяет создавать ((абстракции)). Легко написать ((вспомогательные функции)), позволяющие выражать операции более понятно и коротко. Вообще, такого рода инструменты предоставляют много библиотек, направленных на программирование для браузера.

== Обход дерева ==

(((pointer)))Узлы DOM содержат много ((ссылок)) на соседние. Это показано на диаграмме:

image::img/html-links.svg[alt="Links between DOM nodes",width="6cm"]

(((child node)))(((parentNode property)))(((childNodes property)))Хотя тут показано только по одной ссылке каждого типа, у каждого узла есть свойство `parentNode`, указывающего на его родительский узел. Также у каждого узла-элемента (тип 1) есть свойство `childNodes`, указывающее на ((массивоподобный объект)), содержащий его дочерние узлы.

(((firstChild property)))(((lastChild property)))(((previousSibling property)))(((nextSibling property)))В теории можно пройти в любую часть дерева, используя только эти ссылки. Но JavaScript предоставляет нам много дополнительных вспомогательных ссылок. Свойства `firstChild` и `lastChild` показывают на первый и последний дочерний элементы, или содержат `null` у тех узлов, у которых нет дочерних. `previousSibling` и `nextSibling` указывают на соседние узлы – узлы того же родителя, что и текущего узла, но находящиеся в списке сразу до или после текущей. У первого узла свойство `previousSibling` будет `null`, а у последнего `nextSibling` будет `null`.

(((talksAbout function)))(((recursion)))(((nesting,of objects)))При работе с такими вложенными структурами пригождаются рекурсивные функции. Следующая ищет в документе ((текстовые узлы)), содержащие заданную строку, и возвращает `true`, когда находит:

[[talksAbout]]
[sandbox="homepage"]
[source,javascript]
----
function talksAbout(node, string) {
  if (node.nodeType == document.ELEMENT_NODE) {
    for (var i = 0; i < node.childNodes.length; i++) {
      if (talksAbout(node.childNodes[i], string))
        return true;
    }
    return false;
  } else if (node.nodeType == document.TEXT_NODE) {
    return node.nodeValue.indexOf(string) > -1;
  }
}

console.log(talksAbout(document.body, "книг"));
// → true
----

(((nodeValue property)))Свойства текстового узла `nodeValue` содержит строчку текста.

== Поиск элементов ==

(((DOM)))(((body property)))(((hard-coding)))Часто бывает полезным ориентироваться по этим ((ссылка))м между родителями, детьми и родственными узлами и проходить по всему документу. Однако если нам нужен конкретный узел в документе, очень неудобно идти по нему, начиная с `document.body` и тупо перебирая жёстко заданный в коде путь. Поступая так, мы вносим в программу допущения о точной структуре документа – а её мы позже можем захотеть поменять. Другой усложняющий фактор – текстовые узлы создаются даже для ((пробел))ов между узлами. В документе из примера у тега `<body>` не три дочерних (`<h1>` и два `<p>`), а целых семь: эти три плюс пробелы до, после и между ними.

(((searching)))(((href attribute)))(((getElementsByTagName method)))Так что если нам нужен атрибут `href` из ссылки, мы не должны писать в программе что-то вроде: “второй ребёнок шестого ребёнка тела документа”. Лучше бы, если б мы могли сказать: “первая ссылка в документе”. И так можно сделать.

[sandbox="homepage"]
[source,javascript]
----
var link = document.body.getElementsByTagName("a")[0];
console.log(link.href);
----

(((child node)))У всех узлов-элементов есть метод `getElementsByTagName`, собирающий все элементы с данным тэгом, которые происходят (прямые или не прямые потомки) от этого узла, и возвращает его в виде массивоподобного объекта.

(((id attribute)))(((getElementById method)))Чтобы найти _конкретный_ узел, можно задать ему атрибут `id` и использовать метод `document.getElementById`.

[source,text/html]
----
<p>Мой страус Гертруда:</p>
<p><img id="gertrude" src="img/ostrich.png"></p>

<script>
  var ostrich = document.getElementById("gertrude");
  console.log(ostrich.src);
</script>
----

(((getElementsByClassName method)))(((class attribute)))Третий метод – `getElementsByClassName`, который, как и `getElementsByTagName`, ищет в содержимом узла-элемента и возвращает все элементы, содержащие в своём классе заданную строчку.

== Меняем документ ==

(((side effect)))(((removeChild method)))(((appendChild method)))(((insertBefore method)))(((DOM,construction)))Почти всё в структуре ((DOM)) можно менять. У узлов-элементов есть набор методов, которые используются для их изменения. Метод `removeChild` удаляет заданный дочерний узел. Для добавления узла можно использовать `appendChild`, который добавляет узел в конец списка, либо `insertBefore`, добавляющий узел, переданный первым аргументом, перед узлом, переданным вторым аргументом.

[source,text/html]
----
<p>Один</p>
<p>Два</p>
<p>Три</p>

<script>
  var paragraphs = document.body.getElementsByTagName("p");
  document.body.insertBefore(paragraphs[2], paragraphs[0]);
</script>
----

Узел может существовать в документе только в одном месте. Поэтому вставляя параграф “Три” перед параграфом “Один” мы фактически удаляем его из конца списка и вставляем в начало, и получаем “Три/Один/Два”. Все операции по вставке узла, в качестве ((стороннего эффекта)), приведут к его исчезновению с текущей позиции (если у него таковая была).

(((insertBefore method)))(((replaceChild method)))Метод `replaceChild` используется для замены одного дочернего узла другим. Он принимает два узла: новый, и тот, который надо заменить. Заменяемый узел должен быть дочерним узлом того элемента, чей метод мы вызываем. Как `replaceChild`, так и `insertBefore` в качестве первого аргумента ожидают получить _новый_ узел.

== Создание узлов ==

(((alt attribute)))(((img (HTML tag))))В следующем примере нам надо сделать скрипт, заменяющий все ((картинки)) (тег `<img>`) в документе текстом, содержащимся в их атрибуте `alt`, который задаёт альтернативное текстовое представление картинки.

(((createTextNode method)))Для этого надо не только удалить картинки, но и добавить новые текстовые узлы им на замену. Для этого мы используем метод `document.createTextNode`.

[source,text/html]
----
<p>The <img src="img/cat.png" alt="Кошка"> в
  <img src="img/hat.png" alt="сапожках">.</p>

<p><button onclick="replaceImages()">Заменить</button></p>

<script>
  function replaceImages() {
    var images = document.body.getElementsByTagName("img");
    for (var i = images.length - 1; i >= 0; i--) {
      var image = images[i];
      if (image.alt) {
        var text = document.createTextNode(image.alt);
        image.parentNode.replaceChild(text, image);
      }
    }
  }
</script>
----

(((text node)))Получая строку, `createTextNode` даёт нам тип 3 узла DOM (текстовый), который мы можем вставить в документ, чтобы он был показан на экране.

(((live data structure)))(((getElementsByTagName
method)))(((childNodes property)))Цикл по картинкам начинается в конце списка узлов. Это сделано потому, что список узлов, возвращаемый методом `getElementsByTagName` (или свойством `childNodes`) постоянно _обновляется_ при изменениях документа. Если б мы начали с начала, удаление первой картинки привело бы к потере списком первого элемента, и во время второго прохода цикла, когда `i` равно 1, он бы остановился, потому что длина списка стала бы также равняться 1.

(((slice method)))Если вам нужно работать с _фиксированным_ списком узлов вместо _живого_, можно преобразовать его в настоящий массив при помощи метода `slice`.

[source,javascript]
----
var arrayish = {0: "один", 1: "два", length: 2};
var real = Array.prototype.slice.call(arrayish, 0);
real.forEach(function(elt) { console.log(elt); });
// → один
//   два
----

(((createElement method)))Для создания узлов-((элемент))ов (тип 1) можно использовать `document.createElement`. Метод принимает имя тега и возвращает новый пустой узел заданного типа.

[[elt]]
(((Popper+++,+++ Karl)))(((DOM,construction)))(((elt function)))Следующий пример определяет инструмент `elt`, создающий узел-элемент и использующий остальные аргументы в качестве его детей. Эта функция потом используется для добавления дополнительной информации к цитате.

[source,text/html]
----
<blockquote id="quote">
  Никакая книга не может быть закончена. Во время работы над ней мы узнаём достаточно для того, чтобы найти её незрелой сразу же после того, как мы отвлеклись от неё.
</blockquote>

<script>
  function elt(type) {
    var node = document.createElement(type);
    for (var i = 1; i < arguments.length; i++) {
      var child = arguments[i];
      if (typeof child == "string")
        child = document.createTextNode(child);
      node.appendChild(child);
    }
    return node;
  }

  document.getElementById("quote").appendChild(
    elt("footer", "—",
        elt("strong", "Карл Поппер"),
        ", предисловие ко второму изданию ",
        elt("em", "Открытое общество и его враги"),
        ", 1950"));
</script>
----

ifdef::book_target[]

This is what the resulting document looks like:

image::img/blockquote.png[alt="A blockquote with attribution",width="8cm"]

endif::book_target[]

== Атрибуты ==

(((href attribute)))К некоторым ((атрибут))ам элементов, типа `href` у ссылок, можно получить доступ через одноимённое ((свойство)) объекта. Это возможно для ограниченного числа часто используемых стандартных атрибутов.

(((data attribute)))(((getAttribute method)))(((setAttribute method)))Но HTML позволяет назначать узлам любые атрибуты. Это полезно, т.к. позволяет вам хранить дополнительную информацию в документе. Если вы придумаете свои названия атрибутов, их не будет среди свойств узла-элемента. Вместо этого вам надо будет использовать методы `getAttribute` и `setAttribute` для работы с ними.

[source,text/html]
----
<p data-classified="secret">Код запуска 00000000.</p>
<p data-classified="unclassified">У кошки четыре ноги.</p>

<script>
  var paras = document.body.getElementsByTagName("p");
  Array.prototype.forEach.call(paras, function(para) {
    if (para.getAttribute("data-classified") == "secret")
      para.parentNode.removeChild(para);
  });
</script>
----

Рекомендую перед именами придуманных атрибутов ставить `data-`, чтобы быть уверенным, что они не конфликтуют с любыми другими.

(((programming language)))(((syntax highlighting example)))В качестве простого примера мы напишем “подсветку синтаксиса”, который ищет теги `<pre>` (“preformatted”, предварительно отформатированный – используется для кода и простого текста) с атрибутом `data-language` (язык) и довольно грубо пытается подсветить ((ключевые слова)) в языке.

// include_code

[sandbox="highlight"]
[source,javascript]
----
function highlightCode(node, keywords) {
  var text = node.textContent;
  node.textContent = ""; // Очистим узел

  var match, pos = 0;
  while (match = keywords.exec(text)) {
    var before = text.slice(pos, match.index);
    node.appendChild(document.createTextNode(before));
    var strong = document.createElement("strong");
    strong.appendChild(document.createTextNode(match[0]));
    node.appendChild(strong);
    pos = keywords.lastIndex;
  }
  var after = text.slice(pos);
  node.appendChild(document.createTextNode(after));
}
----

(((pre (HTML tag))))(((syntax highlighting example)))(((highlightCode function)))Функция `highlightCode` принимает узел `<pre>` и ((регулярное выражение)) (с включённой настройкой “global”), совпадающую с ключевым словом языка программирования, которое содержит элемент.

(((strong (HTML tag))))(((clearing)))(((textContent property)))Свойство `textContent` используется для получения всего ((текст))а узла, а затем устанавливается в пустую строку, что приводит к очищению узла. Мы в цикле проходим по всем вхождениям выражения `keyword`, добавляем _между_ ними текст в виде простых текстовых узлов, а совпавший текст (ключевые слова) добавляем, заключая их в элементы `<strong>` (жирный шрифт).

(((data attribute)))(((getElementsByTagName method)))Мы можем автоматически подсветить весь код страницы, перебирая в цикле все элементы `<pre>`, у которых есть атрибут `data-language`, и вызывая на каждом `highlightCodeс` правильной регуляркой.

// include_code

[sandbox="highlight"]
[source,javascript]
----
var languages = {
  javascript: /\b(function|return|var)\b/g /* … и т.д. */
};

function highlightAllCode() {
  var pres = document.body.getElementsByTagName("pre");
  for (var i = 0; i < pres.length; i++) {
    var pre = pres[i];
    var lang = pre.getAttribute("data-language");
    if (languages.hasOwnProperty(lang))
      highlightCode(pre, languages[lang]);
  }
}
----

(((syntax highlighting example)))Вот пример:

[sandbox="highlight"]
[source,text/html]
----
<p>А вот и она, функция идентификации:</p>
<pre data-language="javascript">
function id(x) { return x; }
</pre>

<script>highlightAllCode();</script>
----

ifdef::book_target[]

This produces a page that looks like this:

image::img/highlighted.png[alt="A highlighted piece of code",width="4.8cm"]

endif::book_target[]

(((getAttribute method)))(((setAttribute method)))(((className property)))(((class attribute)))Есть один часто используемый атрибут, `class`, имя которого является ((ключевым словом)) в JavaScript. По историческим причинам, когда старые реализации JavaScript не умели обращаться с именами свойств, совпадавшими с ключевыми словами, этот атрибут доступен через свойство под названием `className`. Вы также можете получить к нему доступ по его настоящему имени `"class"` через методы `getAttribute` и `setAttribute`.

== Расположение элементов ==

(((layout)))(((block element)))(((inline element)))(((p (HTML tag))))(((h1 (HTML tag))))(((a (HTML tag))))(((strong (HTML tag))))Вы могли заметить, что разные типы элементов располагаются по-разному. Некоторые, типа параграфов `<p>` и заголовков `<h1>` растягиваются на всю ширину документа и появляются на отдельных строках. Такие элементы называют _блочными_ (_block_). Другие, как ссылки `<a>` или акцентированный текст `<strong>` появляются на одной строчке с окружающим их текстом. Они называются _встроенными_ (_inline_).

(((drawing)))Для любого документа браузеры могут вычислить расположение элементов (раскладку), в которой у каждого элемента будет размер и положение на основе его типа и содержимого. Затем эта раскладка используется для создания внешнего вида документа.

(((border (CSS))))(((offsetWidth property)))(((offsetHeight property)))(((clientWidth property)))(((clientHeight property)))(((dimensions)))Размер и положение элемента можно узнать через JavaScript. Свойства `offsetWidth` и `offsetHeight` выдают размер в _((пикселях))_, занимаемый элементом. Пиксель – основная единица измерений в браузерах, и обычно соответствует размеру минимальной точки экрана. Сходным образом, `clientWidth` и `clientHeight` дают размер _внутренней_ части элемента, не считая бордюра (или, как говорят некоторые, поребрика).

[source,text/html]
----
<p style="border: 3px solid red">
  Я в коробочке
</p>

<script>
  var para = document.body.getElementsByTagName("p")[0];
  console.log("clientHeight:", para.clientHeight);
  console.log("offsetHeight:", para.offsetHeight);
</script>
----

ifdef::book_target[]

Giving a paragraph a border causes a rectangle to be drawn around it.

image::img/boxed-in.png[alt="A paragraph with a border",width="8cm"]

endif::book_target[]


[[boundingRect]]
(((getBoundingClientRect method)))(((position)))(((pageXOffset property)))(((pageYOffset property)))Самый эффективный способ узнать точное расположение элемента на экране – метод `getBoundingClientRect`. Он возвращает объект со свойствами `top`, `bottom`, `left`, и `right` (сверху, снизу, слева и справа), которые содержат положение элемента относительно левого верхнего угла экрана в пикселях. Если вам надо получить эти данные относительно всего документа, вам надо прибавить текущую позицию прокрутки, которая содержится в глобальных переменных `pageXOffset` и `pageYOffset`.

(((offsetHeight property)))(((getBoundingClientRect method)))(((drawing)))(((laziness)))(((performance)))(((efficiency)))Разбор документа – задача сложная. В целях быстродействия браузерные движки не перестраивают документ каждый раз после его изменения, а ждут так долго. как это возможно. Когда программа JavaScript, изменившая документ, заканчивает работу, браузеру надо будет просчитать новую раскладку страницы, чтобы вывести изменённый документ на экран. Когда программа _запрашивает_ позицию или размер чего-либо, читая свойства типа `offsetHeight` или вызывая `getBoundingClientRect`, для предоставления корректной информации тоже необходимо рассчитывать ((раскладку)).

(((side effect)))(((optimization)))(((benchmark)))Программа, которая периодически считывает раскладку DOM и изменяет DOM, заставляет браузер много раз пересчитывать раскладку, и в связи с этим будет работать медленно. В следующем примере есть две разные программы, которые строят линию из символов _X_ шириной в 2000 пикс, и измеряют время работы.
A program that
repeatedly alternates between reading DOM layout information and
changing the DOM forces a lot of layouts to happen and will
consequently run really slowly. The following code shows an example of
this. It contains two different programs that build up a line of _X_
characters 2,000 pixels wide and measures the time each one takes.

// test: nonumbers

[source,text/html]
----
<p><span id="one"></span></p>
<p><span id="two"></span></p>

<script>
  function time(name, action) {
    var start = Date.now(); // Текущее время в миллисекундах
    action();
    console.log(name, "took", Date.now() - start, "ms");
  }

  time("naive", function() {
    var target = document.getElementById("one");
    while (target.offsetWidth < 2000)
      target.appendChild(document.createTextNode("X"));
  });
  // → тупо заняло 32 мс

  time("clever", function() {
    var target = document.getElementById("two");
    target.appendChild(document.createTextNode("XXXXX"));
    var total = Math.ceil(2000 / (target.offsetWidth / 5));
    for (var i = 5; i < total; i++)
      target.appendChild(document.createTextNode("X"));
  });
  // → умно заняло 1 мс
</script>
----

== Стили ==

(((block element)))(((inline element)))(((style)))(((strong (HTML tag))))(((a (HTML tag))))(((underline)))Мы видели, что разные элементы HTML ведут себя по-разному. Некоторые показываются в виде блоков, другие встроенные. Некоторые добавляют визуальный стиль – например, `<strong>` делает ((жирным)) текст и `<a>` делает текст подчёркнутым и синим.

(((img (HTML tag))))(((default behavior)))(((style attribute)))Внешний вид картинки в теге `<img>` или то, что ссылка в теге `<a>` при клике открывает новую страницу, связано с типом элемента. Но основные стили, связанные с элементом, вроде цвета текста или подчёркивания, могут быть нами изменены. Вот пример использования свойства `style` (стиль):

[source,text/html]
----
<p><a href=".">Обычная ссылка</a></p>
<p><a href="." style="color: green">Зелёная ссылка</a></p>
----

ifdef::book_target[]

The second link will be green instead of the default link color.

image::img/colored-links.png[alt="A normal and a green link",width="2.2cm"]

endif::book_target[]

(((border (CSS))))(((color (CSS))))(((CSS)))(((colon character)))Атрибут `style` может содержать одно или несколько _((объявлений))_ свойств (например, `color`), за которым следует двоеточие и значение (например, `green`). В случае нескольких объявлений они разделяются ((точкой с запятой)): `"color: red; border: none"`.

(((display (CSS))))(((layout)))Много всякого можно изменить при помощи стилей. Например, свойство `display` контролирует, показывается ли элемент в блочном или встроенном виде.

[source,text/html]
----
Текст показан <strong>встроенным</strong>,
<strong style="display: block">в виде блока</strong>, и
<strong style="display: none">вообще не виден</strong>.
----

(((hidden element)))((Блочный элемент)) выводится отдельным блоком на собственной строке, а последний вообще не виден – `display: none` отключает показ элементов. Таким образом можно прятать элементы. Обычно это предпочтительно полному удалению их из документа, потому что их легче потом при необходимости снова показать.

ifdef::book_target[]

image::img/display.png[alt="Different display styles",width="4cm"]

endif::book_target[]

(((color (CSS))))(((style attribute)))Код JavaScript может напрямую действовать на стиль элемента через свойство узла `style`. В нём содержится объект, имеющий свойства для всех свойств стилей. Их значения – строки, в которые мы можем писать для смены какого-то аспекта стиля элемента.

[source,text/html]
----
<p id="para" style="color: purple">
  Красотень
</p>

<script>
  var para = document.getElementById("para");
  console.log(para.style.color);
  para.style.color = "magenta";
</script>
----

(((camel case)))(((capitalization)))(((dash character)))(((font-family (CSS))))Некоторые имена свойств стилей содержат дефисы, например `font-family`. Так как с ними неудобно было бы работать в JavaScript (пришлось бы писать `style["font-family"]`), названия свойств в объекте стилей пишутся без дефиса, а вместо этого в них появляются прописные буквы: `style.fontFamily`.

== Каскадные стили ==

indexsee:[Cascading Style Sheets,CSS]
(((rule (CSS))))(((style (HTML tag))))Система стилей в HTML называется ((CSS)) (_Cascading Style Sheets_, _каскадные таблицы стилей_). _((Таблица стилей))_ – набор стилей в документе. Его можно писать внутри тега `<style>`.

[source,text/html]
----
<style>
  strong {
    font-style: italic;
    color: gray;
  }
</style>
<p>Теперь <strong>текст тега strong</strong> наклонный и серый.</p>
----

(((rule (CSS))))(((font-weight (CSS))))(((overlay)))_((Каскадные))_ означает, что несколько правил комбинируются для получения окончательного стиля документа. В примере на стиль по умолчанию для `<strong>`, который делает текст жирным, накладывается правило из тега `<style>`, по которому добавляется `font-style` и `color`.

(((style (HTML tag))))(((style attribute)))Когда значение свойства определяется несколькими правилами, ((приоритет)) остаётся у более поздних. Если бы стиль текста в `<style>` включал правило `font-weight: normal`, конфликтующее со стилем по умолчанию, то текст был бы обычный, а _не_ жирный. Стили, которые применяются к узлу через атрибут `style`, имеют наивысший приоритет.

(((uniqueness)))(((class attribute)))(((id attribute)))В CSS возможно задавать не только название ((тег))ов. Правило для `.abc` применяется ко всем элементам, у которых указан класс `"abc"`. Правило для `#xyz` применяется к элементу с атрибутом `id` равным `"xyz"` (атрибуты `id` необходимо делать уникальными для документа).

[source,text/css]
----
.subtle {
  color: gray;
  font-size: 80%;
}
#header {
  background: blue;
  color: white;
}
/* Элементы p, у которых указаны классы a и b, а id задан как main */
p.a.b#main {
  margin-bottom: 20px;
}
----

(((rule (CSS))))((Приоритет)) самых поздних правил работает, когда у правил одинаковая _((детализация))_. Это мера того, насколько точно оно описывает подходящие элементы, определяемая числом и видом (тег, класс, или идентификатор) необходимых аспектов элементов. К примеру, правило для `p.a` более детально, чем правила для `p` или просто `.a`, и будет иметь приоритет над ними.

(((direct child node)))Запись `p > a {…}` применима ко всем тегам `<a>`, находящимся внутри тега `<p>` и являющимся его прямыми потомками.
Подобным образом, `p a {…}` применимо также ко всем тегам `<a>` внутри `<p>`, при этом неважно, является ли `<a>` прямым потомком или нет.

== Селекторы запросов ==

(((complexity)))В этой книге мы не будем часто использовать ((таблицы стилей)). Понимание их работы критично для программирования в браузере, но подробное разъяснение всех их свойств заняло бы 2-3 книги.

(((domain-specific language)))Главная причина знакомства с ними и с синтаксисом _((селектор))ов_ (записей, определяющих, к каким элементам относятся правила) – мы можем использовать тот же эффективный мини-язык для поиска элементов ((DOM)).

(((querySelectorAll method)))Метод `querySelectorAll`, существующий и у объекта `document`, и у элементов-узлов, принимает строку селектора и возвращает ((массивоподобный объект)), содержащий все элементы, подходящие под него.

[source,text/html]
----
<p>Люблю грозу в начале
  <span class="animal">мая</span>,</p>
<p>Когда весенний, первый гром,</p>
<p>Как бы <span class="character">резвяся
  <span class="animal">и играя</span></span>,</p>
<p>Грохочет в небе голубом.</p>

<script>
  function count(selector) {
    return document.querySelectorAll(selector).length;
  }
  console.log(count("p"));           // Все элементы <p>
  // → 4
  console.log(count(".animal"));     // Класс animal
  // → 2
  console.log(count("p .animal"));   // Класс animal внутри <p>
  // → 2
  console.log(count("p > .animal")); // Прямой потомок <p>
  // → 1
</script>
----

(((live data structure)))В отличие от методов вроде `getElementsByTagName`, возвращаемый `querySelectorAll` объект _не_ интерактивный. Он не изменится, если вы измените документ.

(((querySelector method)))Метод `querySelector` (без `All`) работает сходным образом. Он нужен, если вам необходим один конкретный элемент. Он вернёт только первое совпадение, или `null`, если совпадений нет.

[[animation]]
== Расположение и анимация ==

(((position (CSS))))(((relative positioning)))(((top (CSS))))(((left (CSS))))(((absolute positioning)))Свойство стилей `position` сильно влияет на расположение элементов. По умолчанию оно равно `static`, что означает, что элемент находится на своём обычном месте в документе. Когда оно равно `relative`, элемент всё ещё занимает место, но теперь свойства `top` и `left` можно использовать для сдвига относительно его обычного расположения. Когда оно равно `absolute`, элемент удаляется из нормального “потока” документа – то есть, он не занимает место и может накладываться на другие. Кроме того, его свойства `left` и `top` можно использовать для абсолютного позиционирования относительно левого верхнего угла ближайшего включающего его элемента, у которого `position` не равно `static`. А если такого элемента нет, тогда он позиционируется относительно документа.

Мы можем использовать это для создания ((анимации)). Следующий документ показывает картинку с котом, которая двигается по ((эллипсу)):

[source,text/html]
----
<p style="text-align: center">
  <img src="img/cat.png" style="position: relative">
</p>
<script>
  var cat = document.querySelector("img");
  var angle = 0, lastTime = null;
  function animate(time) {
    if (lastTime != null)
      angle += (time - lastTime) * 0.001;
    lastTime = time;
    cat.style.top = (Math.sin(angle) * 20) + "px";
    cat.style.left = (Math.cos(angle) * 200) + "px";
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
</script>
----

ifdef::book_target[]

The gray arrow shows the path along which the image moves.

image::img/cat-animation.png[alt="A moving cat head",width="8cm"]

endif::book_target[]

(((top (CSS))))(((left (CSS))))(((centering)))(((relative positioning)))Картинка отцентрирована на странице и ей задана `position: relative`. Мы постоянно обновляем свойства `top` и `left` картинки, чтобы она двигалась.

[[animationFrame]]
(((requestAnimationFrame function)))(((drawing)))(((animation)))Скрипт использует `requestAnimationFrame` для вызова функции `animate` каждый раз, когда браузер готов перерисовывать экран. Функция `animate` сама опять вызывает `requestAnimationFrame`, чтобы запланировать следующее обновление. Когда окно браузера (или закладка) активна, это приведёт к обновлениям со скорость примерно 60 раз в секунду, что позволяет добиться хорошо выглядящей анимации.

(((timeline)))(((blocking)))Если бы мы просто обновляли DOM в цикле, страница бы зависла и ничего не было бы видно. Браузеры не обновляют страницу во время работы JavaScript, и не допускают в это время работы со страницей. Поэтому нам нужна `requestAnimationFrame` – она сообщает браузеру, что мы пока закончили, и он может заниматься своими браузерными вещами, например обновлять экран и отвечать на запросы пользователя.

(((smooth animation)))Наша функция ((анимации)) передаётся текущее ((время)) через аргументы, которое оно сравнивает с предыдущим (переменная `lastTime`), чтобы движение кота было однородным, и анимация работала плавно. Если бы мы просто передвигали её на заданный промежуток на каждом шаге, движение бы запиналось если бы, например, другая задача загрузила бы компьютер.

[[sin_cos]]
(((Math.cos function)))(((Math.sin function)))(((cosine)))(((sine)))(((trigonometry)))Движение по ((круг))у осуществляется с применением тригонометрических функций `Math.cos` и `Math.sin`. Я кратко опишу их для тех, кто с ними не знаком, так как они понадобятся нам в дальнейшем.

(((coordinates)))(((pi)))`Math.cos` и `Math.sin` полезны тогда, когда надо найти точки на окружности с центром в точке (0, 0) и радиусом в единицу. Обе функции интерпретируют свой аргумент как позицию на окружности, следуя против часовой стрелки, от нуля в самой правой точке, пока путь диной в 2π (около 6.28) не проведёт нас по кругу. `Math.cos` считает координату по оси x той точки, которая является нашей текущей позицией на окружности, а `Math.sin` выдаёт координату y. Позиции (или углы) больше, чем 2π или меньше чем 0, тоже допустимы – повороты повторяются так, что _a_+2π означает тот же самый ((угол)), что и _a_.

image::img/cos_sin.svg[alt="Using cosine and sine to compute coordinates",width="6cm"]

(((counter variable)))(((Math.sin function)))(((top (CSS))))(((Math.cos function)))(((left (CSS))))(((ellipse)))Анимация кота хранит счётчик `angle` для текущего угла поворота анимации, и увеличивает его пропорционально прошедшему времени каждый раз при вызове функции `animation`. Этот угол используется для подсчёта текущей позиции элемента `image`. Стиль `top` подсчитывается через `Math.sin` и умножается на 20 – это вертикальный радиус нашего эллипса. Стиль `left` считается через `Math.cos` и умножается на 200, так что ширина эллипса сильно больше высоты.

(((unit (CSS))))Стилям обычно требуются _единицы измерения_. В нашем случае приходится добавлять `"px"` к числу, чтобы объяснить браузеру, что мы считаем в ((пикселях)) (а не в сантиметрах, “ems” или других единицах). Это легко забыть. Использование чисел без единиц измерения приведёт к игнорированию стиля – если только число не равно 0, что не зависит от единиц измерения.

== Итог ==

Программы JavaScript могут изучать и изменять текущий отображаемый браузером документ через структуру под названием DOM. Эта структура данных представляет модель документа браузера, а программа JavaScript может изменять её для изменения видимого документа.

DOM организован в виде дерева, в котором элементы расположены иерархически в соответствии со структурой документа. У объектов элементов есть свойства типа `parentNode` и `childNodes`, которые используются для ориентирования на дереве.

Внешний вид документа можно изменять через стили, либо добавляя _стили_ к узлам напрямую, либо определяя правила для каких-либо узлов. У стилей есть очень много свойств, таких, как `color` или `display`. JavaScript может влиять на стиль элемента напрямую через его свойство `style`.

== Упражнения ==

[[exercise_table]]
=== Строим таблицу ===

(((table (HTML tag))))Мы строили ((таблицы)) из простого текста в link:06_object.html#tables[главе 6]. HTML упрощает построение таблиц. Таблица в ((HTML)) строится при помощи следующих тегов:

[source,text/html]
----
<table>
  <tr>
    <th>name</th>
    <th>height</th>
    <th>country</th>
  </tr>
  <tr>
    <td>Kilimanjaro</td>
    <td>5895</td>
    <td>Tanzania</td>
  </tr>
</table>
----

(((tr (HTML tag))))(((th (HTML tag))))(((td (HTML tag))))Для каждой _((строки))_ в теге `<table>` содержится тег `<tr>`. Внутри него мы можем размещать ячейки: либо ячейки заголовков `<th>`, либо обычные ячейки `<td>`.

(((download)))(((MOUNTAINS data set)))(((table example)))Те же данные, что мы использовали в link:06_object.html#mountains[главе 6], снова доступны в переменной `MOUNTAINS`. Их также можно http://eloquentjavascript.net/2nd_edition/code/mountains.js[скачать]
с сайта(!book (http://eloquentjavascript.net/2nd_edition/code#13[_eloquentjavascript.net/2nd_edition/code#13_])!).

Напишите функцию `buildTable`, которая, принимая массив объектов с одинаковыми свойствами, строит структуру DOM, представляющую таблицу. У таблицы должна быть строка с заголовками, где имена свойств обёрнуты в элементы `<th>`, и должно быть по одной строчке на объект из массива, где его свойства обёрнуты в элементы `<td>`.

(((Object.keys function)))Здесь пригодится функция `Object.keys`, возвращающая массив, содержащий имена свойств объекта.

(((right-aligning)))(((text-align (CSS))))Когда вы разберётесь с основами, выровняйте ячейки с числами по правому краю, изменив их свойство `style.textAlign` на `"right"`.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<style>
  /* Определяет стили для красивых таблиц */
  table  { border-collapse: collapse; }
  td, th { border: 1px solid black; padding: 3px 8px; }
  th     { text-align: left; }
</style>

<script>
  function buildTable(data) {
    // Ваш код.
  }

  document.body.appendChild(buildTable(MOUNTAINS));
</script>
----
endif::interactive_target[]

!!hint!!

(((createElement method)))(((table example)))(((appendChild
method)))Use `document.createElement` to create new element nodes,
`document.createTextNode` to create text nodes, and the `appendChild`
method to put nodes into other nodes.

You should loop over the key names once to fill in the top row and
then again for each object in the array to construct the data
rows.

Don't forget to return the enclosing `<table>` element at the end of
the function.

!!hint!!

=== Элементы по имени тегов ===

(((getElementsByTagName method)))(((recursion)))Метод `getElementsByTagName` возвращает все дочерние элементы с заданным именем тега. Сделайте свою версию этого метода в виде обычной функции, которая принимает узел и строчку (имя тега) и возвращает массив, содержащий все нисходящие узлы с заданным именем тега.

(((tagName property)))(((capitalization)))(((toLowerCase method)))(((toUpperCase method)))Чтобы выяснить имя тега элемента, используйте свойство `tagName`. Заметьте, что оно возвратит имя тега в верхнем регистре. Используйте методы строк `toLowerCase` или `toUpperCase`.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<h1>Заголовок с элементом <span>span</span> внутри.</h1>
<p>Параграф с <span>раз</span>, <span>два</span> элементами
  span.</p>

<script>
  function byTagName(node, tagName) {
    // Ваш код.
  }

  console.log(byTagName(document.body, "h1").length);
  // → 1
  console.log(byTagName(document.body, "span").length);
  // → 3
  var para = document.querySelector("p");
  console.log(byTagName(para, "span").length);
  // → 2
</script>
----
endif::interactive_target[]

!!hint!!

(((getElementsByTagName method)))(((recursion)))The solution is most
easily expressed with a recursive function, similar to the
link:13_dom.html#talksAbout[`talksAbout` function] defined earlier in
this chapter.

(((concatenation)))(((concat method)))(((closure)))You could call
`byTagname` itself recursively, concatenating the resulting arrays to
produce the output. For a more efficient approach, define an inner
function that calls itself recursively and that has access to an
array variable defined in the outer function to which it can add the
matching elements it finds. Don't forget to call the ((inner
function)) once from the outer function.

(((nodeType property)))(((ELEMENT_NODE code)))The recursive function
must check the node type. Here we are interested only in node type 1
(`document.ELEMENT_NODE`). For such nodes, we must loop over their
children and, for each child, see whether the child matches the query while also doing
a recursive call on it to inspect its own children.

!!hint!!

=== Шляпа кота ===

(((cat's hat (exercise))))Расширьте ((анимацию)) кота из link:13_dom.html#animation[примера], чтобы и кот и его шляпа `<img src="img/hat.png">` летали по противоположным сторонам эллипса.

Или пусть шляпа летает вокруг кота. Или ещё что-нибудь интересное придумайте.

(((absolute positioning)))(((top (CSS))))(((left (CSS))))(((position (CSS))))Чтобы упростить расположение множества объектов, неплохо будет переключиться на абсолютное позиционирование. Тогда `top` и `left` будут считаться относительно левого верхнего угла документа. Чтобы не использовать отрицательные координаты, вы можете добавить заданное число пикселей к значениям `position`.

ifdef::interactive_target[]

// test: no

[source,text/html]
----
<img src="img/cat.png" id="cat" style="position: absolute">
<img src="img/hat.png" id="hat" style="position: absolute">

<script>
  var cat = document.querySelector("#cat");
  var hat = document.querySelector("#hat");
  // Ваш код.
</script>
----

endif::interactive_target[]
