:chap_num: 10
:prev_link: 09_regexp
:next_link: 11_language
:load_files: ["code/chapter/10_modules.js", "code/loadfile.js"]

= Модули =

ifdef::interactive_target[]

[chapterquote="true"]
[quote, Мастер Юан-Ма, Книга программирования]
____
Начинающий программист пишет программы так, как муравьи строят муравейник – по кусочку, без размышления над общей структурой. Его программы как песок. Они могут недолго простоять, но вырастая, они разваливаются.

Поняв проблему, программист тратит много времени на размышления о структуре. Его программы получаются жёстко структурированными, как каменные изваяния. Они тверды, но когда их нужно менять, над ними приходится совершать насилие.

Мастер-программист знает, когда нужна структура, а когда нужно оставить вещи в простом виде. Его программы словно глина – твёрдые, но податливые.
____

endif::interactive_target[]

(((organization)))(((code structure)))У каждой программы есть структура. В частностях она определяется тем, как программист делит код на ((функции)) и блоки внутри этих функций. Программисты вольны в создании структуры своей программы. Структура определяется больше ((вкус))ом программиста, нежели функциональностью программы.

(((readability)))В случае больших программ отдельные функции уже теряются в коде, и нам необходима единица организации кода больших масштабов. _Модули_ группируют программный код по каким-то _определённым_ признакам. В этой главе мы рассмотрим преимущества такого деления и техники создания ((модулей)) в JavaScript.

== Зачем нужны модули ==

(((book analogy)))(((organization)))Есть несколько причин, по которым авторы делят свои книги на ((главы)) и секции. Это помогает читателю понять, как построена книга, и найти нужные им части. _Автору_ это помогает концентрироваться на каждой конкретной части. Преимущества организации программ в нескольких ((файл))ах, или ((модулях)), примерно те же. Структуризация помогает незнакомым с кодом людям найти то, что им нужно, и помогает программистам хранить связанные друг с другом вещи в одном месте.

(((project chapter)))(((readability)))(((interconnection)))Некоторые программы организованы по модели обычного ((текст))а, где порядок следования чётко определён, и где читателю предлагается последовательное изучение программы и множество прозы (комментариев) для описания кода. Это делает чтение кода менее пугающим (а чтение чужого кода обычно пугает), но требует больших усилий при создании кода. Также такую программу сложнее менять, потому что части прозы связаны между собой сильнее, чем части кода. Этот стиль называется _((литературным программированием))_. Те главы книги, в которых обсуждаются проекты, можно считать литературным кодом.

(((minimalism)))(((evolution)))(((structure)))(((organization)))Обычно структурирование чего-либо требует затрат энергии. На ранних стадиях проекта, когда вы ещё не уверены, что где будет, и какие ((модули)) вообще нужны, я пропагандирую бесструктурную минималистическую организацию кода. Просто размещайте все части там, где удобно, пока код не стабилизируется. Таким образом не придётся тратить время на перестановку кусков программы, и вы не поймаете себя в такую структуру, которая не подходит для вашей программы.

=== Пространство имён ===

(((encapsulation)))(((isolation)))(((global scope)))(((local scope)))У большинства современных ((языков программирования)) есть промежуточные ((области видимости)) (ОВ) между _глобальной_ (видно всем) и _локальной_ (видно только этой функции). У JavaScript такого нет. По умолчанию, всё, что необходимо видеть снаружи функции верхнего уровня, находится в _глобальной_ ОВ.

(((namespace pollution)))Загрязнение пространства имён, когда не связанные друг с другом части кода делят один набор переменных, упоминалась в link:04_data.html#namespace_pollution[главе 4]. Там объект `Math` был приведён в качестве примера объекта, который группирует функциональность, связанную с математикой, в виде модуля.

(((function,as namespace)))Хотя JavaScript не предлагает непосредственно конструкции для создания ((модуля)), мы можем использовать объекты для создания подпространств имён, доступных отовсюду. А функции можно использовать для создания изолированных частных пространств имён внутри модуля. Чуть дальше мы обсудим способ построения достаточно удобных модулей, изолирующих пространства имён при помощи базовых концепций языка.

=== Повторное использование ===

(((version control)))(((bug)))(((copy-paste programming)))(((ini file)))(((dependency)))(((structure)))В проекте, не разбитом на ((модули)), непонятно, какие части кода необходимы для конкретной функции. В моей программе, шпионящей за врагами (link:09_regexp.html#ini[глава 9])), я написал функцию чтения файлов с настройками. Если мне понадобится использовать её в другом проекте, я должен буду скопировать части старой программы, которые вроде бы связаны с этой функцией, в мой новый проект. А если я найду там ошибку, я её исправлю только в том проекте, над которым работаю в данный момент, и забуду исправить её во всех остальных.

(((duplication)))Когда у вас будет множество таких сдублированных кусков кода, вы обнаружите, что тратите кучу времени и сил на их копирование и обновление. Если разместить связанные между собой части программ в отдельные модули, их будет проще отслеживать, исправлять и обновлять, потому что везде, где этот функционал потребуется, вы сможете просто загрузить этот модуль из файла.

(((dependency)))(((library)))(((installation)))(((upgrading)))Эту идею можно использовать ещё лучше, если чётко прописать взаимоотношения разных модулей – кто от кого зависит. Тогда можно автоматизировать процесс установки и обновления внешних модулей (_библиотек_).

(((package manager)))(((download)))(((reuse)))Если ещё развить идею – представьте себе онлайн-сервис, который отслеживает и распространяет сотни тысяч таких библиотек, и вы можете искать нужную вам функциональность среди них, а когда найдёте – ваш проект автоматически скачает её.

[[modules_npm]]
(((NPM)))И такой сервис есть! Он называется NPM (http://npmjs.org[_npmjs.org_]). NPM – онлайн-база модулей и инструмент для скачивания и апгрейда модулей, от которых зависит ваша программа. он вырос из ((Node.js)), окружения JavaScript, не требующего браузера, которое мы обсудим в link:20_node.html#node[главе 20], но также может использоваться и в браузерных программах.

=== Устранение связей ===

(((isolation)))(((decoupling)))(((backward compatibility)))Ещё одна задача модулей – изолировать несвязанные между собой части кода так, как это делают интерфейсы объектов из link:06_object.html#interface[главы 6]. Хорошо продуманный модуль предоставляет интерфейс для его использования вовне. Когда модуль обновляют или исправляют, существующий ((интерфейс)) остаётся неизменным, чтобы другие модули могли использовать новую, обновлённую версию без изменений в них самих.

(((stability)))Стабильный интерфейс не означает, что в него не добавляют новые функции, методы или переменные. Главное, что существующая функциональность не удаляется и её смысл не меняется.

(((implementation detail)))(((encapsulation)))Хороший ((интерфейс)) позволяет ((модулю)) расти, не ломая старый интерфейс. А это значит – выставлять наружу как можно меньше внутренней кухни модуля, при этом “язык” интерфейса должен быть достаточно гибким и мощным для применения в различных ситуациях.

(((interface,design)))Интерфейсы, выполняющие простую задачу, вроде чтения настроек из файла, выходят такими естественным образом. Для других – к примеру, для редактора текстов, у которого есть множество разных аспектов, требующих доступа извне (содержимое, стили, действия пользователя и т.п.) интерфейс необходимо скрупулёзно продумывать.

== Использование функций в качестве пространств имён ==

(((namespace)))(((function,as namespace)))Функции – единственная вещь в JavaScript, создающая новую ((область видимости)). Если нам нужно, чтобы у ((модулей)) была своя область видимости, придётся основывать их на функциях.

(((weekday example)))(((Date type)))(((getDay method)))Обратите внимание на простейший модуль, связывающий имена с номерами дней недели – как делает метод `getDay` объекта `Date`.

[source,javascript]
----
var names = ["Понедельник", "Вторник", "Среда", "Четверг",
             "Пятница", "Суббота", "Воскресенье"];
function dayName(number) {
  return names[number];
}

console.log(dayName(1));
// → Вторник
----

(((access control)))(((encapsulation)))Функция `dayName` – часть ((интерфейса)) модуля, а переменная `names` – нет. Но хотелось бы _не_ загрязнять ((глобальное пространство имён)).

Можно сделать так:

[source,javascript]
----
var dayName = function() {
  var names = ["Понедельник", "Вторник", "Среда", "Четверг",
               "Пятница", "Суббота", "Воскресенье"];
  return function(number) {
    return names[number];
  };
}();

console.log(dayName(3));
// → Четверг
----

(((anonymous function)))Теперь `names` – локальная переменная безымянной функции. Функция создаётся и сразу вызывается, а её возвращаемое значение (уже нужная нам функция `dayName`) хранится в переменной. Мы можем написать много страниц кода в функции, объявить там сотню переменных, и все они будут внутренними для нашего модуля, а не для внешнего кода.

(((isolation)))(((side effect)))Подобный шаблон можно использовать для изолирования кода. Следующий модуль пишет в консоль значение, но не предоставляет никаких значений для использования другими модулями:

[source,javascript]
----
(function() {
  function square(x) { return x * x; }
  var hundred = 100;

  console.log(square(hundred));
})();
// → 10000
----

(((namespace pollution)))Этот код выводит квадрат сотни, но в реальности это мог бы быть модуль, добавляющий метод к какому-то ((прототипу)), или настраивающий виджет на веб-странице. Он обёрнут в функцию для предотвращения загрязнения ((глобальной области видимости)) используемыми им переменными.

(((parsing)))(((function keyword)))А зачем мы заключили функцию в ((круглые скобки))? Это связано с глюком ((синтаксис))а JavaScript. Если _((выражение))_ начинается с ключевого слова `function`, это функциональное выражение. А если _((инструкция))_ начинается с `function`, это _объявление_ функции, которое требует названия, и, так как это не выражение, не может быть вызвано при помощи скобок `()` после неё. Можно представлять себе заключение в скобки как трюк, чтобы функция принудительно интерпретировалась как выражение.

== Объекты в качестве интерфейсов ==

(((interface)))Представьте, что нам надо добавить ещё одну функцию в наш модуль “день недели”. Мы уже не можем возвращать функцию, а должны завернуть две функции в объект.

[source,javascript]
----
var weekDay = function() {
  var names = ["Понедельник", "Вторник", "Среда", "Четверг",
               "Пятница", "Суббота", "Воскресенье"];
  return {
    name: function(number) { return names[number]; },
    number: function(name) { return names.indexOf(name); }
  };
}();

console.log(weekDay.name(weekDay.number("Среда")));
// → Среда
----

(((exporting)))(((exports object)))(((this)))Когда ((модуль)) большой, собирать все _возвращаемые_ значения в объект в конце функции неудобно, потому что многие возвращаемые функции будут большими, и вам было бы удобнее их записывать где-то в другом месте, рядом со связанным с ними кодом. Удобно объявить объект (обычно называемый `exports`) и добавлять к нему свойства каждый раз, когда нам надо что-то экспортировать. В следующем примере функция модуля принимает объект интерфейса как аргумент, позволяя коду снаружи функции создать его и сохранить в переменной. Снаружи функции `this` ссылается на объект глобальной области видимости.

[source,javascript]
----
(function(exports) {
  var names = ["Понедельник", "Вторник", "Среда", "Четверг",
               "Пятница", "Суббота", "Воскресенье];

  exports.name = function(number) {
    return names[number];
  };
  exports.number = function(name) {
    return names.indexOf(name);
  };
})(this.weekDay = {});

console.log(weekDay.name(weekDay.number("Четверг")));
// → Четверг
----

== Отсоединяемся от глобальной области видимости ==

(((variable,global)))Такой шаблон часто используется в модулях JavaScript, предназначающихся для ((браузер))а. Модуль возьмёт одну глобальную переменную и обернёт свой код в функцию, чтобы у него было своё личное ((пространство имён)). Но с этим шаблоном бывают проблемы, когда много модулей требуют одно и то же имя, или когда вам надо загрузить две ((версии)) модуля одновременно.

(((module loader)))(((require function)))(((CommonJS)))(((dependency)))Подкрутив кое-что, мы можем сделать систему, разрешающую одному ((модулю)) обращаться к ((интерфейсному)) объекту другого, без выхода в глобальную ОВ. Наша цель – функция `require`, которая, получая имя модуля, загрузит его файл (с диска или из сети, в зависимости от платформы) и вернёт соответствующее значение с интерфейсом.

Этот подход решает проблемы, упомянутые ранее, и у него есть ещё одно преимущество – зависимости вашей программы становятся явными, и поэтому сложнее случайно вызвать ненужный вам модуль без чёткого его объявления.

(((readFile function)))(((require function)))Нам понадобятся две вещи. Во-первых, функция `readFile`, возвращающая содержимое файла в виде строки. В ((стандартном)) JavaScript такой функции нет, но разные окружения, такие как браузер или Node.js, предоставляют свои способы доступа к ((файлам)). Пока притворимся, что у нас есть такая функция. Во-вторых, нам нужна возможность выполнить содержимое этой строки как код.

[[eval]]
== Выполняем данные как код ==

(((evaluation)))(((interpretation)))Есть несколько способов получить данные (строку кода) и выполнить их как часть текущей программы.

(((isolation)))(((eval)))Самый очевидный – оператор `eval`, который выполняет строку кода в _текущем_ окружении. Это плохая идея – он нарушает некоторые свойства окружения, которые обычно у него есть, например изоляция от внешнего мира.

[source,javascript]
----
function evalAndReturnX(code) {
  eval(code);
  return x;
}

console.log(evalAndReturnX("var x = 2"));
// → 2
----

(((Function constructor)))Способ лучше – использовать конструктор `Function`. Он принимает два аргумента – строку, содержащую список имён аргументов через запятую, и строку, содержащую тело функции.

[source,javascript]
----
var plusOne = new Function("n", "return n + 1;");
console.log(plusOne(4));
// → 5
----

Это то, что нам надо. Мы обернём код модуля в функцию, и её область видимости станет ((областью видимости)) нашего модуля.

[[commonjs]]
== Require ==

(((require function)))(((CommonJS)))Вот минимальная версия функции `require`:

// test: wrap

[source,javascript]
----
function require(name) {
  var code = new Function("exports", readFile(name));
  var exports = {};
  code(exports);
  return exports;
}

console.log(require("weekDay").name(1));
// → Вторник
----

(((weekday example)))(((exports object)))(((Function constructor)))Так как конструктор `new Function` оборачивает код модуля в функцию, нам не надо писать функцию, оборачивающую ((пространство имён)), внутри самого модуля. А так как `exports` является аргументом функции модуля, модулю не нужно его объявлять. Это убирает много мусора из нашего модуля-примера.

[source,javascript]
----
var names = ["Понедельник", "Вторник", "Среда", "Четверг",
             "Пятница", "Суббота", "Воскресенье"];

exports.name = function(number) {
  return names[number];
};
exports.number = function(name) {
  return names.indexOf(name);
};
----

(((require function)))При использовании такого шаблона ((модуль)) обычно начинается с объявления нескольких переменных, которые загружают модули, от которых он зависит.

// test: no

[source,javascript]
----
var weekDay = require("weekDay");
var today = require("today");

console.log(weekDay.name(today.dayNumber()));
----

(((efficiency)))У такого простого варианта `require` есть недостатки. Во-первых, он загрузит и выполнит модуль каждый раз, когда его грузят через `require` – если у нескольких модулей есть одинаковые зависимости, или вызов `require` находится внутри функции, которая вызывается многократно, будет потеряно время и энергия.

(((cache)))Это можно решить, храня уже загруженные модули в объекте, и возвращая существующее значение, когда он грузится несколько раз.

(((exports object)))(((exporting)))Вторая проблема – модуль не может экспортировать переменную напрямую, только через объект `export`. К примеру, модулю может потребоваться экспортировать только конструктор объекта, объявленного в нём. Сейчас это невозможно, поскольку `require` всегда использует объект `exports` в качестве возвращаемого значения.

(((module object)))Традиционное решение – предоставить модули с другой переменной, `module`, которая является объектом со свойством `exports`. Оно изначально указывает на пустой объект, созданный `require`, но может быть перезаписано другим значением, чтобы экспортировать что-либо ещё.

// test: wrap
// include_code

[source,javascript]
----
function require(name) {
  if (name in require.cache)
    return require.cache[name];

  var code = new Function("exports, module", readFile(name));
  var exports = {}, module = {exports: exports};
  code(exports, module);

  require.cache[name] = module.exports;
  return module.exports;
}
require.cache = Object.create(null);
----

(((require function)))Сейчас у нас есть система модулей, использующих одну глобальную переменную `require`, чтобы позволять модулям искать и использовать друг друга без выхода в ((глобальную область видимости)).

Такой стиль системы модулей называется _((CommonJS))_, по имени псевдо((стандарт))а, который первым его описал. Он встроен в систему ((Node.js)). Настоящие реализации делают гораздо больше описанного мною. Главное, что у них есть более умный способ перехода от имени модуля к его коду, который разрешает загружать модули по относительному пути к файлу, или же по имени модуля, указывающему на локально установленные модули.

[[amd]]
== Медленная загрузка модулей ==

(((loading)))(((synchronous I/O)))(((blocking)))(((World Wide Web)))Хотя и возможно использовать стиль CommonJS для ((браузер))а, но он не очень подходит для этого. Загрузка файла из Сети происходит медленнее, чем с жёсткого диска. Пока скрипт в браузере работает, на сайте ничего другого не происходит (по причинам, которые станут ясны к link:14_event.html#timeline[главе 14]). Значит, если бы каждый вызов `require` скачивал что-то с дальнего веб-сервера, страница бы зависла на очень долгое время при загрузке.

(((Browserify)))(((require function)))(((preprocessing)))Можно обойти это, запуская программу типа http://browserify.org[_Browserify_] с вашим кодом перед выкладыванием её в веб. Она просмотрит все вызовы `require`, обработает все зависимости и соберёт нужный код в один большой файл. Веб-сайт просто грузит этот файл и получает все необходимые модули.

(((AMD)))(((dependency)))(((asynchronous I/O)))Второй вариант – оборачивать код модуля в функцию, чтобы ((загрузчик модулей)) сначала грузил зависимости в фоне, а потом вызывал функцию, инициализирующую ((модуль)), после загрузки зависимостей. Этим занимается система AMD (асинхронное определение модулей).

(((weekday example)))Наша простая программа с зависимости выглядела бы в AMD так:

// test: no

[source,javascript]
----
define(["weekDay", "today"], function(weekDay, today) {
  console.log(weekDay.name(today.dayNumber()));
});
----

(((define function)))(((asynchronous programming)))Функция `define` здесь самая важная. Она принимает массив имён модулей, а затем функцию, принимающую один аргумент для каждой из зависимостей. Она загрузит зависимости (если они уже не загружены) в фоне, позволяя странице работать, пока файлы качаются. Когда всё загружено, `define` вызывает данную ему функцию, с ((интерфейс))ами этих зависимостей в качестве аргументов.

(((weekday example)))(((define function)))Загруженные таким образом модули должны содержать вызовы `define`. В качестве их интерфейса используется то, что было возвращено функцией, переданной в `define`. Вот модуль `weekDay`:

[source,javascript]
----
define([], function() {
  var names = ["Понедельник", "Вторник", "Среда", "Четверг",
               "Пятница", "Суббота", "Воскресенье"];
  return {
    name: function(number) { return names[number]; },
    number: function(name) { return names.indexOf(name); }
  };
});
----

(((define function)))(((backgroundReadFile function)))Чтобы показать минимальную реализацию `define`, притворимся, что у нас есть функция `backgroundReadFile`, которая принимает имя файла и функцию, и вызывает эту функцию с содержимым этого файла, как только он будет загружен. (В link:17_http.html#getURL[главе 17] будет объяснено, как написать такую функцию.)

Чтоб отслеживать модули, пока они загружаются, `define` использует объекты, описывающие состояние модулей, сообщает нам, доступны ли они уже, и предоставляет их интерфейс по доступности.

Функция `getModule` принимает имя и возвращает такой объект, и убеждается в том, что модуль поставлен в очередь загрузки. Она использует ((кеш))ирующий объект, чтобы не грузить один модуль дважды.

// include_code

[source,javascript]
----
var defineCache = Object.create(null);
var currentMod = null;

function getModule(name) {
  if (name in defineCache)
    return defineCache[name];

  var module = {exports: null,
                loaded: false,
                onLoad: []};
  defineCache[name] = module;
  backgroundReadFile(name, function(code) {
    currentMod = module;
    new Function("", code)();
  });
  return module;
}
----

(((define function)))Мы предполагаем, что загружаемый файл тоже содержит вызов `define`. Переменная `currentMod` используется, чтобы сообщить этому вызову о загружаемом объекте модуля, чтобы тот смог обновить этот объект после загрузки. Мы ещё вернёмся к этому механизму.

(((dependency)))(((Function constructor)))(((asynchronous programming)))(((event handling)))Функция `define` сама использует `getModule` для загрузки или создания объектов модулей для зависимостей текущего модуля. Её задача – запланировать запуск функции `moduleFunction` (содержащей сам код модуля) после загрузки зависимостей. Для этого она определяет функцию `whenDepsLoaded`, добавляемую в массив `onLoad`, содержащий все пока ещё не загруженные зависимости. Эта функция сразу прекращает работу, если есть ещё незагруженные зависимости, так что она выполнит свою работу только раз, когда последняя зависимость загрузится. Она также вызывается сразу из самого `define`, в случае когда никакие зависимости не нужно грузить.

// include_code

[source,javascript]
----
function define(depNames, moduleFunction) {
  var myMod = currentMod;
  var deps = depNames.map(getModule);

  deps.forEach(function(mod) {
    if (!mod.loaded)
      mod.onLoad.push(whenDepsLoaded);
  });

  function whenDepsLoaded() {
    if (!deps.every(function(m) { return m.loaded; }))
      return;

    var args = deps.map(function(m) { return m.exports; });
    var exports = moduleFunction.apply(null, args);
    if (myMod) {
      myMod.exports = exports;
      myMod.loaded = true;
      myMod.onLoad.forEach(function(f) { f(); });
    }
  }
  whenDepsLoaded();
}
----

(((define function)))Когда все зависимости доступны, `whenDepsLoaded` вызывает функцию, содержащую модуль, передавая в виде аргументов интерфейсы зависимостей.

Первое, что делает `define`, это сохраняет значение `currentMod`, которое было у него при вызове, в переменной `myMod`. Вспомните, что `getModule` прямо перед исполнением кода модуля сохранил соответствующий объект модуля в `currentMod`. Это позволяет `whenDepsLoaded` хранить возвращаемое значение функции модуля в свойстве `exports` этого модуля, установить свойство `loaded` модуля в true, и вызвать все функции, ждавшие загрузки модуля.

(((asynchronous programming)))Этот код изучать тяжелее, чем функцию `require`. Его выполнение идёт не по простому и предсказуемому пути. Вместо этого, несколько операций должны быть выполнены в неопределённые моменты в ((будущем)), что затрудняет изучения того, как выполняется этот код.

Настоящая реализация ((AMD)) гораздо умнее подходит к превращению имён модулей в URL и более надёжна, чем показано в примере. Проект _((RequireJS))_ (http://requirejs.org[_requirejs.org_]) предоставляет популярную реализацию такого стиля ((загрузчика модулей)).

== Разработка интерфейса ==

(((interface,design)))Разработка интерфейсов – один из самых тонких моментов в программировании. Любую нетривиальную функциональность можно реализовать множеством способов. Поиск работающего способа требует проницательности и предусмотрительности.

Лучший способ познать значимость хорошего интерфейса – использовать много интерфейсов. Некоторые будут плохие, некоторые хорошие. Опыт покажет вам, что работает, а что – нет. Никогда не принимайте как должное плохой интерфейс. Исправьте его, или заключите в другой интерфейс, который лучше вам подходит.

=== Предсказуемость ===

(((documentation)))(((predictability)))(((convention)))Если программист может предсказать, как работает ваш интерфейс, ему не придётся часто отвлекаться и смотреть подсказку по его использованию. Постарайтесь следовать общепринятым соглашениям. Если есть модуль или часть языка JavaScript, которая делает что-то похожее на то, что вы пытаетесь реализовать – будет неплохо, если ваш интерфейс будет напоминать существующий. Таким образом, он будет привычен для людей, знакомых с существующим интерфейсом.

(((cleverness)))В _поведении_ вашего кода предсказуемость также важна. Вас может постичь искушение сделать интерфейс слишком заумным якобы потому, что его удобнее использовать. К примеру, вы можете принимать любые виды типов и комбинаций аргументов и проделывать с ними “то, что надо”. Или предоставлять десятки специализированных функций, которые предлагают незначительно отличающуюся функциональность. Это может сделать код, опирающийся на ваш интерфейс, немного короче, зато затруднить людям, работающим с ним, строить чёткую ((мысленную модель)) работы вашего модуля.

=== Компонуемость ===

(((composability)))Старайтесь использовать в интерфейсах настолько простые ((структуры данных)), насколько это возможно. Делайте так, чтобы функции выполняли простые и понятные вещи. Если это применимо, делайте ((функции чистыми)) (см. link:03_functions.html#pure[главу 3]).

(((array-like object)))К примеру, частенько модули предлагают свою версию массивоподобных коллекций объектов со своим интерфейсом для подсчёта и извлечения элементов. У таких объектов нет методов `map` или `forEach`, и никакая функция, ожидающая настоящий массив, не сможет с ними работать. Это пример плохой _компонуемости_ – модуль нельзя легко скомпоновать с другим кодом.

(((encapsulation)))(((spell-check example)))Примером может служить модуль для орфографической проверки текста, который может пригодиться в текстовом редакторе. Проверочный модуль можно сделать таким, чтобы он работал с любыми сложными ((структурами данных)), используемыми самим редактором, и вызывал внутренние функции редактора для предоставления пользователю выбора вариантов написания. Если вы поступите таким образом, модуль нельзя будет использовать с другими программами. С другой стороны, если мы определим интерфейс модуля проверки, который принимает простую строку и возвращает позицию, на которой в строке есть возможная ошибка, а впридачу – массив предлагаемых поправок, тогда у нас будет интерфейс, который можно скомпоновать с другими системами, потому что строки и массивы всегда доступны в JavaScript.

=== Многослойные интерфейсы ===

(((simplicity)))(((complexity)))(((layering)))(((interface design)))Разрабатывая интерфейс для сложной системы (к примеру, отправка email), часто приходишь к дилемме. С одной стороны, не нужно перегружать пользователя интерфейса деталями. Не надо заставлять их изучать его 20 минут перед тем, как они смогут отправить email. С другой стороны, не хочется и прятать все детали – когда людям надо сделать что-то сложное при помощи вашего модуля, у них должна быть такая возможность.

Часто приходится предлагать два интерфейса: детализированный _низкоуровневый_ для сложных ситуаций, и простой _высокоуровневый_ для обычного использования. Второй можно построить на основе первого. В модуле для отправки email высокоуровневый интерфейс может быть просто функцией, которая принимает сообщение, адрес получателя и отправителя, и отправляет письмо. Низкоуровневый должен давать доступ к заголовкам, приложенным файлам, HTML письмам и т.д.

== Итог ==

Модули позволяют структурировать большие программы, разделяя код по разным файлам и пространствам имён. Если обеспечить их хорошо разработанными интерфейсами, их будет просто использовать, применять в других проектах и продолжать использовать при развитии и эволюции самого проекта.

Хотя JavaScript совершенно не помогает делать модули, его гибкие функции и объекты позволяют сделать достаточно неплохую систему модулей. Область видимости функций используется как внутреннее пространство имён модуля, а объекты используются для хранения наборов переменных.

Есть два популярных подхода к использованию модулей. Один – _CommonJS Modules_, построенный на функции `require`, которая вызывает модули по имени и возвращает их интерфейс. Другой – _AMD_, использующий функцию `define`, принимающую массив имён модулей и, после их загрузки, исполняющую функцию, аргументами которой являются их интерфейсы.

== Упражнения ==

=== Названия месяцев ===

(((Date type)))(((weekday example)))(((month name (exercise))))Напишите простой модуль типа `weekday`, преобразующий номера месяцев (начиная с нуля) в названия и обратно. Выделите ему собственное пространство имён, т.к. ему потребуется внутренний массив с названиями месяцев, и используйте чистый JavaScript, без системы загрузки модулей.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Ваш код.

console.log(month.name(2));
// → March
console.log(month.number("November"));
// → 10
----
endif::interactive_target[]

!!hint!!

(((month name (exercise))))This follows the `weekDay` module almost
exactly. A function expression, called immediately, wraps the variable
that holds the array of names, along with the two functions that must
be exported. The functions are put in an object and returned. The
returned interface object is stored in the `month` variable.

!!hint!!

=== Вернёмся к электронной жизни ===

(((electronic life)))(((module)))Надеюсь, что link:07_elife.html#elife[глава 7] ещё не стёрлась из вашей памяти. Вернитесь к разработанной там системе и предложите способ разделения кода на модули. Чтобы освежить вам память – вот список функций и типов, по порядку появления:

----
Vector
Grid
directions
directionNames
randomElement
BouncingCritter
elementFromChar
World
charFromElement
Wall
View
WallFollower
dirPlus
LifelikeWorld
Plant
PlantEater
SmartPlantEater
Tiger
----

(((book analogy)))Не надо создавать слишком много модулей. Книга, в которой на каждой странице была бы новая глава, действовала бы вам на нервы (хотя бы потому, что всё место съедали бы заголовки). Не нужно делать десять файлов для одного мелкого проекта. Рассчитывайте на 3-5 модулей.

(((encapsulation)))Некоторые функции можно сделать внутренними, недоступными из других модулей. Правильного варианта здесь не существует. Организация модулей – вопрос ((вкус))а.

!!hint!!

Here is what I came up with. I've put parentheses around internal
functions.

----
Module "grid"
  Vector
  Grid
  directions
  directionNames

Module "world"
  (randomElement)
  (elementFromChar)
  (charFromElement)
  View
  World
  LifelikeWorld
  directions [reexported]

Module "simple_ecosystem"
  (randomElement) [duplicated]
  (dirPlus)
  Wall
  BouncingCritter
  WallFollower

Module "ecosystem"
  Wall [duplicated]
  Plant
  PlantEater
  SmartPlantEater
  Tiger
----

(((exporting)))I have reexported the `directions` array from the
`grid` module from `world` so that modules built on that (the
ecosystems) don't have to know or worry about the existence of the
`grid` module.

(((duplication)))I also duplicated two generic and tiny helper values
(`randomElement` and `Wall`) since they are used as internal details
in different contexts and do not belong in the interfaces for these
modules.

!!hint!!

=== Круговые зависимости ===

(((dependency)))(((circular dependency)))(((require function)))Запутанная тема в управлении зависимостями – круговые зависимости, когда модуль А зависит от Б, а Б зависит от А. Многие системы модулей это просто запрещают. Модули ((CommonJS)) допускают ограниченный вариант: это работает, пока модули не заменяют объект `exports`, существующий по-умолчанию, другим значением, и начинают использовать интерфейсы друг друга только после окончания загрузки.

Можете ли вы придумать способ, который позволил бы воплотить систему поддержки таких зависимостей? Посмотрите на определение `require` и подумайте, что нужно сделать этой функции для этого.

!!hint!!

(((overriding)))(((circular dependency)))(((exports object)))The trick
is to add the `exports` object created for a module to `require`'s
((cache)) _before_ actually running the module. This means the module
will not yet have had a chance to override `module.exports`, so we do
not know whether it may want to export some other value. After
loading, the cache object is overridden with `module.exports`, which
may be a different value.

But if in the course of loading the module, a second module is loaded
that asks for the first module, its default `exports` object, which is likely
still empty at this point, will be in the cache, and the second module
will receive a reference to it. If it doesn't try to do anything with
the object until the first module has finished loading, things will
work.

!!hint!!
