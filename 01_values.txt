:chap_num: 1
:prev_link: 00_intro
:next_link: 02_program_structure
:docid: values

= Величины, типы и операторы =

[chapterquote="true"]
[quote, Мастер Юан-Ма, Книга Программирования]
____
Под поверхностью машины движется программа. Без усилий, она расширяется и сжимается. Находясь в великой гармонии, электроны рассеиваются и собираются. Формы на мониторе – лишь рябь на воде. Суть остаётся скрытой внутри…
____

(((Yuan-Ma)))(((Book of Programming)))(((binary data)))(((data)))(((bit)))(((memory)))В компьютерном мире есть только данные. Можно читать данные, изменять данные, создавать новые – но кроме данных ничего нет. Все данные хранятся как длинные последовательности бит, этим они сходны между собой.

(((CD)))(((signal)))Биты – это сущности с двумя состояниями, обычно описываемые как нули и единицы. В компьютере они живут в виде высоких и низких электрических зарядов, сильного или слабого сигнала, или блестящего и матового участка на поверхности CD. Каждая часть информации может быть представлена в виде последовательности нулей и единиц, то есть бит.

(((binary number)))(((radix)))(((decimal number)))К примеру, число 13. Вместо десятичной системы, состоящей из 10 цифр, у вас есть двоичная система с двумя ((цифра))ми. Значение каждой позиции числа удваивается при движении справа налево. Биты, составляющие число 13, вместе с их весами:

----
   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1
----

Получается двоичное число 00001101, или 8 + 4 + 1, что равно 13.

== Величины ==

(((memory)))(((volatile data storage)))(((hard drive)))Представьте океан бит. Типичный современный компьютер хранит более 30 миллиардов бит в оперативной памяти. Постоянная память (жёсткий диск) обычно ещё на пару порядков объёмнее.

image::img/bit-sea.png[alt="The Ocean of Bits"]

Чтобы работать с ними и не заблудиться, вы можете делить их на куски, представляющие единицы информации. В JavaScript эти единицы называются _((величина))ми_. Все их значения состоят из бит, но играют разные роли. У каждой величины есть ((тип)), определяющий его роль. Всего есть шесть основных типов: числа, строки, булевые величины, объекты, функции и неопределённые величины.

(((garbage collection)))Для создания величины вам нужно указать её имя. Это удобно. Вам не надо собирать стройматериалы или платить за них. Нужно просто позвать – и _оп-па_, готово. Они не создаются из воздуха – каждая величина где-то хранится, и если вы хотите использовать огромное их количество, у вас могут закончиться биты. К счастью, это только если они все нужны вам одновременно. Когда величина вам станет не нужна, она растворяется, и использованные ею биты поступают в переработку как стройматериал для новых величин.

В этой главе мы знакомимся с атомами программ JavaScript – это простые типы величин и операторы, которые к ним применимы.

== Числа ==

(((syntax)))(((number)))(((number,notation)))Величины _числовых_ типов, это – сюрприз – числа. В программе JavaScript они записываются как:

[source,javascript]
----
13
----

(((binary number)))Используйте эту запись в программе, и она вызовет к жизни в компьютерной памяти цепочку бит, представляющую число 13.

(((number,representation)))(((bit)))JavaScript использует фиксированное число бит (64) для хранения численных величин. Число величин, которые можно выразить при помощи 64 бит, ограничено – то есть и сами числа тоже ограничены. Для _N_ десятичных ((цифр)) количество чисел, которые ими можно записать, равно 10^_N_^. Аналогично, 64 битами можно выразить 2^64^ чисел, что составляет около 18 квинтиллионов (это 18 с 18 нулями). Это довольно много.

Раньше у компьютеров памяти было меньше, и тогда для хранения чисел использовали группы из 8 или 16 бит. Было легко случайно превысить максимальное число для таких небольших чисел – то есть, использовать число, которое не помещалось в этот набор бит и происходило _((переполнение))_. Сегодня у компьютеров памяти много, можно использовать куски по 64 бит, и значит вам надо беспокоиться об этом только, если вы работаете с астрономическими числами.

(((sign)))(((floating-point number)))(((fractional number)))(((sign bit)))Правда, не все числа меньше 18 квинтиллионов помещаются в число JavaScript. В этих битах также хранятся отрицательные числа – поэтому, один бит хранит знак числа. Кроме того, нам нужно иметь возможность хранить дроби. Для этого часть бит используется для хранения позиции десятичной точки. Реальный максимум для чисел – примерно 9 квадриллионов (число с 15 нулями), что в общем всё равно довольно много.

(((number,notation)))Дроби записываются с помощью точки.

[source,javascript]
----
9.81
----

(((exponent)))(((scientific notation)))(((number,notation)))Очень большие или маленькие числа записываются научной записью с буквой “e” (“exponent”), за которой следует степень:

[source,javascript]
----
2.998e8
----

Это 2.998 × 10^8^ = 299,800,000.

(((pi)))(((number,precision of)))(((floating-point number)))Вычисления с целыми числами (которые также называются _((integer))_), меньшими, чем 9 квадриллионов, гарантировано будут точными. Вычисления с дробями обычно нет. Так же, как число π (пи) нельзя представить точно при помощи конечного числа цифр, так и многие дроби нельзя представить в случае, когда у нас есть только 64 бита. Плохо, но это мешает в очень специфических случаях. Важно помнить об этом и относиться к дробям как к приближённым значениям.

=== Арифметика ===

(((syntax)))(((operator)))(((binary operator)))(((arithmetic)))(((addition)))(((multiplication)))Главное, что можно делать с числами – это арифметические вычисления. Сложения и умножения используют два числа и выдают третье. Как это записывается в JavaScript:

[source,javascript]
----
100 + 4 * 11
----

(((operator,application)))(((asterisk)))(((plus character)))(((pass:[*] operator)))(((+ operator)))Символы `+` и `*` называются _операторами_. Первый – сложение, второй – умножение. Помещаем оператор между двумя величинами и получаем значение выражения.

(((grouping)))(((parentheses)))(((precedence)))А в примере получается “сложить 4 и 100 и затем умножить результат на 11” или умножение выполняется сначала? Как вы могли догадаться, умножение выполняется первым. Но как и в математике, это можно изменить при помощи скобок:

[source,javascript]
----
(100 + 4) * 11
----

(((dash character)))(((slash character)))(((division)))(((subtraction)))(((minus)))(((- operator)))(((/ operator)))Для вычитания используется оператор `-`, а для деления — `/`.

Когда операторы используются без скобок, порядок их выполнения определяется их _((приоритет))ом_. У операторов `*` и `/` приоритет одинаковый, выше, чем у `+` и `-`, которые между собой равны по приоритету. При вычислении операторов с равным приоритетом, например, `1 - 2 + 1`, они вычисляются слева направо: `(1 - 2) + 1`.

Пока беспокоиться о приоритетах не надо. Если сомневаетесь – используйте скобки.

(((modulo operator)))(((division)))(((remainder operator)))(((% operator)))Есть ещё один оператор, который вы не сразу узнаете. Символ `%` используется для получения _остатка_. `X % Y` – остаток от деления `X` на `Y`. `314 % 100` даёт `14`, и `144 % 12` даёт `0`. Приоритет у оператора такой же, как у умножения и деления. Его ещё часто называют _модулем_, хотя более правильно _остатком_.

=== Специальные числа ===

(((number,special values)))В JavaScript есть три специальных значения, которые считаются числами, но ведут себя не как обычные числа.

(((infinity)))Это `Infinity` и `-Infinity`, которые представляют положительную и отрицательную бесконечности. `Infinity — 1` всё ещё `Infinity`, и так далее. Не надейтесь сильно на вычисления с бесконечностями, они не слишком строгие.

(((NaN)))(((not a number)))(((division by zero)))Третье значение: NaN. Обозначает “not a number” (не число), хотя это величина числового типа. Вы можете получить её после вычислений типа `0 / 0`, `Infinity – Infinity`, или других операций, которые не ведут к точным осмысленным результатам.

== Строки ==

(((syntax)))(((text)))(((character)))(((string,notation)))(((single-quote character)))(((double-quote character)))(((quotation mark)))
Следующий базовый тип данных – _((строка))_. Они используются для хранения текста. Записываются они в кавычках:

[source,javascript]
----
"Что посеешь, то из пруда"
'Баба с возу, потехе час'
----

Можно использовать как двойные, так и одинарные кавычки – главное использовать их вместе.

(((line break)))(((newline character)))Почти всё можно заключить в кавычки и сделать из этого строку. Но некоторые символы вызывают проблемы. Например, сложно заключить кавычки в кавычки. _Перевод строки_ тоже нельзя просто так заключить в них – строка должна идти одной строкой.

(((escaping,in strings)))(((backslash character)))Для заключения специальных символов используется обратный слеш `\`. Он обозначает, что символ, идущий за ним, имеет специальное значение – это называется _экранирование_ (“_escape_”) символов. `\”` можно заключать в двойные кавычки. `\n` обозначает перевод строки, `\t` – это ((табуляция)). Следующая строка:

[source,javascript]
----
"Между первой и второй\nсимвол будет небольшой"
----

на самом деле будет выглядеть так:

----
Между первой и второй
символ будет небольшой
----

Если вам нужно включить в строку обратный слеш, его тоже нужно экранировать: `\\`. Инструкцию “++Символ новой строки — это "\n".++” нужно будет написать так:

[source,javascript]
----
"Символ новой строки — это \"\\n\"."
----

(((+ operator)))(((concatenation)))Строки нельзя делить, умножать и вычитать. Однако с ними _можно_ использовать оператор `+`, который будет _соединять_ их друг с другом. Следующее выражение выдаст слово `"соединение"`:

[source,javascript]
----
"сое" + "ди" + "н" + "ение
----

Есть много способов манипуляций со строками, которые мы обсудим в link:04_data.html#methods[Главе 4].

== Унарные операторы ==

(((operator)))(((typeof operator)))(((type)))Не все операторы записываются символами – некоторые словами. Один из таких операторов – `typeof`, который выдаёт название типа величины, к которой он применяется.

[source,javascript]
----
console.log(typeof 4.5)
// → number
console.log(typeof "x")
// → string
----

[[console.log]]

(((console.log)))(((output)))(((JavaScript console)))Будем использовать вызов `console.log` в примерах, когда захотим увидеть результат на экране. Как именно будет выдан результат – зависит от окружения, в котором вы запускаете скрипт.

(((negation)))(((- operator)))(((binary operator)))(((unary operator)))Предыдущие операторы работали с двумя величинами, однако `typeof` использует только одну. Операторы, работающие с двумя величинами, называются _бинарными_, а с одной – _унарными_. Минус (вычитание) можно использовать и как унарный, и как бинарный.

[source,javascript]
----
console.log(- (10 - 2))
// → -8
----

== Булевские величины ==

(((Boolean)))(((operator)))(((true)))(((false)))(((bit)))Часто вам нужна величина, которая просто показывает одну из двух возможностей – типа “да” и “нет”, или “вкл” и “выкл”. Для этого в JavaScript есть тип _Boolean_, у которого есть всего два значения – true и false (правда и ложь).

=== Сравнения ===

(((comparison)))Один из способов получить булевские величины:

[source,javascript]
----
console.log(3 > 2)
// → true
console.log(3 < 2)
// → false
----

(((comparison,of numbers)))(((> operator)))(((< operator)))(((greater than)))(((less than)))Знаки `<` и `>` традиционно обозначают “меньше” и “больше”. Это бинарные операторы. В результате их использования мы получаем булевскую величину, которая показывает, является ли неравенство верным.

Строки можно сравнивать так же.

[source,javascript]
----
console.log("Арбуз" < "Яблоко")
// → true
----

(((comparison,of strings)))Строки сравниваются по алфавиту: буквы в верхнем регистре всегда “меньше” букв в нижнем регистре. Сравнение основано на стандарте _((Unicode))_. Этот стандарт присваивает номер практически любому символу из любого языка. Во время сравнения строк JavaScript проходит по их символам слева направо, сравнивая номерные коды этих символов.

(((equality)))(((>= operator)))(((pass:[<=] operator)))(((== operator)))(((!= operator)))Другие сходные операторы – это `>=` (больше или равно), `<=` (меньше или равно), `==` (равно), `!=` (не равно).

[source,javascript]
----
console.log("Хочется" != "Колется")
// → true
----

(((comparison,of NaN)))(((NaN)))В JavaScript есть только одна величина, которая не равна самой себе – `NaN` (“не число”).

[source,javascript]
----
console.log(NaN == NaN)
// → false
----

`NaN` – это результат любого бессмысленного вычисления, поэтому он не равен результату какого-то _другого_ бессмысленного вычисления.

=== Логические операторы ===

(((reasoning)))(((logical operators)))Есть операции, которые можно совершать и с самими булевскими значениями. JavaScript поддерживает три логических оператора: _и_, _или_, _нет_.
There are also some operations that can be applied to Boolean values themselves. JavaScript supports three logical operators: _and_, _or_, and _not_. These can be used to “reason” about Booleans.

(((&& operator)))(((logical and)))Оператор `&&` — логическое _и_. Он бинарный, и его результат – правда, только если обе величины, к которым он применяется, тоже правда.

[source,javascript]
----
console.log(true && false)
// → false
console.log(true && true)
// → true
----

(((|| operator)))(((logical or)))Оператор `||` — логическое _или_. Выдаёт true, если одна из величин true.

[source,javascript]
----
console.log(false || true)
// → true
console.log(false || false)
// → false
----

(((negation)))(((! operator)))_Нет_ записывается при помощи восклицательного знака (`!`). Это унарный оператор, который обращает данную величину на обратную. `!true` получается `false`, `!false` получается `true`.

(((precedence)))При использовании логических и арифметических операторов не всегда ясно, когда нужны скобки. На практике вы можете справиться с этим, зная, что у `||` приоритет ниже всех, потом идёт `&&`, потом операторы сравнения, потом все остальные. Такой порядок был выбран для того, чтобы в выражениях типа следующего можно было использовать скобок по минимуму:

[source,javascript]
----
1 + 1 == 2 && 10 * 10 > 50
----

(((conditional execution)))(((ternary operator)))(((?: operator)))(((conditional operator)))(((colon character)))(((question mark)))Последний логический оператор не унарный и не бинарный – он _тернарный_ (_тройной_). Записывается при помощи вопросительного знака и двоеточия:

[source,javascript]
----
console.log(true ? 1 : 2);
// → 1
console.log(false ? 1 : 2);
// → 2
----

Это _условный_ оператор, у которого величина слева от вопросительного знака выбирает одну из двух величин, разделённых двоеточием. Когда величина слева true, выбираем первое значение. Когда false, второе.

== Неопределённые значения ==

(((undefined)))(((null)))Существуют два специальных значения, `null` и `undefined`, которые используются для обозначения отсутствия осмысленного значения. Сами по себе они никакой информации не несут.

Много операторов, которые не выдают значения, возвращают `undefined` просто для того, чтобы _что-то_ вернуть.

Разница между `undefined` и `null` появилась в языке случайно, и обычно не имеет значения.

== Автоматическое преобразование типов ==

(((NaN)))(((type coercion)))Ранее я упоминал, что JavaScript позволяет выполнять любые, подчас очень странные программы. К примеру:

[source,javascript]
----
console.log(8 * null)
// → 0
console.log("5" - 1)
// → 4
console.log("5" + 1)
// → 51
console.log("пять" * 2)
// → NaN
console.log(false == 0)
// → true
----

(((+ operator)))(((arithmetic)))(((pass:[*] operator)))(((- operator)))Когда оператор применяется “не к тому” типу величин, JavaScript втихую преобразовывает величину к нужному типу, используя набор правил, которые не всегда соответствуют вашим ожиданиям. Это называется _((приведение типов))_ (_type coercion_). В первом выражении `null` превращается в `0`, а `"5"` становится `5` (из строки – в число). Однако в третьем выражении `+` выполняет конкатенацию (объединение) строк, из-за чего `1` преобразовывается в `"1"` (из числа в строку).

(((type coercion)))(((number,conversion to)))Когда что-то неочевидное превращается в номер (к примеру, `"пять"` или `undefined`), возвращается значение `NaN`. Последующие арифметические операции с `NaN` опять получают `NaN`. Если вы получили такое значение, поищите, где произошло случайное преобразование типов.

(((null)))(((undefined)))(((comparison,of undefined values)))(((== operator)))При сравнении величин одного типа через `==`, легко предсказать, что вы должны получить true, если они одинаковые (исключая случай с `NaN`). Но когда типы различаются, JavaScript использует сложный и запутанный набор правил для сравнений. Обычно он пытается преобразовать тип одной из величин в тип другой. Когда с одной из сторон оператора возникает `null` или `undefined`, он выдаёт true, если обе стороны имеют значение `null` или `undefined`.

[source,javascript]
----
console.log(null == undefined);
// → true
console.log(null == 0);
// → false
----

Последний пример демонстрирует полезный приём. Когда вам надо проверить, имеет ли величина реальное значение вместо `null` или `undefined`, вы просто сравниваете её с `null` при помощи `==` или `!=`.

(((type coercion)))(((Boolean,conversion to)))(((=== operator)))(((!== operator)))(((comparison)))Но что, если вам надо сравнить нечто с точной величиной `false`? Правила преобразования типов в булевские значения говорят, что `0`, `NaN` и пустая строка `""` считаются `false`, а все остальные – `true`. Поэтому `0 == false` и `"" == false`. В случаях, когда вам _не_ нужно автоматическое преобразование типов, можно использовать ещё два оператора: `===` и `!==`. Первый проверяет, что две величины абсолютно идентичны, второй – наоборот. И тогда сравнение `"" === false` возвращает false.

Рекомендую использовать трёхсимвольные операторы сравнения для защиты от неожиданных преобразований типов, которые могут привести к непредсказуемым последствиям. Если вы уверены, что типы сравниваемых величин будут совпадать, можно спокойно использовать короткие операторы.

=== Короткое вычисление логических операторов ===

(((type coercion)))(((Boolean,conversion to)))(((operator)))Логические операторы `&&` и `||` работают с величинами разных типов очень странным образом. Они преобразовывают величину с левой стороны оператора в булевскую, чтобы понять, что делать дальше, но в зависимости от оператора и от результата этого преобразования, возвращают либо _оригинальное_ значение с левой или правой части.

(((|| operator)))К примеру, `||` вернёт значение с левой части, когда его можно преобразовать в true – а иначе вернёт правую часть.

[source,javascript]
----
console.log(null || "user")
// → user
console.log("Karl" || "user")
// → Karl
----

(((default value)))Такая работа оператора `||` позволяет использовать его как откат к значению по умолчанию. Если вы дадите ему выражение, которое может вернуть пустое значение слева, то значение справа будет служить заменой на этот случай.

(((&& operator)))Оператор `&&` работает сходным образом, но наоборот. Если величина слева преобразовывается в false, он возвращает эту величину, а иначе – величину справа.

(((short-circuit evaluation)))Ещё одно важное их свойство – выражение в правой части вычисляется только при необходимости. В случае `true || X` неважно, чему равно `X`. Даже если это какое-то _ужасное_ выражение. Результат всегда true и `X` не вычисляется. Так же работает `false && X` – `X` просто игнорируется. Это называется _коротким вычислением_.

(((ternary operator)))(((?: operator)))(((conditional operator)))Оператор условия работает так же. Первое выражение всегда вычисляется, а из второго и третьего значения – только то, которое оказывается выбранным в результате.

== Итог ==

Мы рассмотрели четыре типа величин JavaScript: числа, строки, булевские и неопределённые.

Эти величины получаются, когда мы пишем их имена (`true`, `null`) или значения (`13`, `"ёпрст"`). Их можно комбинировать и изменять при помощи операторов. Для арифметики есть бинарные операторы (`+`, `-`, `*`, `/`, and `%`), объединение строк (`+`), сравнение (`==`, `!=`, `===`, `!==`, `<`, `>`, `<=`, `>=`), и логические операторы (`&&`, `||`), так же, как и несколько унарных операторов (`-` для отрицательного значения, `!` для логического отрицания, и `typeof` для определения типа величины) и тернарный оператор (`?:`) для выбора одного из двух значений на основании третьего.

Эти знания позволяют использовать JavaScript в качестве калькулятора, но и только. В link:02_program_structure.html#program_structure[следующей главе] мы будем связывать эти простые значения вместе, чтобы составлять простые программы.
