:chap_num: 11
:prev_link: 10_modules
:next_link: 12_browser
:load_files: ["code/chapter/11_language.js"]
:zip: node/html

= Проект: язык программирования =

[chapterquote="true"]
[quote, Хэл Абельсон и Жеральд Сасман, Структура и интерпретация компьютерных программ]
____
То, что проверяет и определяет смысл выражений в языке программирования, является в свою очередь просто программой.
____

ifdef::interactive_target[]

[chapterquote="true"]
[quote, Мастер Юань-Ма, Книга программирования]
____
Когда ученик спросил учителя о природе цикла Данных и Контроля, Юань-Ма ответил: «Подумай о компиляторе, компилирующем самого себя».
____

endif::interactive_target[]

(((Abelson+++,+++ Hal)))(((Sussman+++,+++ Gerald)))(((SICP)))(((project chapter)))Создать свой ((язык программирования)) удивительно легко (пока вы не ставите запредельных целей) и довольно поучительно.

Главное, что я хочу продемонстрировать в этой главе – в построении языка нет никакой ((магии)). Мне часто казалось, что некоторые человеческие изобретения настолько сложны и заумны, что мне их никогда не понять. Однако после небольшого самообразования и ковыряния такие штуки часто оказываются довольно обыденными.

(((Egg language)))Мы построим язык программирования Egg (Яйцо). Он будет небольшим, простым, но достаточно мощным для выражения любых расчётов. Он также будет осуществлять простые ((абстракции)), основанные на ((функциях)).

[[parsing]]
== Разбор ==

(((parsing)))(((validation)))То, что лежит на поверхности языка – _((синтаксис))_, система обозначений. _Грамматический анализатор_, или парсер – программа, читающая кусок текста и выдающая структуру данных, описывающую структуры программы, содержавшейся в тексте. Если текст не описывает корректную программу, парсер должен пожаловаться и указать на ошибку.

(((special form)))У нашего языка будет простой и однородный синтаксис. В Egg всё будет являться ((выражение))м. Выражение может быть переменной, числом, строкой или _приложением_. Приложения используются для вызова функций и конструкций типа `if` или `while`.

(((double-quote character)))(((parsing)))(((escaping,in strings)))Для упрощения парсинга строки в Egg не будут поддерживать обратных слешей и подобных вещей. Строка – просто последовательность символов, не являющихся двойными кавычками, заключённая в двойные кавычки. Число – последовательность цифр. Имена переменных могут состоять из любых символов, не являющихся ((пробел))ами и не имеющих специального значения в синтаксисе.

(((comma character)))Приложения записываются так же, как в JavaScript — при помощи ((скобок)) после выражения и с любым количеством ((аргумент))ов в скобках, разделённых запятыми.

----
do(define(x, 10),
   if(>(x, 5),
      print("много"),
      print("мало")))
----

(((block)))((Однородность)) ((языка Egg)) означает, что то, что в JavaScript является ((оператор))ами, применяется так же, как и остальные ((функции)). Так как в ((синтаксис))е нет концепции блоков, нам нужна конструкция `do` для обозначения нескольких вещей, выполняемых последовательно.

(((type property)))(((parsing)))((Структура данных)), описывающая программу, будет состоять из объектов ((выражений)), у каждого из которых будет свойство `type`, отражающее тип этого выражения и другие свойства, описывающие содержимое.

(((identifier)))Выражения типа `"value"` представляют строки или числа. Их свойство `value` содержит строку или число, которое они представляют. Выражения типа `"word"` используются для идентификаторов (имён). У таких объектов есть свойство `name`, содержащее имя идентификатора в виде строки. И наконец, выражения `"apply"` представляют приложения. У них есть свойство `operator`, ссылающееся на применяемое выражение, и свойство `args` с массивом аргументов.

Часть `>(x, 5)` прошлой программы будет представлена так:

[source,application/json]
----
{
  type: "apply",
  operator: {type: "word", name: ">"},
  args: [
    {type: "word", name: "x"},
    {type: "value", value: 5}
  ]
}
----

indexsee:[abstract syntax tree,syntax tree]
Такая ((структура данных)) называется _((синтаксическим деревом))_. Если вы представите объекты в виде точек, а связи между ними в виде линий, то получите ((древо))видную структуру. То, что выражения содержат другие выражения, которые в свою очередь могут содержать свои выражения, сходно с тем, как разветвляются ветки.

image::img/syntax_tree.svg[alt="The structure of a syntax tree",width="5cm"]

(((parsing)))Сравните это с парсером, написанным нами для файла настроек в link:09_regexp.html#ini[главе 9], у которого была простая структура: он делил ввод на строки и обрабатывал их одну за другой. Там было всего несколько форм, которые разрешено принимать строке.

(((recursion)))(((nesting,of expressions)))Здесь нам нужен другой подход. Выражения не разделяются на строчки, и их структура рекурсивна. Выражения-приложения _содержат_ другие выражения.

(((elegance)))К счастью, эта задача элегантно решается применением рекурсивной функции, отражающей рекурсивность языка.

(((parseExpression function)))(((syntax tree)))Мы определяем функцию `parseExpression`, принимающую строку на вход и возвращающую объект, содержащий структуру данных для выражения с начала строки, вместе с частью строки, оставшейся после парсинга. При разборе подвыражений (таких, как аргумент приложения), эта функция снова вызывается, возвращая выражение аргумента вместе с оставшимся текстом. Тот текст может, в свою очередь, содержать ещё аргументы, или же быть закрывающей скобкой, завершающей список аргументов.

Первая часть парсера:

// include_code

[source,javascript]
----
function parseExpression(program) {
  program = skipSpace(program);
  var match, expr;
  if (match = /^"([^"]*)"/.exec(program))
    expr = {type: "value", value: match[1]};
  else if (match = /^\d+\b/.exec(program))
    expr = {type: "value", value: Number(match[0])};
  else if (match = /^[^\s(),"]+/.exec(program))
    expr = {type: "word", name: match[0]};
  else
    throw new SyntaxError("Неожиданный синтаксис: " + program);

  return parseApply(expr, program.slice(match[0].length));
}

function skipSpace(string) {
  var first = string.search(/\S/);
  if (first == -1) return "";
  return string.slice(first);
}
----

(((skipSpace function)))Поскольку Egg разрешает любое количество ((пробел))ов между элементами, нам надо постоянно вырезать пробелы с начала строки. С этим справляется `skipSpace`.

(((literal expression)))(((SyntaxError type)))Пропустив начальные пробелы, `parseExpression` использует три ((регулярных выражения)) для распознавания трёх простых (атомарных) элементов, поддерживаемых языком: строк, чисел и слов. Парсер создаёт разные структуры для разных типов. Если ввод не подходит ни под одну из форм, это не является допустимым выражением, и он выбрасывает ошибку. `SyntaxError` – стандартный объект для ошибок, который создаётся при попытке запуска некорректной программы JavaScript.

(((parseApply function)))Мы можем отрезать обработанную часть программы, и передать её остаток, вместе с объектом выражения, в `parseApply`, определяющая, не является ли выражение приложением. Если так и есть, он парсит список аргументов в скобках.

// include_code

[source,javascript]
----
function parseApply(expr, program) {
  program = skipSpace(program);
  if (program[0] != "(")
    return {expr: expr, rest: program};

  program = skipSpace(program.slice(1));
  expr = {type: "apply", operator: expr, args: []};
  while (program[0] != ")") {
    var arg = parseExpression(program);
    expr.args.push(arg.expr);
    program = skipSpace(arg.rest);
    if (program[0] == ",")
      program = skipSpace(program.slice(1));
    else if (program[0] != ")")
      throw new SyntaxError("Ожидается ',' или ')'");
  }
  return parseApply(expr, program.slice(1));
}
----

(((parsing)))Если следующий символ программы – не открывающая скобка, то это не приложение, и `parseApply` просто возвращает данное ей выражение.

(((recursion)))В ином случае, она пропускает открывающую скобку и создаёт объект ((синтаксического дерева)) для этого выражения. Затем она рекурсивно вызывает `parseExpression` для разбора каждого аргумента, пока не встретит закрывающую скобку. Рекурсия непрямая, `parseApply` и `parseExpression` вызывают друг друга.

Поскольку выражение приложения само по себе может быть выражением приложения (например, `multiplier(2)(1)`), `parseApply` должна, после разбора приложения, вызвать себя снова, проверив, не идёт ли далее другая пара скобок.

(((syntax tree)))(((Egg language)))(((parse function)))Вот и всё, что нам нужно для разбора Egg. Мы обернём это в удобную функцию `parse`, проверяющую, что она дошла до конца строки после разбора выражения (программа Egg – это одно выражение), и это даст нам структуру данных программы.

// include_code strip_log
// test: join

[source,javascript]
----
function parse(program) {
  var result = parseExpression(program);
  if (skipSpace(result.rest).length > 0)
    throw new SyntaxError("Неожиданный текст после программы");
  return result.expr;
}

console.log(parse("+(a, 10)"));
// → {type: "apply",
//    operator: {type: "word", name: "+"},
//    args: [{type: "word", name: "a"},
//           {type: "value", value: 10}]}
----

(((error message)))Работает! Она не выдаёт полезной информации при ошибке, и не хранит номера строки и столбца, с которых начинается каждое выражение, что могло бы пригодиться при разборе ошибок – но для нас и этого хватит.

== Интерпретатор ==

(((evaluate function)))(((evaluation)))(((interpretation)))(((syntax tree)))(((Egg language)))А что нам делать с синтаксическим деревом программы? Запускать его! Этим занимается интерпретатор. Вы даёте ему синтаксическое дерево и объект окружения, который связывает имена со значениями, а он интерпретирует выражение, представляемое деревом, и возвращает результат.

// include_code

[source,javascript]
----
function evaluate(expr, env) {
  switch(expr.type) {
    case "value":
      return expr.value;

    case "word":
      if (expr.name in env)
        return env[expr.name];
      else
        throw new ReferenceError("Неопределённая переменная: " +
                                 expr.name);
    case "apply":
      if (expr.operator.type == "word" &&
          expr.operator.name in specialForms)
        return specialForms[expr.operator.name](expr.args,
                                                env);
      var op = evaluate(expr.operator, env);
      if (typeof op != "function")
        throw new TypeError("Приложение не является функцией.");
      return op.apply(null, expr.args.map(function(arg) {
        return evaluate(arg, env);
      }));
  }
}

var specialForms = Object.create(null);
----

(((literal expression)))(((environment)))У интерпретатора есть код для каждого из типов ((выражений)). Для литералов он возвращает их значение. Например, выражение `100` интерпретируется в число 100. У переменной мы должны проверить, определена ли она в окружении, и если да – запросить её значение.

(((function,application)))С приложениями сложнее. Если это ((особая форма)) типа `if`, мы ничего не интерпретируем, а просто передаём аргументы вместе с окружением в функцию, обрабатывающую форму. Если это простой вызов, мы интерпретируем оператор, проверяем, что это функция и вызываем его с результатом интерпретации аргументов.

Для представления значений функций Egg мы будем использовать простые значения функций JavaScript. Мы вернёмся к этому link:11_language.html#egg_fun[позже], когда определим специальную форму `fun`.

(((readability)))(((evaluate function)))(((recursion)))(((parsing)))Рекурсивная структура интерпретатора напоминает парсер. Оба отражают структуру языка. Можно было бы интегрировать парсер в интерпретатор и интерпретировать во время разбора, но их разделение делает программу более читаемой.

(((Egg language)))(((interpretation)))Вот и всё, что нужно для интерпретации Egg. Вот так просто. Но без определения нескольких специальных форм и добавления полезных значений в ((окружение)), вы с этим языком ничего не сможете сделать.

== Специальные формы ==

(((special form)))(((specialForms object)))Объект `specialForms` используется для определения особого синтаксиса Egg. Он сопоставляет слова с функциями, интерпретирующими эти специальные формы. Пока он пуст. Давайте добавим несколько форм.

// include_code

[source,javascript]
----
specialForms["if"] = function(args, env) {
  if (args.length != 3)
    throw new SyntaxError("Неправильное количество аргументов для if");

  if (evaluate(args[0], env) !== false)
    return evaluate(args[1], env);
  else
    return evaluate(args[2], env);
};
----

(((conditional execution)))Конструкция `if` языка Egg ждёт три аргумента. Она вычисляет первый, и если результат не `false`, вычисляет второй. В ином случае вычисляет третий. Этот `if` больше похож на тернарный оператор `?:`. Это выражение, а не инструкция, и она выдаёт значение, а именно, результат второго или третьего выражения.

(((Boolean)))Egg отличается от JavaScript тем, как он обрабатывает условие `if`. Он не будет считать ноль или пустую строку за `false`.

(((short-circuit evaluation)))Причина, по которой `if` представлено в виде особой формы, а не обычной функции, в том, что все аргументы функций вычисляются перед вызовом, а `if` должен интерпретировать только _один_ из двух аргументов – второй или третий, в зависимости от значения первого.

Форма для `while` схожая.

// include_code

[source,javascript]
----
specialForms["while"] = function(args, env) {
  if (args.length != 2)
    throw new SyntaxError("Неправильное количество аргументов для while");

  while (evaluate(args[0], env) !== false)
    evaluate(args[1], env);

  // Поскольку undefined не задано в Egg,
  // за отсутствием осмысленного результата возвращаем false.
  return false;
};
----

Ещё одна основная часть языка – `do`, выполняющий все аргументы сверху вниз. Его значение – это значение, выдаваемое последним аргументом.

// include_code

[source,javascript]
----
specialForms["do"] = function(args, env) {
  var value = false;
  args.forEach(function(arg) {
    value = evaluate(arg, env);
  });
  return value;
};
----

(((= operator)))Чтобы создавать ((переменные)) и давать им значения, мы создаём форму `define`. Она ожидает `word` в качестве первого аргумента, и выражение, производящее значение, которое надо присвоить этому слову в качестве второго. Как и всё, `define` является выражением, поэтому оно должно возвращать значение. Пусть оно возвращает присвоенное значение (прям как оператор `=` в JavaScript).

// include_code

[source,javascript]
----
specialForms["define"] = function(args, env) {
  if (args.length != 2 || args[0].type != "word")
    throw new SyntaxError("Неправильное использование define");
  var value = evaluate(args[1], env);
  env[args[0].name] = value;
  return value;
};
----

== Окружение ==

(((Egg language)))(((evaluate function)))((Окружение)), принимаемое интерпретатором — это объект со свойствами, чьи имена соответствуют именам переменных, а значения – значениям этих ((переменных)). Давайте определим объект окружения, представляющий ((глобальную область видимости)).

Для использования конструкции `if` мы должны создать ((булевские)) значения. Так как их всего два, особый синтаксис для них не нужен. Мы просто делаем две переменные со значениями `true` и `false`.

// include_code

[source,javascript]
----
var topEnv = Object.create(null);

topEnv["true"] = true;
topEnv["false"] = false;
----

Теперь мы можем вычислить простое выражение, меняющее булевское значение на обратное.

[source,javascript]
----
var prog = parse("if(true, false, true)");
console.log(evaluate(prog, topEnv));
// → false
----

(((arithmetic)))(((Function constructor)))Для поддержки простых ((арифметических)) ((операторов)) и ((сравнения)) мы добавим несколько функций в ((окружение)). Для упрощения кода мы будем использовать `new Function` для создания набора функций-операторов в цикле, а не определять их все по отдельности.

// include_code

[source,javascript]
----
["+", "-", "*", "/", "==", "<", ">"].forEach(function(op) {
  topEnv[op] = new Function("a, b", "return a " + op + " b;");
});
----

Также пригодится способ ((вывод))а значений, так что мы обернём `console.log` в функцию и назовём её `print`.

// include_code

[source,javascript]
----
topEnv["print"] = function(value) {
  console.log(value);
  return value;
};
----

(((parsing)))(((run function)))Это даёт нам достаточно элементарных инструментов для написания простых программ. Следующая функция `run` даёт удобный способ записи и запуска. Она создаёт свежее окружение, парсит и разбирает строчки, которые мы ей передаём, так, как будто они являются одной программой.

// include_code

[source,javascript]
----
function run() {
  var env = Object.create(topEnv);
  var program = Array.prototype.slice
    .call(arguments, 0).join("\n");
  return evaluate(parse(program), env);
}
----

(((join method)))(((call method)))Использование `Array.prototype.slice.call` – уловка для превращения ((объекта, похожего на массив)), такого как `arguments`, в настоящий массив, чтобы мы могли применить к нему `join`. Она принимает все аргументы, переданные в `run`, и считает, что все они – строчки программы.

[source,javascript]
----
run("do(define(total, 0),",
    "   define(count, 1),",
    "   while(<(count, 11),",
    "         do(define(total, +(total, count)),",
    "            define(count, +(count, 1)))),",
    "   print(total))");
// → 55
----

(((summing example)))(((Egg language)))Эту программу мы видели уже несколько раз – она подсчитывает сумму чисел от 1 до 10 на языке Egg. Она уродливее эквивалентной программы на JavaScript, но не так уж и плоха для языка, заданного менее чем 150 ((строчками кода)).

[[egg_fun]]
== Функции ==

(((function)))(((Egg language)))Язык программирования без функций – плохой язык.

К счастью, несложно добавить конструкцию `fun`, которая расценивает последний аргумент как тело функции, а все предыдущие – имена аргументов функции.
Fortunately, it is not hard to add a `fun` construct, which treats its last argument as the function's body and treats all the arguments before that as the names of the function's arguments.

// include_code

[source,javascript]
----
specialForms["fun"] = function(args, env) {
  if (!args.length)
    throw new SyntaxError("Функции нужно тело");
  function name(expr) {
    if (expr.type != "word")
      throw new SyntaxError("Имена аргументов должны быть типа word");
    return expr.name;
  }
  var argNames = args.slice(0, args.length - 1).map(name);
  var body = args[args.length - 1];

  return function() {
    if (arguments.length != argNames.length)
      throw new TypeError("Неверное количество аргументов");
    var localEnv = Object.create(env);
    for (var i = 0; i < arguments.length; i++)
      localEnv[argNames[i]] = arguments[i];
    return evaluate(body, localEnv);
  };
};
----

(((local scope)))(((Object.create function)))(((prototype)))У функций в Egg своё локальное окружение, как и в JavaScript. Мы используем `Object.create` для создания нового объекта, имеющего доступ к переменным во внешнем окружении (своего прототипа), но он также может содержать новые переменные, не меняя внешней области видимости.

(((power example)))(((evaluation)))(((interpretation)))Функция, созданная формой `fun`, создаёт своё локальное окружение и добавляет к нему переменные-аргументы. Затем она интерпретирует тело в этом окружении и возвращает результат.

// start_code

[source,javascript]
----
run("do(define(plusOne, fun(a, +(a, 1))),",
    "   print(plusOne(10)))");
// → 11

run("do(define(pow, fun(base, exp,",
    "     if(==(exp, 0),",
    "        1,",
    "        *(base, pow(base, -(exp, 1)))))),",
    "   print(pow(2, 10)))");
// → 1024
----

== Компиляция ==

(((interpretation)))(((compilation)))Мы с вами построили интерпретатор. Во время интерпретации он работает с представлением программы, созданным парсером.

(((efficiency)))(((performance)))_Компиляция_ – добавление ещё одного шага между разбором и запуском программы, которая превращает программу в нечто, что можно выполнять более эффективно, путём проделывания большинства работы заранее. К примеру, в хорошо организованных языках при каждом использовании ((переменной)) очевидно, к какой переменной обращаются, даже без запуска программы. Это можно использовать, чтобы не искать переменную по имени каждый раз, когда к ней обращаются, а напрямую вызывать её из какой-то заранее определённой области ((памяти)).

По традиции ((компиляция)) также превращает программу в ((машинный код)) – сырой формат, пригодный для исполнения процессором. Но каждый процесс превращения программы в другой вид, по сути, является компиляцией.

(((simplicity)))(((Function constructor)))(((transpilation)))Можно было бы создать другой ((интерпретатор)) Egg, который сначала превращает программу в программу на языке JavaScript, использует `new Function` для вызова компилятора JavaScript и возвращает результат. При правильной реализации Egg выполнялся бы очень быстро при относительно простой реализации.

Если вам это интересно, и вы хотите потратить на это время, я поощряю вас попробовать сделать такой компилятор в качестве упражнения.

== Мошенничество ==

(((Egg language)))Когда мы определяли `if` и `while`, вы могли заметить, что они представляли собой простые обёртки вокруг `if` и `while` в JavaScript. Значения в Egg – также обычные значения JavaScript.

Если вы сравните реализацию Egg, построенную на JavaScript, с объёмом работы, необходимой для создания языка программирования непосредственно на машинном языке, то разница будет огромной. Тем не менее, этот пример, надеюсь, даёт вам представление о работе ((языков программирования)).

И когда вам надо что-то сделать, смошенничать будет более эффективно, нежели делать всё с нуля самому. И хотя игрушечный язык ничем не лучше JavaScript, в некоторых ситуациях написание своего небольшого языка помогает сделать работу.

Такой язык не обязан напоминать обычный язык программирования. Если бы JavaScript не содержал регулярных выражений, вы могли бы написать свои парсер и интерпретатор для такого суб-языка.

(((artificial intelligence)))Или представьте, что вы строите гигантского робота-((динозавр))а и вам нужно запрограммировать его ((поведение)). JavaScript – не самый эффективный способ сделать это. Можно вместо этого выбрать язык примерно такого свойства:

----
behavior walk
  perform when
    destination ahead
  actions
    move left-foot
    move right-foot

behavior attack
  perform when
    Godzilla in-view
  actions
    fire laser-eyes
    launch arm-rockets
----

(((expressivity)))Обычно это называют _((языком для выбранной области))_ (_domain-specific language_) – язык, специально предназначенный для работы в узком направлении. Такой язык может быть более выразительным, чем язык общего назначения, потому что он разработан для выражения именно тех вещей, которые надо выразить в этой области – и больше ничего.

== Упражнения ==

=== Массивы ===

(((Egg language)))Добавьте поддержку ((массив))ов в Egg. Для этого добавьте три функции в основную область видимости: `array(...)` для создания массива, содержащего значения аргументов, `length(array)` для возврата длины массива и `element(array, n)` для возврата n-ного элемента.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Modify these definitions...

topEnv["array"] = "...";

topEnv["length"] = "...";

topEnv["element"] = "...";

run("do(define(sum, fun(array,",
    "     do(define(i, 0),",
    "        define(sum, 0),",
    "        while(<(i, length(array)),",
    "          do(define(sum, +(sum, element(array, i))),",
    "             define(i, +(i, 1)))),",
    "        sum))),",
    "   print(sum(array(1, 2, 3))))");
// → 6
----
endif::interactive_target[]

!!hint!!

The easiest way to do this is to represent Egg arrays
with JavaScript arrays.

(((slice method)))The values added to the top environment must be
functions. `Array.prototype.slice` can be used to convert an
`arguments` array-like object into a regular array.

!!hint!!

=== Замыкания ===

(((closure)))(((function,scope)))Способ определения `fun` позволяет функциям в Egg “замыкаться” вокруг окружения, и использовать локальные переменные в теле функции, которые видны во время определения, точно как в функциях JavaScript.

Следующая программа иллюстрирует это: функция `f` возвращает функцию, добавляющую её аргумент к аргументу `f`, то есть, ей нужен доступ к локальной ((области видимости)) внутри `f` для использования переменной `a`.

[source,javascript]
----
run("do(define(f, fun(a, fun(b, +(a, b)))),",
    "   print(f(4)(5)))");
// → 9
----

Объясните, используя определение формы `fun`, какой механизм позволяет этой конструкции работать.

!!hint!!

(((closure)))Again, we are riding along on a JavaScript mechanism to
get the equivalent feature in Egg. Special forms are passed the local
environment in which they are evaluated so that they can evaluate
their subforms in that environment. The function returned by `fun`
closes over the `env` argument given to its enclosing function and
uses that to create the function's local ((environment)) when it is
called.

(((compilation)))This means that the ((prototype)) of the local
environment will be the environment in which the function was created,
which makes it possible to access variables in that environment from
the function. This is all there is to implementing closure (though to
compile it in a way that is actually efficient, you'd need to do some
more work).

!!hint!!

=== Комментарии ===

(((hash character)))(((Egg language)))Хорошо было бы иметь ((комментарии)) в Egg. К примеру, мы могли бы игнорировать оставшуюся часть строки, встречая символ `#` – так, как это происходит с `//` в JS.

(((skipSpace function)))Большие изменения в парсере делать не придётся. Мы просто поменяем `skipSpace`, чтобы она пропускала комментарии, будто они являются ((пробел))ами – и во всех местах, где вызывается `skipSpace`, комментарии тоже будут пропущены. Внесите это изменение.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Поменяйте старую функцию
function skipSpace(string) {
  var first = string.search(/\S/);
  if (first == -1) return "";
  return string.slice(first);
}

console.log(parse("# hello\nx"));
// → {type: "word", name: "x"}

console.log(parse("a # one\n   # two\n()"));
// → {type: "apply",
//    operator: {type: "word", name: "a"},
//    args: []}
----
endif::interactive_target[]

!!hint!!

(((comment)))Make sure your solution handles multiple comments in a
row, with potentially ((whitespace)) between or after them.

A ((regular expression)) is probably the easiest way to solve this.
Write something that matches “whitespace or a comment, zero or more
times”. Use the `exec` or `match` method and look at the length of
the first element in the returned array (the whole match) to find out
how many characters to slice off.

!!hint!!

=== Чиним область видимости ===

(((variable,definition)))(((assignment)))Сейчас мы можем присвоить ((переменной)) значение только через `define`. Эта конструкция работает как при присвоении старым переменным, так и при создании новых.

(((local variable)))Эта ((неоднозначность)) приводит к проблемам. Если вы пытаетесь присвоить новое значение нелокальной переменной, вместо этого вы определяете локальную с таким же именем. (Некоторые языки так и делают, но мне это всегда казалось дурацким способом работы с ((областью видимости))).

(((ReferenceError type)))Добавьте форму `set`, схожую с `define`, которая присваивает переменной новое значение, обновляя переменную во внешней области видимости, если она не задана в локальной. Если переменная вообще не задана, швыряйте `ReferenceError` (ещё один стандартный тип ошибки).

(((hasOwnProperty method)))(((prototype)))(((getPrototypeOf function)))Техника представления областей видимости в виде простых объектов, до сего момента бывшая удобной, теперь будет вам мешать. Вам может понадобиться функция `Object.getPrototypeOf`, возвращающая прототип объекта. Также помните, что область видимости не наследуется от `Object.prototype`, поэтому если вам надо вызвать на них `hasOwnProperty`, придётся использовать такую неуклюжую конструкцию:

// test: no

[source,javascript]
----
Object.prototype.hasOwnProperty.call(scope, name);
----

Это получает метод `hasOwnProperty` прототипа `Object` и затем вызывает его на объекте `scope`.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
specialForms["set"] = function(args, env) {
  // Ваш код.
};

run("do(define(x, 4),",
    "   define(setx, fun(val, set(x, val))),",
    "   setx(50),",
    "   print(x))");
// → 50
run("set(quux, true)");
// → Ошибка вида ReferenceError
----
endif::interactive_target[]

!!hint!!

(((variable,definition)))(((assignment)))(((getPrototypeOf
function)))(((hasOwnProperty method)))You will have to loop through
one ((scope)) at a time, using `Object.getPrototypeOf` to go the next
outer scope. For each scope, use `hasOwnProperty` to find out whether the
variable, indicated by the `name` property of the first argument to
`set`, exists in that scope. If it does, set it to the result of
evaluating the second argument to `set` and then return that value.

(((global scope)))(((run-time error)))If the outermost scope is
reached (`Object.getPrototypeOf` returns null) and we haven't found
the variable yet, it doesn't exist, and an error should be thrown.

!!hint!!
