:chap_num: 20
:prev_link: 19_paint
:next_link: 21_skillsharing
:code_links: ["code/file_server.js", "code/file_server_promises.js"]

= Node.js =

[chapterquote="true"]
[quote, Мастер Юан-Ма, Книга программирования]
____
Ученик спросил: «Программисты встарь использовали только простые компьютеры и программировали без языков, но они делали прекрасные программы. Почему мы используем сложные компьютеры и языки программирования?». Фу-Тзу ответил: «Строители встарь использовали только палки и глину, но они делали прекрасные хижины».
____

(((command line)))(((Yuan-Ma)))(((Book of Programming)))На текущий момент вы учили язык JavaScript и использовали его в единственном окружении: в браузере. В этой и link:21_skillsharing.html#skillsharing[следующей главе] мы кратко представим вам ((Node.js)), программу, которая позволяет применять навыки JavaScript вне браузера. С ней вы можете написать всё, от утилит командной строки до динамических HTTP ((сервер))ов.

Эти главы посвящены обучению важным идеям, составляющим Node.js и предназначены для передачи вам достаточного количества информации, чтобы вы могли писать полезные программы в этой среде. Они не пытаются быть всеобъемлющими справочниками по Node.

ifdef::interactive_target[]

Код из предыдущих глав вы могли писать и исполнять прямо в браузере, но код из этой главы написан для Node и в браузере работать не будет.

endif::interactive_target[]

Если вы хотите сразу запускать код из этой главы, начните с установки Node с сайта http://nodejs.org[_nodejs.org_] для вашей операционки. Также на этом сайте вы найдёте ((документацию)) по Node и его встроенным ((модулям)).

== Вступление ==

(((responsiveness)))(((input)))Одна из наиболее сложных проблем при написании систем, общающихся по ((сети)) – обработка ввода и ((вывод))а. Чтение и запись данных в сеть и из сети, на ((диск)), и другие устройства. Перемещение данных требует времени, и грамотное ((планирование)) этих действий может сильно повлиять на время отклика системы для пользователя или сетевых запросов.

В традиционном методе обработки ввода и вывода принято, что функция, к примеру, `readFile`, начинает читать файл и прекращает работать только когда файл полностью прочитан. Это называется _((синхронным вводом-выводом))_ (_((synchronous I/O)))_, I/O означает input/output).

(((asynchronous I/O)))(((asynchronous programming)))(((callback function)))Node был задуман с целью облегчить и упростить использование _асинхронного_ I/O. Мы уже встречались с асинхронными интерфейсами, такими, как объект браузера `XMLHttpRequest`, обсуждавшийся в link:17_http.html#xmlhttprequest[главе 17]. Такой интерфейс позволяет скрипту продолжать работу, пока интерфейс делает свою, и вызывает функцию обратного вызова по окончанию работы. Таким образом в Node работает весь I/O.

(((programming language)))(((Node.js)))(((standard)))JavaScript легко вписывается в систему вроде Node. Это один из немногих языков, в которые не встроена система I/O. Поэтому JavaScript легко встраивается в довольно эксцентричный подход к I/O в Node и в результате не порождает две разных системы ввода и вывода. В 2009 году при разработке Node люди уже использовали I/O в браузере, основанный на обратных вызовах, поэтому ((сообщество)) вокруг языка было привычно к ((асинхронному стилю программирования)).

== Асинхронность ==

Попробую проиллюстрировать разницу в синхронном и асинхронном подходах в I/O на небольшом примере, где программа должна получить два ресурса из интернета, и затем сделать что-то с этими данными.

(((synchronous I/O)))В синхронном окружении очевидным способом решения задачи будет сделать запросы последовательно. У этого метода есть минус – второй запрос начнётся только после окончания первого. Общее время будет не меньше, чем сумма времени на обработку двух запросов. Это неэффективное использование компьютера, который большую часть времени будет простаивать, пока происходит передача данных по ((сети)).

(((parallelism)))Решение проблемы в синхронной системе – запуск дополнительных ((поток))ов контроля исполнения программы (в link:14_event.html#timeline[главе 14] мы их уже обсуждали). Второй поток может запустить второй запрос, и затем оба потока будут ждать возврата результата, после чего они заново будут синхронизированы для сведения работы в один результат.

(((CPU)))(((blocking)))(((synchronous I/O)))(((asynchronous I/O)))(((timeline)))(((callback function)))На диаграмме жирные линии обозначают время нормальной работы программы, а тонкие – время ожидания I/O. В синхронной модели время, затраченное на I/O, _входит_ во временной график каждого из потоков. В асинхронной, запуск действия по I/O приводит к _разветвлению_ временной линии. Поток, запустивший I/O, продолжает выполнение, а I/O выполняется параллельно ему, по окончанию работы делая обратный вызов функции.

image::img/control-io.svg[alt="Control flow for synchronous and asynchronous I/O",width="8cm"]

(((control flow)))(((asynchronous programming)))Ещё один способ выразить эту разницу: в синхронной модели ожидание окончания I/O _неявное_, а в асинхронной – _явное_, и находится под нашим непосредственным контролем. Но асинхронность работает в обе стороны. С её помощью выражать программы, не работающие по принципу прямой линии, проще, но выражать прямолинейные программы становится сложнее.

(((verbosity)))В link:17_http.html#promises[главе 17] я уже касался того факта, что обратные вызовы привносят кучу шума и делают программу менее упорядоченной. Является ли такой подход в общем хорошей идеей – спорный вопрос. В любом случае, требуется время, чтобы привыкнуть к нему.

(((asynchronous programming)))(((parallelism)))Но для системы, основанной на JavaScript, я бы сказал, что использование асинхронности с обратными вызовами имеет смысл. Одна из сильных сторон JavaScript – простота, и попытки добавить в программу несколько ((поток))ов привели бы к сильному усложнению. Хотя обратные вызовы не делают _код_ простым, их _идея_ очень проста и в то же время достаточно сильна для того, чтобы писать высокопроизводительные веб-серверы.

== Команда node ==

(((node program)))Когда в вашей системе установлен ((Node.js)), у вас появляется программа под названием `node`, которая запускает файлы JavaScript. Допустим, у вас есть файл `hello.js` со следующим кодом:

[source,javascript]
----
var message = "Hello world";
console.log(message);
----

Вы можете выполнить свою программу из ((командной строки)):

----
$ node hello.js
Hello world
----

(((console.log)))Метод `console.log` в Node действует так же, как в браузере. Выводит кусок текста. Но в Node текст выводится на ((стандартный вывод)), а не в ((консоль JavaScript)) в браузере.

(((node program)))(((read-eval-print loop)))Если запустить `node` без файла, он выдаст вам строку запроса, в которой можно писать код на JavaScript и получать результат.

----
$ node
> 1 + 1
2
> [-1, -2, -3].map(Math.abs)
[1, 2, 3]
> process.exit(0)
$
----

(((process object)))(((global scope)))(((variable,global)))(((exit method)))(((status code)))Переменная `process`, так же как и `console`, доступна в Node глобально. Она обеспечивает несколько способов для инспектирования и манипулирования программой. Метод `exit` заканчивает процесс, и ему можно передать код статуса окончания программы, который сообщает программе, запустившей `node` (в данном случае, оболочке командной строки), завершилась ли программа удачно (нулевой код) или с ошибкой (любое другое число).

(((command line)))(((argv property)))Для доступа к аргументам командной строки, переданным программе, можно читать массив строк `process.argv`. В него также включены имя команды `node` и имя вашего скрипта, поэтому список аргументов начинается с индекса 2. Если файл `showargv.js` содержит только инструкцию `console.log(process.argv)`, его можно запустить так:

----
$ node showargv.js one --and two
["node", "/home/marijn/showargv.js", "one", "--and", "two"]
----

(((variable,global)))Все ((стандарт))ные глобальные переменные JavaScript — `Array`, `Math`, `JSON`, также есть в окружении Node. Но там отсутствует функционал, связанный с работой браузера, например `document` или `alert`.

(((global object)))(((global scope)))(((window)))Объект глобальной области видимости, который в браузере называется `window`, в Node имеет более осмысленное название `global`.

== Модули ==

(((Node.js)))(((global scope)))(((module loader)))Кроме нескольких упомянутых переменных, вроде `console` и `process`, Node держит мало функционала в глобальной области видимости. Для доступа к остальным встроенным возможностям вам надо обращаться к системе модулей.

(((library)))(((require function)))Система ((CommonJS)), основанная на функции `require`, была описана в link:10_modules.html#commonjs[главе 10]. Такая система встроена в Node и используется для загрузки всего, от встроенных ((модулей)) и скачанных библиотек до файлов, являющихся частями вашей программы.

(((path,file system)))(((relative path)))(((resolution)))При вызове `require` Node нужно преобразовать заданную строку в имя ((файл))а. Пути, начинающиеся с `"/"`, `"./"` или `"../"`, преобразуются в пути относительно текущего. При этом `"./"` означает текущую директорию, `"../"` – директорию выше, а `"/"` – корневую директорию файловой системы. Если вы запросите `"./world/world"` из файла `/home/marijn/elife/run.js`, Node попробует загрузить файл `/home/marijn/elife/world/world.js`. Расширение `.js` можно опускать.

(((node_modules directory)))Когда в `require` передаётся строка, которая не выглядит как относительный или абсолютный путь, то предполагается, что это либо встроенный ((модуль)), или модуль, установленный в директории `node_modules`. К примеру, `require("fs")` выдаст вам встроенный модуль для работы с файловой системой, а `require("elife")` попробует загрузить библиотеку из `node_modules/elife/`. Типичный метод установки библиотек – при помощи ((NPM)), к которому я вернусь позже.

(((require function)))(((Node.js)))(((garble example)))Для демонстрации использования `require` давайте сделаем простой проект из двух файлов. Первый назовём `main.js`, и в нём будет определён скрипт, вызываемый из ((командной строки)), предназначенный для искажения строк.

[source,javascript]
----
var garble = require("./garble");

// По индексу 2 содержится первый аргумент программы из командной строки
var argument = process.argv[2];

console.log(garble(argument));
----

(((reuse)))Файл `garble.js` определяет библиотеку искажения строк, которая может использоваться как заданной ранее программой для командной строки, так и другими скриптами, которым нужен прямой доступ к функции `garble`.

[source,javascript]
----
module.exports = function(string) {
  return string.split("").map(function(ch) {
    return String.fromCharCode(ch.charCodeAt(0) + 5);
  }).join("");
};
----

(((exports object)))(((CommonJS)))Замена `module.exports` вместо добавления к нему свойств позволяет нам экспортировать определённое значение из модуля. В данном случае, результатом запроса нашего модуля получится сама функция искажения.

(((Unicode)))(((split method)))(((map method)))(((join method)))Функция разбивает строку на символы, используя `split` с пустой строкой, и затем заменяет все символы на другие, чьи коды на 5 единиц больше. Затем она соединяет результат обратно в строку.

Теперь мы можем вызвать наш инструмент:

----
$ node main.js JavaScript
Of{fXhwnuy
----

== Установка через NPM ==

(((NPM)))(((Node.js)))(((npm program)))(((library)))NPM, вскользь упомянутый в link:10_modules.html#modules_npm[главе 10], это онлайн-хранилище ((модулей)) JavaScript, многие из которых написаны специально для Node. Когда вы ставите Node на компьютер, вы получаете программу `npm`, которая даёт удобный интерфейс к этому хранилищу.

(((figlet module)))К примеру, один из модулей NPM зовётся `figlet`, и он преобразует текст в __((ASCII art))__, рисунки, составленные из текстовых символов. Вот как его ((установить)):

----
$ npm install figlet
npm GET https://registry.npmjs.org/figlet
npm 200 https://registry.npmjs.org/figlet
npm GET https://registry.npmjs.org/figlet/-/figlet-1.0.9.tgz
npm 200 https://registry.npmjs.org/figlet/-/figlet-1.0.9.tgz
figlet@1.0.9 node_modules/figlet
$ node
> var figlet = require("figlet");
> figlet.text("Hello world!", function(error, data) {
    if (error)
      console.error(error);
    else
      console.log(data);
  });
  _   _      _ _                            _     _ _ 
 | | | | ___| | | ___   __      _____  _ __| | __| | |
 | |_| |/ _ \ | |/ _ \  \ \ /\ / / _ \| '__| |/ _` | |
 |  _  |  __/ | | (_) |  \ V  V / (_) | |  | | (_| |_|
 |_| |_|\___|_|_|\___/    \_/\_/ \___/|_|  |_|\__,_(_)
----

(((require function)))(((node_modules directory)))(((npm program)))После запуска `npm install` ((NPM)) создаст директорию `node_modules`. Внутри неё будет директория `figlet`, содержащая ((библиотеку)). Когда мы запускаем `node` и вызываем `require("figlet")`, библиотека загружается и мы можем вызвать её метод `text`, чтобы вывести большие красивые буквы.

(((error handling)))(((return value)))Что интересно, вместо простого возврата строки, в которой содержатся большие буквы, `figlet.text` принимает ((функцию для обратного вызова)), которой он передаёт результат. Также он передаёт туда ещё один аргумент, `error`, который в случае ошибки будет содержать объект `error`, а в случае успеха – `null`.

(((file system)))(((asynchronous programming)))(((Node.js)))Такой принцип работы принят в Node. Для создания букв `figlet` должен прочесть файл с диска, содержащий буквы. Чтение файла – асинхронная операция в Node, поэтому `figlet.text` не может вернуть результат немедленно. Асинхронность заразительна – любая функция, вызывающая асинхронную, сама становится асинхронной.

(((dependency)))(((publishing)))(((package.json file)))(((npm program)))((NPM)) – это больше, чем просто `npm install`. Он читает файлы `package.json`, содержащие информацию в формате ((JSON)) про программу или библиотеку, в частности, от каких библиотек она зависит. Выполнение `npm install` в директории, содержащей такой файл, автоматически приводит к установке всех зависимостей, и в свою очередь _их_ зависимостей. Также инструмент `npm` используется для размещения библиотек в онлайновом хранилище NPM, чтобы другие люди могли их находить, скачивать и использовать.

(((library)))Больше мы не будем углубляться в детали использования ((NPM)). Обращайтесь на http://npmjs.org[_npmjs.org_] за документацией и простым поиском библиотек.

== Модуль file system ==

(((directory)))(((fs module)))(((Node.js)))Один из самых востребованных встроенных модулей Node – модуль `"fs"`, что означает _((файловая система))_. Модуль обеспечивает функционал для работы с ((файл))ами и директориями.

(((readFile function)))(((callback function)))К примеру, есть функция `readFile`, читающая файл и делающая обратный вызов с содержимым файла.

[source,javascript]
----
var fs = require("fs");
fs.readFile("file.txt", "utf8", function(error, text) {
  if (error)
    throw error;
  console.log("А в файле том было:", text);
});
----

(((Buffer type)))Второй аргумент `readFile` задаёт _((кодировку символов))_, в которой нужно преобразовывать содержимое файла в строку. ((Текст)) можно преобразовать в ((двоичные данные)) разными способами, но самым новым из них является ((UTF-8)). Если у вас нет оснований полагать, что в файле содержится текст в другой кодировке, можно смело передавать параметр `"utf8"`. Если вы не задали кодировку, Node выдаст вам данные в двоичной кодировке в виде объекта `Buffer`, а не строки. Это ((массивоподобный объект)), содержащий байты из файла.

[source,javascript]
----
var fs = require("fs");
fs.readFile("file.txt", function(error, buffer) {
  if (error)
    throw error;
  console.log("В файле было", buffer.length, "байт.",
              "Первый байт:", buffer[0]);
});
----

(((writeFile function)))(((file system)))Схожая функция, `writeFile`, используется для записи ((файл))а на диск.

[source,javascript]
----
var fs = require("fs");
fs.writeFile("graffiti.txt", "Здесь был Node", function(err) {
  if (err)
    console.log("Ничего не вышло, и вот почему:", err);
  else
    console.log("Запись успешна. Все свободны.");
});
----

(((Buffer type)))(((character encoding)))Здесь задавать кодировку не нужно, потому что `writeFile` полагает, что если ей на запись дали строку, а не объект `Buffer`, то её надо выводить в виде текста с кодировкой по умолчанию ((UTF-8)).

(((fs module)))(((readdir function)))(((stat function)))(((rename function)))(((unlink function)))Модуль `"fs"` содержит много полезного: функция `readdir` возвращает список ((файл))ов ((директории)) в виде массива строк, `stat` вернёт информацию о файле, `rename` переименовывает файл, `unlink` удаляет, и т.п. Смотрите документацию на http://nodejs.org[_nodejs.org_].

(((synchronous I/O)))(((fs module)))(((readFileSync function)))Многие функции `"fs"` имеют как синхронный, так и асинхронный вариант. К примеру, есть синхронный вариант функции `readFile` под названием `readFileSync`.

[source,javascript]
----
var fs = require("fs");
console.log(fs.readFileSync("file.txt", "utf8"));
----

(((synchronous I/O)))(((optimization)))(((performance)))(((blocking)))Синхронные функции использовать проще и полезнее для простых скриптов, где дополнительная скорость асинхронного метода не важна. Но заметьте – на время выполнения синхронного действия ваша программа полностью останавливается. Если ей надо отвечать на ввод пользователя или другим программам по сети, затыки ожидания синхронного I/O приводят к раздражающим задержкам.

== Модуль HTTP ==

(((Node.js)))(((http module)))Ещё один центральный модуль Node — `"http"`. Он даёт функционал для создания ((HTTP)) серверов и HTTP ((запрос))ов.

(((listening (TCP))))(((listen method)))(((createServer function)))Вот всё, что нужно для запуска простейшего HTTP сервера:

[source,javascript]
----
var http = require("http");
var server = http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("<h1>Привет!</h1><p>Вы запросили <code>" +
                 request.url + "</code></p>");
  response.end();
});
server.listen(8000);
----

(((port)))(((localhost)))Запустив скрипт на своей машины, вы можете направить браузер по адресу http://localhost:8000/hello[_http://localhost:8000/hello_], таким образом создав запрос к серверу. Он ответит небольшой HTML-страницей.

(((createServer function)))(((HTTP)))Функция, передаваемая как аргумент к `createServer`, вызывается при каждой попытке соединения с сервером. Переменные `request` и `response` – объекты, представляющие входные и выходные данные. Первый содержит информацию по ((запрос))у, например свойство `url` содержит URL запроса.

(((200 (HTTP status code))))(((Content-Type header)))(((writeHead method)))Чтобы отправить что-то назад, используются методы объекта `response`. Первый, `writeHead`, пишет ((заголовки)) ((ответ))а (см. link:17_http.html#headers[главу 17]). Вы даёте ему код статуса (в этом случае 200 для “OK”) и объект, содержащий значения заголовков. Здесь мы сообщаем клиенту, что он должен ждать документ HTML.

(((writable stream)))(((body (HTTP))))(((stream)))(((write method)))(((end method)))Затем идёт тело ответа (сам документ), отправляемое через `response.write`. Этот метод можно вызывать несколько раз, если хотите отправлять ответ по кускам, к примеру, передавая потоковые данные по мере их поступления. Наконец, `response.end` сигнализирует конец ответа.

(((listen method)))Вызов `server.listen` заставляет ((сервер)) слушать запросы на ((порт))у 8000. Поэтому вам надо в браузере заходить на _localhost:8000_, а не просто на _localhost_ (где портом по умолчанию будет 80).

(((Node.js)))(((kill)))Для остановки такого скрипта Node, который не завершается автоматически, потому что ожидает следующих событий (в данном случае, соединений), надо нажать Ctrl-C.

Настоящий веб-((сервер)) делает гораздо больше того, что описано в примере. Он смотрит на ((метод)) запроса (свойство `method`), чтобы понять, какое действие пытается выполнить клиент, и на ((URL)) запроса, чтобы понять, на каком ресурсе это действие должно выполняться. link:20_node.html#file_server[Далее в этой главе] вы увидите более продвинутую версию сервера.

(((http module)))(((request function)))Чтобы сделать _((HTTP-клиент))_, мы можем использовать функцию `request` модуля `"http"`.

[source,javascript]
----
var http = require("http");
var request = http.request({
  hostname: "eloquentjavascript.net",
  path: "/20_node.html",
  method: "GET",
  headers: {Accept: "text/html"}
}, function(response) {
  console.log("Сервис ответил с кодом",
              response.statusCode);
});
request.end();
----

(((Node.js)))(((callback function)))(((readable stream)))Первый аргумент `request` настраивает запрос, объясняя Node, с каким сервером будем общаться, какой путь будет у запроса, какой метод использовать, и т.д. Второй – функция, которую надо будет вызвать по окончанию запроса. Ей передаётся объект `response`, в котором содержится вся информация по ответу – к примеру, код статуса.

(((GET method)))(((write method)))(((end method)))(((writable stream)))(((request function)))Как и объект `response` сервера, объект, возвращаемый `request`, позволяет передавать ((поток)) данных методом `write` и заканчивать ((запрос)) методом `end`. В примере не используется `write`, потому что запросы `GET` не должны содержать данных в теле.

(((HTTPS)))(((https module)))(((request function)))Для запросов на безопасные URL (по протоколу HTTPS), Node предлагает модуль `"https"`, в котором есть своя функция запроса `request`, схожая с `http.request`.

== Потоки ==

(((Node.js)))(((write method)))(((end method)))(((Buffer type)))(((stream)))(((writable stream)))Мы видели два примера потоков в HTTP примерах – объект ответа, в который сервер может вести запись, и объект запроса, который возвращается из `http.request`.

(((callback function)))(((asynchronous programming)))Потоки с возможностью записи – популярная концепция в интерфейсах Node. У всех потоков есть метод `write`, которому можно передать строку или объект `Buffer`. Метод `end` закрывает поток, а при наличии аргумента, выведет перед закрытием кусочек данных. Обоим методам можно задать функцию обратного вызова через дополнительный аргумент, которую они вызовут по окончанию записи или закрытию потока.

(((createWriteStream function)))(((writeFile function)))Возможно создать поток, показывающий на ((файл)), при помощи функции `fs.createWriteStream`. Затем можно использовать метод `write` для записи в файл по кусочкам, а не целиком, как в `fs.writeFile`.

(((createServer function)))(((request function)))(((event handling)))(((readable stream)))((Поток))и с возможностью чтения будут чуть сложнее. Как переменная `request`, переданная функции для обратного вызова на HTTP-сервер, так и переменная `response`, переданная на HTTP-клиент, являются потоками с возможностью чтения. (Сервер читает запрос и потом пишет ответы, а клиент сперва пишет запрос и затем читает ответ). Чтение из потока осуществляется через обработчики событий, а не через методы.

(((on method)))(((addEventListener method)))У объектов, создающих события в Node, есть метод `on`, схожий с методом браузера `addEventListener`. Вы даёте ему имя события и функцию, и он регистрирует эту функцию, чтоб её вызвали сразу, когда произойдёт событие.

(((createReadStream function)))(((data event)))(((end event)))(((readable stream)))У ((поток))ов с возможностью чтения есть события `"data"` и `"end"`. Первое происходит при поступлении данных, второе – по окончанию. Эта модель подходит к “потоковым” данным, которые можно сразу обработать, даже если получен не весь документ. Файл можно прочесть в виде потока через `fs.createReadStream`.

(((upcasing server example)))(((capitalization)))(((toUpperCase method)))Следующий код создаёт ((сервер)), читающий тела запросов и отправляющий их в ответ потоком в виде текста из заглавных букв:

[source,javascript]
----
var http = require("http");
http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  request.on("data", function(chunk) {
    response.write(chunk.toString().toUpperCase());
  });
  request.on("end", function() {
    response.end();
  });
}).listen(8000);
----

(((Buffer type)))(((toString method)))Переменная `chunk`, передаваемая обработчику данных, будет бинарным `Buffer`, который можно преобразовать в строку, вызвав его метод `toString`, который декодирует его из кодировки по умолчанию (UTF-8).

Следующий код, будучи запущенным одновременно с сервером, отправит запрос на сервер и выведет полученный ответ:

// test: no

[source,javascript]
----
var http = require("http");
var request = http.request({
  hostname: "localhost",
  port: 8000,
  method: "POST"
}, function(response) {
  response.on("data", function(chunk) {
    process.stdout.write(chunk.toString());
  });
});
request.end("Hello server");
----

(((stdout property)))(((standard output)))(((writable stream)))(((console.log)))Пример пишет в `process.stdout` (стандартный вывод процесса, являющийся потоком с возможностью записи), а не в `console.log`. Мы не можем использовать `console.log`, так как он добавляет лишний перевод строки после каждого куска кода – это здесь не нужно.

[[file_server]]
== Простой файловый сервер ==

(((file server example)))(((Node.js)))Давайте скомбинируем наши новые знания о ((сервер))ах ((HTTP)) и работе с ((файловой системой)), и наведём мостик между ними: HTTP-сервер, предоставляющий ((удалённый доступ)) к файлам. У такого сервера много вариантов использования. Он позволяет веб-приложениям хранить и делиться данными, или может дать группе людей доступ к набору файлов.

(((path,URL)))(((GET method)))(((PUT method)))(((DELETE method)))Когда мы относимся к ((файл))ам, как к ((ресурс))ам HTTP, методы `GET`, `PUT` и `DELETE` можно использовать для чтения, записи и удаления файлов. Мы будем интерпретировать путь в запросе как путь к файлу.

(((path,file system)))(((relative path)))Нам не надо открывать доступ ко всей файловой системе, поэтому мы будем интерпретировать эти пути как заданные относительно корневого ((каталог))а, и это будет каталог запуска скрипта. Если я запущу сервер из `/home/marijn/public/` (или `C:\Users\marijn\public\` на Windows), то запрос на `/file.txt` должен указать на `/home/marijn/public/file.txt` (или `C:\Users\marijn\public\file.txt`).

(((file server example)))(((Node.js)))(((methods object)))Программу мы будем строить постепенно, используя объект `methods` для хранения функций, обрабатывающих разные методы HTTP.

// include_code >code/file_server.js

[source,javascript]
----
var http = require("http"), fs = require("fs");

var methods = Object.create(null);

http.createServer(function(request, response) {
  function respond(code, body, type) {
    if (!type) type = "text/plain";
    response.writeHead(code, {"Content-Type": type});
    if (body && body.pipe)
      body.pipe(response);
    else
      response.end(body);
  }
  if (request.method in methods)
    methods[request.method](urlToPath(request.url),
                            respond, request);
  else
    respond(405, "Method " + request.method +
            " not allowed.");
}).listen(8000);
----

(((405 (HTTP status code))))Этот код запустит сервер, возвращающий ошибки 405 – этот код используется для обозначения того, что запрошенный метод сервером не поддерживается.

(((end method)))(((Content-Type header)))(((response)))(((pipe method)))(((stream)))Функция `respond` передаётся функциям, обрабатывающим разные методы, и работает как обратный вызов для окончания запроса. Она принимает ((код статуса)) HTTP, тело, и, возможно, тип содержимого. Если переданное тело – ((поток с возможностью чтения)), у него будет метод `pipe`, который используется для передачи читаемого потока в ((записываемый)). Если нет – предполагается, что это либо `null` (тело пустое), или строка, и тогда она передаётся напрямую в метод ответа `end`.

(((path,URL)))(((urlToPath function)))(((url module)))(((parsing)))(((escaping,in URLs)))(((decodeURIComponent function)))Чтобы получить путь из ((URL)) в запросе, функция `urlToPath`, используя встроенный модуль Node `"url"`, разбирает URL. Она принимает имя пути, нечто вроде `/file.txt`, декодирует, чтобы убрать экранирующие коды `%20`, и вставляет в начале точку, чтобы получить путь относительно текущего каталога.

// include_code >code/file_server.js

[source,javascript]
----
function urlToPath(url) {
  var path = require("url").parse(url).pathname;
  return "." + decodeURIComponent(path);
}
----


(((security)))(((path,file system)))Вам кажется, что функция `urlToPath` небезопасна? Вы правы. Вернёмся к этому вопросу в упражнениях.

(((file server example)))(((Node.js)))(((GET method)))Мы устроим метод `GET` так, чтобы он возвращал список ((файл))ов при чтении ((директории)), и содержимое файла при чтении файла.

(((media type)))(((MIME type)))(((Content-Type header)))(((mime module)))Вопрос на засыпку – какой тип заголовка `Content-Type` мы должны возвращать, читая файл. Поскольку в файле может быть всё, что угодно, сервер не может просто вернуть один и тот же тип для всех. Но ((NPM)) с этим может помочь. Модуль `"mime"` (индикаторы типа содержимого файла вроде `text/plain` также называются _MIME types_) знает правильный тип для огромного количества ((расширений файлов)).

(((require function)))(((npm program)))Запустив следующую команду `npm` в директории, где живёт скрипт сервера, вы сможете использовать `require("mime")` для запросов к библиотеке типов:

----
$ npm install mime@1.4.0
npm http GET https://registry.npmjs.org/mime
npm http 304 https://registry.npmjs.org/mime
mime@1.4.0 node_modules/mime
----

(((404 (HTTP status code))))(((stat function)))Когда запрошенного файла не существует, правильным кодом ошибки для этого случая будет 404. Мы будем использовать `fs.stat` для получения информации по файлу, чтобы выяснить, есть ли такой ((файл)), и не ((директория)) ли это.

// include_code >code/file_server.js

[source,javascript]
----
methods.GET = function(path, respond) {
  fs.stat(path, function(error, stats) {
    if (error && error.code == "ENOENT")
      respond(404, "File not found");
    else if (error)
      respond(500, error.toString());
    else if (stats.isDirectory())
      fs.readdir(path, function(error, files) {
        if (error)
          respond(500, error.toString());
        else
          respond(200, files.join("\n"));
      });
    else
      respond(200, fs.createReadStream(path),
              require("mime").lookup(path));
  });
};
----

(((createReadStream function)))(((asynchronous programming)))(((error handling)))(((ENOENT (status code))))(((Error type)))(((inheritance)))Поскольку запросы к диску занимают время, `fs.stat` работает асинхронно. Когда файла не существует, `fs.stat` передаст объект `error` со значением `"ENOENT"` свойства `code` в функцию обратного вызова. Было бы здорово, если бы Node определил разные типы `Error` для разных ошибок, но такого нет. Вместо этого он выдаёт запутанные коды в стиле ((Unix)).

(((500 (HTTP status code))))(((error handling)))(((error response)))Все неожиданные ошибки мы будем выдавать с кодом 500, обозначающим, что на сервере проблема – в отличие от кодов, начинающихся на 4 (например, 404), говорящих о проблеме с запросом. В некоторых ситуациях это будет не совсем аккуратно, но для небольшой примерной программы этого будет достаточно.

(((Stats type)))(((stat function)))Объект `stats`, возвращаемый `fs.stat`, рассказывает нам о ((файл))е всё. Например, `size` – размер файла, `mtime` – ((дата модификации)). Здесь нам нужно узнать, ((директория)) это или обычный файл – это нам сообщит метод `isDirectory`.

(((readdir function)))Для чтения списка файлов в ((директории)) мы используем `fs.readdir`, и через ещё один обратный вызов, возвращаем его пользователю. Для обычных файлов мы создаём читаемый поток через `fs.createReadStream` и передаём его в ответ `respond`, вместе с типом содержимого, который модуль `"mime"` выдал для этого файла.

(((Node.js)))(((file server example)))(((DELETE method)))Код обработки `DELETE` будет проще.

// include_code >code/file_server.js

[source,javascript]
----
methods.DELETE = function(path, respond) {
  fs.stat(path, function(error, stats) {
    if (error && error.code == "ENOENT")
      respond(204);
    else if (error)
      respond(500, error.toString());
    else if (stats.isDirectory())
      fs.rmdir(path, respondErrorOrNothing(respond));
    else
      fs.unlink(path, respondErrorOrNothing(respond));
  });
};
----

(((idempotency)))(((error response)))Возможно, вам интересно, почему попытка удаления несуществующего файла возвращает статус 204 вместо ошибки. Можно сказать, что при попытке удалить несуществующий файл, так как файла там уже нет, то запрос уже исполнен. Стандарт ((HTTP)) поощряет людей делать _идемпотентные_ запросы – то есть такие, при которых многократный повтор одного и того же действия не приводит к разным результатам.

// include_code >code/file_server.js

[source,javascript]
----
function respondErrorOrNothing(respond) {
  return function(error) {
    if (error)
      respond(500, error.toString());
    else
      respond(204);
  };
}
----

(((204 (HTTP status code))))(((body (HTTP))))Когда ((ответ)) ((HTTP)) не содержит данных, можно использовать код статуса 204 (“no content”). Так как нам нужно обеспечить функции обратного вызова, которые либо сообщают об ошибке, или возвращают ответ 204 в разных ситуациях, я написал специальную функцию `respondErrorOrNothing`, которая создаёт такой обратный вызов.

(((file server example)))(((Node.js)))(((PUT method)))Вот обработчик запросов `PUT`:

// include_code >code/file_server.js

[source,javascript]
----
methods.PUT = function(path, respond, request) {
  var outStream = fs.createWriteStream(path);
  outStream.on("error", function(error) {
    respond(500, error.toString());
  });
  outStream.on("finish", function() {
    respond(204);
  });
  request.pipe(outStream);
};
----

(((overwriting)))(((204 (HTTP status code))))(((error event)))(((finish event)))(((createWriteStream function)))(((pipe method)))(((stream)))Здесь нам не нужно проверять существование файла – если он есть, мы его просто перезапишем. Опять мы используем `pipe` для передачи данных из читаемого потока в записываемый, в нашем случае – из запроса в файл. Если создать поток не удаётся, создаётся событие `"error"`, о чём мы сообщаем в ответе. Когда данные переданы успешно, `pipe` закроет оба потока, что приведёт к запуску события `"finish"` на записываемом потоке. А после этого мы можем отчитаться об успехе с кодом 204.

(((download)))(((file server example)))(((Node.js)))Полный скрипт сервера доступен на сайте http://eloquentjavascript.net/2nd_edition/code/file_server.js[_eloquentjavascript.net/2nd_edition/code/file_server.js_]. Его можно скачать и запустить через Node для запуска собственного файлового сервера. Конечно, его можно менять и дополнять для решения упражнений этой главы или экспериментов.

(((body (HTTP))))(((curl program)))Утилита командной строки `curl`, общедоступная на ((Unix))-системах, может использоваться для создания ((HTTP)) запросов. Следующий фрагмент тестирует наш сервер. Опция `-X` используется для задания ((метода)) запроса, а `-d` для включения тела запроса.

----
$ curl http://localhost:8000/file.txt
File not found
$ curl -X PUT -d hello http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
hello
$ curl -X DELETE http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
File not found
----

Первый запрос к `file.txt` завершается с ошибкой, поскольку файла ещё нет. Запрос `PUT` создаёт файл, и глядите-ка, – следующий запрос его успешно получает. После его удаления через `DELETE` файл снова отсутствует.

== Обработка ошибок ==

(((verbosity)))(((error handling)))В коде файлового сервера есть _шесть_ мест, где мы перенаправляем исключения, когда мы не знаем, как обрабатывать ошибки. Поскольку ((исключения)) не передаются автоматически в функции обратного вызова, но передаются им как аргументы, их надо каждый раз обрабатывать персонально. Это сводит на нет преимущество ((обработки исключений)), а именно, возможность централизованно обрабатывать ошибки.

(((Node.js)))(((stack trace)))(((throw keyword)))(((try keyword)))(((uncaught exception)))Что будет, когда что-то реально _выбросит_ исключение в системе? Мы не используем блоки `try`, поэтому оно будет передано на самый верх стека вызовов. В Node это приводит к прекращению выполнения программы и выводу информации об исключении (вместе со стеком трассировки) в стандартный поток вывода.

(((callback function)))Поэтому наш сервер будет падать при возникновении проблем в коде – в отличие от проблем с асинхронностью, которые будут переданы как аргументы в функции вызова. Если нам надо обрабатывать все исключения, возникающие при обработке запроса, чтобы мы точно отправили ответ, нам надо добавлять блоки `try/catch` в _каждом_ обратном вызове.

(((exception handling)))Это плохо. Много программ для Node написаны так, чтобы использовать как можно меньше работы с исключениями, подразумевая что в случае возникновения исключения программа не может его обработать, и поэтому надо падать.

(((denodeify function)))(((readFile function)))(((promise module)))(((error handling)))Ещё один подход – использование ((обещаний)), которые были описаны в link:17_http.html#promises[главе 17]. Они ловят исключения, выброшенные функциями обратного вызова и передают их как ошибки. В Node можно загрузить библиотеку `"promise"` и использовать её для обработки асинхронных вызовов. Немногие библиотеки Node интегрируют обещания, но обычно их довольно просто обернуть. Отличный модуль `"promise"` с ((NPM)) содержит функцию `denodeify`, которая берёт асинхронную функцию вроде `fs.readFile` и преобразовывает её в функцию, возвращающую обещание.

[source,javascript]
----
var Promise = require("promise");
var fs = require("fs");

var readFile = Promise.denodeify(fs.readFile);
readFile("file.txt", "utf8").then(function(content) {
  console.log("The file contained: " + content);
}, function(error) {
  console.log("Failed to read file: " + error);
});
----

(((error handling)))(((exception handling)))(((file server example)))Для сравнения, я написал ещё одну версию файлового сервера с использованием ((обещаний)), которую можно найти на http://eloquentjavascript.net/2nd_edition/code/file_server_promises.js[_eloquentjavascript.net/2nd_edition/code/file_server_promises.js_]. Она почище, потому что функции теперь могут _возвращать_ результаты, а не назначать обратные вызовы, и исключения передаются неявно.

(((programming style)))Приведу несколько строк оттуда, чтобы продемонстрировать разницу в стилях.

(((chaining)))(((fsp object)))Объект `fsp`, использующийся в коде, содержит варианты функций `fs` с обещаниями, обёрнутыми при помощи `Promise.denodeify`. Возвращаемый из обработчика метода объект, со свойствами `code` и `body`, становится окончательным результатом цепочки ((обещаний)), и он используется для определения того, какой ((ответ)) отправить клиенту.

// test: no

[source,javascript]
----
methods.GET = function(path) {
  return inspectPath(path).then(function(stats) {
    if (!stats) // Does not exist
      return {code: 404, body: "File not found"};
    else if (stats.isDirectory())
      return fsp.readdir(path).then(function(files) {
        return {code: 200, body: files.join("\n")};
      });
    else
      return {code: 200,
              type: require("mime").lookup(path),
              body: fs.createReadStream(path)};
  });
};

function inspectPath(path) {
  return fsp.stat(path).then(null, function(error) {
    if (error.code == "ENOENT") return null;
    else throw error;
  });
}
----

(((500 (HTTP status code))))(((stat function)))(((ENOENT (status code))))(((promise)))Функция `inspectPath` – простая обёртка вокруг `fs.stat`, обрабатывающая случай, когда файл не найден. В этом случае мы заменяем ошибку на успех, возвращающий `null`. Все остальные ошибки можно передавать. Когда обещание, возвращаемое из этих обработчиков, обламывается, сервер отвечает кодом 500.

== Итог ==

(((Node.js)))Node – отличная простая система, позволяющая запускать JavaScript вне браузера. Изначально она разрабатывалась для работы по сети, чтобы играть роль _узла_ в сети. Но она позволяет делать много всего, и если вы наслаждаетесь программированием на JavaScript, автоматизация ежедневных задач с Node работает отлично.

NPM предоставляет библиотеки для всего, что вам может прийти в голову (и даже для кое-чего, что вам не придёт в голову), и она позволяет скачивать и устанавливать их простой командой. Node также поставляется с набором встроенных модулей, включая `"fs"` для работы с файловой системой, и `"http"` для запуска HTTP серверов и создания HTTP запросов.

Весь ввод и вывод в Node делается асинхронно, если только вы не используете явно синхронный вариант функции, например `fs.readFileSync`. Вы предоставляете функции обратного вызова, а Node их вызывает в нужное время, когда операции I/O заканчивают работу.

== Упражнения ==

=== И снова согласование содержания ===

(((Accept header)))(((content negotiation (exercise))))В link:17_http.html#exercise_accept[главе 17] первое упражнение было посвящено созданию запросов к http://eloquentjavascript.net/author[_eloquentjavascript.net/author_], спрашивавших разные типы содержимого путём передачи разных заголовков `Accept`.

(((request function)))(((http module)))(((MIME type)))Сделайте это снова, используя функцию Node `http.request`. Запросите, по крайней мере, типы `text/plain`, `text/html` и `application/json`. Помните, что заголовки запроса можно передавать как объект в свойстве `headers`, первым аргументом `http.request`.

(((output)))Выведите содержимое каждого ответа.

!!hint!!

(((content negotiation (exercise))))(((end method)))(((request
function)))Don't forget to call the `end` method on the object
returned by `http.request` in order to actually fire off the request.

(((concatenation)))(((callback function)))(((readStreamAsString
function)))The ((response)) object passed to `http.request`’s callback
is a ((readable stream)). This means that it is not entirely trivial
to get the whole response body from it. The following utility
function reads a whole stream and calls a callback function with the
result, using the usual pattern of passing any errors it encounters as
the first argument to the callback:

[source,text/javascript]
----
function readStreamAsString(stream, callback) {
  var data = "";
  stream.on("data", function(chunk) {
    data += chunk.toString();
  });
  stream.on("end", function() {
    callback(null, data);
  });
  stream.on("error", function(error) {
    callback(error);
  });
}
----

!!hint!!

=== Устранение утечек ===

(((file server example)))(((leak)))Для упрощения удалённого доступа к файлам я оставил работать link:20_node.html#file_server[файловый сервер], разработанный в этой главе, у себя на комьпютере, в директории `/home/marijn/public`. Однажды я обнаружил, что кто-то получил доступ ко всем моим ((паролям)), которые я хранил в ((браузер))е.

Что случилось?

(((urlToPath function)))(((relative path)))Если вам это непонятно, вспомните функцию `urlToPath`, которая определялась так:

[source,javascript]
----
function urlToPath(url) {
  var path = require("url").parse(url).pathname;
  return "." + decodeURIComponent(path);
}
----

(((fs module)))Теперь вспомните, что пути, передаваемые в функцию `"fs"`, могут быть относительными. Они могут содержать путь `"../"` в верхний каталог. Что будет, если клиент отправит запросы на URL вроде следующих?

----
http://myhostname:8000/../.config/config/google-chrome/Default/Web%20Data
http://myhostname:8000/../.ssh/id_dsa
http://myhostname:8000/../../../etc/passwd
----

(((directory)))(((urlToPath function)))(((slash character)))(((backslash character)))Поменяйте функцию `urlToPath` для устранения подобной проблемы. Примите во внимание, что на ((Windows)) Node разрешает как прямые так и обратные слеши для задания путей.

(((security)))Кроме этого, помедитируйте над тем фактом, что как только вы выставляете сырую систему в ((Интернет)), ((баг))и в системе могут быть использованы против вас и вашего компьютера.

!!hint!!

(((replace method)))(((file server example)))(((leak)))(((period
character)))(((slash character)))(((backslash
character)))(((decodeURIComponent function)))It is enough to strip out
all occurrences of two dots that have a slash, a backslash, or the end
of the string on both sides. Using the `replace` method with a
((regular expression)) is the easiest way to do this. But since such
instances may overlap (as in `"/../../f"`), you may have to apply
`replace` multiple times, until the string no longer changes. Also
make sure you do the replace _after_ decoding the string, or it would
be possible to foil the check by encoding a dot or a slash.

(((path,file system)))(((slash character)))Another potentially
worrying case is when paths start with a slash, which are interpreted as
((absolute path))s. But because `urlToPath` puts a dot character in
front of the path, it is impossible to create requests that result in
such a path. Multiple slashes in a row, inside the path, are odd
but will be treated as a single slash by the file system.

!!hint!!

=== Создание директорий ===

(((file server example)))Хотя метод `DELETE` работает и при удалении директорий (через `fs.rmdir`), пока сервер не предоставляет возможности _создания_ ((директорий)).

(((MKCOL method)))Добавьте поддержку метода `MKCOL`, который должен создавать директорию через `fs.mkdir`. `MKCOL` не является основным методом HTTP, но он существует, именно для этого, в стандарте _((WebDAV))_, который содержит расширения ((HTTP)), чтобы использовать его для записи ресурсов, а не только для их чтения.

!!hint!!

(((file server example)))(((MKCOL method)))(((mkdir
function)))(((idempotency)))(((400 (HTTP status code))))You can use
the function that implements the `DELETE` method as a blueprint for
the `MKCOL` method. When no file is found, try to create a directory with
`fs.mkdir`. When a directory exists at that path, you can return a 204
response so that directory creation requests are idempotent. If a
nondirectory file exists here, return an error code. The code 400 (“bad
request”) would be appropriate here.

!!hint!!

=== Общественное место в сети ===

(((public space (exercise))))(((file server example)))(((Content-Type header)))(((website)))Так как файловый сервер выдаёт любые файлы и даже возвращает правильный заголовок `Content-Type`, его можно использовать для обслуживания веб-сайта. Так как он разрешает всем удалять и заменять файлы, это был бы интересный сайт – который можно изменять, портить и удалять всем, кто может создать правильный HTTP-запрос. Но это всё равно был бы веб-сайт.

Напишите простую ((HTML)) страницу с простым файлом JavaScript. Разместите их в директории, обслуживаемой файловым сервером и откройте в браузере.

Затем, в качестве продвинутого упражнения, скомбинируйте все полученные знания из книги, чтобы построить более дружественный интерфейс для модификации веб-сайта _изнутри_ самого сайта.

(((XMLHttpRequest)))Используйте ((форму)) HTML (link:18_forms.html#forms[глава 18]) для редактирования файлов, составляющих сайт, позволяя пользователю обновлять их на сервере через HTTP-запросы, как описано в link:17_http.html#http[главе 17].

Начните с одного файла, редактирование которого разрешено. Затем сделайте так, чтобы можно было выбирать файл для редактирования. Используйте тот факт, что наш файловый сервер возвращает списки файлов по запросу директории.

(((overwriting)))Не меняйте файлы непосредственно в коде файлового сервера – если вы сделаете ошибку, вы скорее всего испортите те файлы. Работайте в директории, недоступной снаружи, и копируйте их туда после тестирования.

(((IP address)))Если ваш компьютер соединяется с ((Интернет))ом напрямую, без ((firewall)), ((роутер))а или других устройств, вы сможете пригласить друга на свой сайт. Для проверки сходите на http://www.whatismyip.com/[_whatismyip.com_], скопируйте IP адрес в адресную строку вашего браузера и добавьте `:8000` для выбора нужного порта. Если вы попали на свой сайт, то он доступен для просмотра всем.

!!hint!!

(((file server example)))(((textarea (HTML
tag))))(((XMLHttpRequest)))(((relative path)))(((public space
(exercise))))You can create a `<textarea>` element to hold the content
of the file that is being edited. A `GET` request, using
`XMLHttpRequest`, can be used to get the current content of the file.
You can use relative URLs like _index.html_, instead of
http://localhost:8000/index.html[_http://localhost:8000/index.html_],
to refer to files on the same server as the running script.

(((form (HTML tag))))(((submit event)))(((click event)))(((PUT
method)))Then, when the user clicks a button (you can use a `<form>`
element and `"submit"` event or simply a `"click"` handler), make a
`PUT` request to the same URL, with the content of the `<textarea>` as
request body, to save the file.

(((select (HTML tag))))(((option (HTML tag))))(((change event)))You
can then add a `<select>` element that contains all the files in the
server's root ((directory)) by adding `<option>` elements containing
the lines returned by a `GET` request to the URL `/`. When the user
selects another file (a `"change"` event on the field), the script
must fetch and display that file. Also make sure that when saving a
file, you use the currently selected filename.

(((directory)))(((GET method)))Unfortunately, the server is too
simplistic to be able to reliably read files from subdirectories
since it does not tell us whether the thing we fetched with a `GET`
request is a regular file or a directory. Can you think of a way to
extend the server to address this?

!!hint!!
