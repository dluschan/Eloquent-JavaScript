:chap_num: 6
:prev_link: 05_higher_order
:next_link: 07_elife
:load_files: ["code/mountains.js", "code/chapter/06_object.js"]
:zip: node/html

= Тайная жизнь объектов =

[chapterquote="true"]
[quote, Джо Армстронг, в интервью Coders at Work]
____
Проблема объектно-ориентированных языков в том, что они тащат с собой всё своё неявное окружение. Вам нужен был банан – а вы получаете гориллу с бананом, и целые джунгли впридачу.
____

(((Armstrong+++,+++ Joe)))(((object)))(((holy war)))Термин “объект” в программировании сильно перегружен значениями. В моей профессии объекты – стиль жизни, тема священных войн и любимое заклинание, не теряющий своей магической силы.

Стороннему человеку всё это непонятно. Начнём же с краткой ((истории)) объектов как концепции в программировании.

== История ==

(((isolation)))(((history)))(((object-oriented programming)))(((object)))Эта история, как большинство историй о программировании, начинается с проблемы ((сложности)). Одна из идей говорит, что сложность можно сделать управляемой, разделив её не небольшие части, изолированные друг от друга. Эти части стали называть _объектами_.

[[interface]]
(((complexity)))(((encapsulation)))(((method)))(((interface)))Объект – твёрдая скорлупа, скрывающая липкую сложность внутри, и вместо неё предлагающая нам несколько ручек настройки и контактов (вроде ((метод))ов), представляющих _интерфейс_, посредством которого объект нужно использовать. Идея в том, что интерфейс относительно прост, и при работе с ним позволяет игнорировать все сложные процессы, происходящие _внутри_ объекта.

image::img/object.jpg[alt="A simple interface can hide a lot of complexity.",width="6cm"]

Для примера представьте объект, обеспечивающий интерфейс к участку экрана. С его помощью можно рисовать фигуры или выводить текст на этот участок, но при этом все детали, касающиеся превращения текста или фигур в пиксели, скрыты. У вас есть набор методов, к примеру ++drawCircle++, и это всё, что вам нужно знать для использования такого объекта.

(((object-oriented programming)))Такие идеи получили развитие в 70-80 годах, а в 90-х их вынесла на поверхность рекламная волна – революция объектно-ориентированного программирования. Внезапно большой клан людей объявил, что объекты – это _правильный_ способ программирования. А всё, что не имеет объектов, является устаревшей ерундой.

Такой фанатизм всегда приводит к куче бесполезной чуши, и с тех пор идёт что-то вроде контрреволюции. В некоторых кругах объекты вообще имеют крайне плохую репутацию.

Я предпочитаю рассматривать их с практической, а не идеологической точки зрения. Есть несколько полезных идей, в частности _((инкапсуляция))_ (различие между внутренней сложностью и внешней простотой), которые были популяризованы объектно-ориентированной культурой. Их стоит изучать.

Эта глава описывает довольно эксцентричный подход JavaScript к объектам, и то, как они соотносятся с классическими объектно-ориентированными техниками.

[[obj_methods]]
== Методы ==

(((rabbit example)))(((method)))(((property)))Методы – свойства, содержащие функции. Простой метод:

[source,javascript]
----
var rabbit = {};
rabbit.speak = function(line) {
  console.log("Кролик говорит '" + line + "'");
};

rabbit.speak("Я живой.");
// → Кролик говорит 'Я живой.'
----

(((this)))(((method call)))Обычно метод должен что-то сделать с объектом, через который он был вызван. Когда функцию вызывают в виде метода – как свойство объекта, например ++object.method()++ – специальная переменная `this` в её теле будет указывать на вызвавший её объект.

// test: join
// include_code top_lines:6

[source,javascript]
----
function speak(line) {
  console.log("А " + this.type + " кролик говорит '" +
              line + "'");
}
var whiteRabbit = {type: "белый", speak: speak};
var fatRabbit = {type: "толстый", speak: speak};

whiteRabbit.speak("Ушки мои и усики, " +
                  "я же наверняка опаздываю!");
// → А белый кролик говорит 'Ушки мои и усики, я же наверняка опаздываю!'
fatRabbit.speak("Мне бы сейчас морковочки.");
// → А толстый кролик говорит 'Мне бы сейчас морковочки.'
----

(((apply method)))(((bind method)))(((this)))(((rabbit example)))Код использует ключевое слово `this` для вывода типа говорящего кролика. Вспомните, что методы `apply` и `bind` принимают первый аргумент, который можно использовать для эмуляции вызова методов. Этот первый аргумент как раз даёт значение переменной `this`.

[[call_method]]
(((call method)))Есть метод, похожий на `apply`, под названием `call`. Он тоже вызывает функцию, методом которой является, только принимает аргументы как обычно, а не в виде массива. Как `apply` и `bind`, в `call` можно передать значение `this`.

[source,javascript]
----
speak.apply(fatRabbit, ["Отрыжка!"]);
// → А толстый кролик говорит 'Отрыжка!'
speak.call({type: "старый"}, "О, господи.");
// → А старый кролик говорит 'О, господи.'
----

[[prototypes]]
== Прототипы ==

(((toString method)))Следите за руками.

[source,javascript]
----
var empty = {};
console.log(empty.toString);
// → function toString(){…}
console.log(empty.toString());
// → [object Object]
----

(((magic)))Я достал свойство пустого объекта. Магия!

(((property)))(((object)))Ну, не магия, конечно. Я просто не всё рассказал про то, как работают объекты в JavaScript. В дополнение к набору свойств, почти у всех также есть _прототип_. ((Прототип)) – это ещё один объект, который используется как запасной источник свойств. Когда объект получает запрос на свойство, которого у него нет, это свойство ищется у его прототипа, затем у прототипа прототипа, и т.д.

(((Object prototype)))Ну а кто же ((прототип)) пустого объекта? Это великий предок всех объектов, `Object.prototype`.

[source,javascript]
----
console.log(Object.getPrototypeOf({}) ==
            Object.prototype);
// → true
console.log(Object.getPrototypeOf(Object.prototype));
// → null
----

(((getPrototypeOf function)))Как и следовало ожидать, функция `Object.getPrototypeOf` возвращает прототип объекта.

(((toString method)))Прототипические отношения в JavaScript выглядят как ((дерево)), а в его корне находится `Object.prototype`. Он предоставляет несколько ((метод))ов, которые появляются у всех объектов, типа `toString`, который преобразует объект в строковый вид.

(((inheritance)))(((Function prototype)))(((Array prototype)))(((Object prototype)))((Прототип))ом многих объектов служит не непосредственно `Object.prototype`, а какой-то другой объект, который предоставляет свои свойства по умолчанию. Функции происходят от `Function.prototype`, массивы – от `Array.prototype`.

[source,javascript]
----
console.log(Object.getPrototypeOf(isNaN) ==
            Function.prototype);
// → true
console.log(Object.getPrototypeOf([]) ==
            Array.prototype);
// → true
----

(((Object prototype)))У таких прототипов будет свой прототип – часто `Object.prototype`, поэтому он всё равно, хоть и не напрямую, предоставляет им методы типа `toString`.

(((getPrototypeOf function)))(((rabbit example)))(((Object.create
function)))Функция `Object.getPrototypeOf` возвращает прототип объекта. Можно использовать `Object.create` для создания объектов с заданным ((прототип))ом.

[source,javascript]
----
var protoRabbit = {
  speak: function(line) {
    console.log("А " + this.type + " кролик говорит '" +
                line + "'");
  }
};
var killerRabbit = Object.create(protoRabbit);
killerRabbit.type = "убийственный";
killerRabbit.speak("ХРЯЯЯСЬ!");
// → А убийственный кролик говорит 'ХРЯЯЯСЬ!'
----

(((shared property)))“Прото”-кролик работает в качестве контейнера свойств, которые есть у всех кроликов. Конкретный объект-кролик, например убийственный, содержит свойства, применимые только к нему,– например, свой тип,– и наследует разделяемые с другими свойства от прототипа.

[[constructors]]
== Конструкторы ==

(((new operator)))(((this)))(((return keyword)))(((object,creation)))Более удобный способ создания объектов, наследуемых от некоего прототипа – _((конструктор))_. В JavaScript вызов функции с предшествующим ключевым словом `new` приводит к тому, что функция работает как конструктор. У конструктора будет в распоряжении переменная `this`, привязанная к свежесозданному объекту, и если она не вернёт непосредственно другое значение, содержащее объект, этот новый объект будет возвращён вместо него.

Говорят, что объект, созданный при помощи `new`, является _((экземпляр))ом_ конструктора.

(((rabbit example)))(((capitalization)))Вот простой конструктор кроликов. Имена конструкторов принято начинать с заглавной буквы, чтобы отличать их от других функций.

// include_code top_lines:6

[source,javascript]
----
function Rabbit(type) {
  this.type = type;
}

var killerRabbit = new Rabbit("убийственный");
var blackRabbit = new Rabbit("чёрный");
console.log(blackRabbit.type);
// → чёрный
----

(((prototype property)))(((constructor)))Конструкторы (а вообще-то, и все функции) автоматически получают свойство под именем `prototype`, которое по умолчанию содержит простой и пустой объект, происходящий от `Object.prototype`. Каждый экземпляр, созданный этим конструктором, будет иметь этот объект в качестве ((прототип))а. Поэтому, чтобы добавить кроликам, созданным конструктором `Rabbit`, метод `speak`, мы просто можем сделать так:

// include_code top_lines:4

[source,javascript]
----
Rabbit.prototype.speak = function(line) {
  console.log("А " + this.type + " кролик говорит '" +
              line + "'");
};
blackRabbit.speak("Всем капец...");
// → А чёрный кролик говорит 'Всем капец...'
----

(((prototype property)))(((getPrototypeOf function)))Важно отметить разницу между тем, как прототип связан с конструктором (через свойство `prototype`) и тем, как у объектов _есть_ прототип (который можно получить через `Object.getPrototypeOf`). На самом деле прототип конструктора — `Function.prototype`, поскольку конструкторы – это функции. Его _свойство_ `prototype` будет прототипом экземпляров, созданных им, но не _его_ прототипом.

== Перезагрузка унаследованных свойств ==

(((shared property)))(((overriding)))Когда вы добавляете ((свойство)) объекту, есть оно в прототипе или нет, оно добавляется непосредственно к _самому_ объекту. Теперь это его свойство. Если в прототипе _есть_ одноимённое свойство, оно больше не влияет на объект. Сам прототип не меняется.

[source,javascript]
----
Rabbit.prototype.teeth = "мелкие";
console.log(killerRabbit.teeth);
// → мелкие
killerRabbit.teeth = "длинные, острые и окровавленные";
console.log(killerRabbit.teeth);
// → длинные, острые и окровавленные
console.log(blackRabbit.teeth);
// → мелкие
console.log(Rabbit.prototype.teeth);
// → мелкие
----

(((prototype,diagram)))На диаграмме нарисована ситуация после прогона кода. ((Прототип))ы `Rabbit` и `Object` находятся за `killerRabbit` на манер фона, и у них можно запрашивать свойства, которых нет у самого объекта.

image::img/rabbits.svg[alt="Rabbit object prototype schema",width="8cm"]

(((shared property)))Перезагрузка свойств, существующих в прототипе, часто приносит пользу. Как в примере с зубами кролика её можно использовать для выражения каких-то исключительных характеристик у более общих свойств, в то время как обычные объекты просто используют стандартные значения, взятые у прототипов.

(((toString method)))(((Array prototype)))(((Function prototype)))Также она используется для назначения функциям и массивам разных методов `toString`.

[source,javascript]
----
console.log(Array.prototype.toString ==
            Object.prototype.toString);
// → false
console.log([1, 2].toString());
// → 1,2
----

(((toString method)))(((join method)))(((call method)))Вызов `toString` массива выводит результат, похожий на `.join(",")` – получается список, разделённый запятыми. Вызов `Object.prototype.toString` напрямую для массива приводит к другому результату. Эта функция не знает ничего о массивах, и просто помещает слово “object” с имененм типа между квадратными скобками.

[source,javascript]
----
console.log(Object.prototype.toString.call([1, 2]));
// → [object Array]
----

== Нежелательное взаимодействие прототипов ==

(((prototype,interference)))(((rabbit example)))(((mutability)))((Прототип)) помогает в любое время добавлять новые свойства и методы всем объектам, которые основаны на нём. К примеру, нашим кроликам может понадобиться танец.

[source,javascript]
----
Rabbit.prototype.dance = function() {
  console.log("А " + this.type + " кролик танцует джигу.");
};
killerRabbit.dance();
// → А убийственный кролик танцует джигу.
----

(((map)))(((object,as map)))Это удобно. Но в некоторых случаях это приводит к проблемам. В предыдущих главах мы использовали объект как способ связать значения с именами – мы создавали свойства для этих имён, и давали им соответствующие значения. Вот пример из link:04_data.html#object_map[Главы 4]:

// include_code

[source,javascript]
----
var map = {};
function storePhi(event, phi) {
  map[event] = phi;
}

storePhi("пицца", 0.069);
storePhi("тронул дерево", -0.081);
----

(((for/in loop)))(((in operator)))Мы можем перебрать все значения фи в объекте через цикл `for`/`in`, и проверить наличие в нём имени через оператор `in`. К сожалению, нам мешается прототип объекта.

[source,javascript]
----
Object.prototype.nonsense = "ку";
for (var name in map)
  console.log(name);
// → пицца
// → тронул дерево
// → nonsense
console.log("nonsense" in map);
// → true
console.log("toString" in map);
// → true

// Удалить проблемное свойство
delete Object.prototype.nonsense;
----

(((prototype,pollution)))(((toString method)))Это же неправильно. Нет события под названием “nonsense”. И _тем более_ нет события под названием “toString”.

(((enumerability)))(((for/in loop)))(((property)))Занятно, что `toString` не вылезло в цикле `for`/`in`, хотя оператор `in` возвращает true на его счёт. Это потому, что JavaScript различает _счётные_ и _несчётные_ свойства.

(((Object prototype)))Все свойства, которые мы создаём, назначая им значение – счётные. Все стандартные свойства в `Object.prototype` – несчётные, поэтому они не вылезают в циклах `for`/`in`.

(((defineProperty function)))Мы можем объявить свои несчётные свойства через функцию `Object.defineProperty`, которая позволяет указывать тип создаваемого свойства.

[source,javascript]
----
Object.defineProperty(Object.prototype, "hiddenNonsense",
                      {enumerable: false, value: "ку"});
for (var name in map)
  console.log(name);
// → пицца
// → тронул дерево
console.log(map.hiddenNonsense);
// → ку
----

(((in operator)))(((map)))(((object,as map)))(((hasOwnProperty method)))Теперь свойство есть, а в цикле оно не вылезает. Хорошо. Но нам всё ещё мешает проблема с оператором `in`, который утверждает, что свойства `Object.prototype` присутствуют в нашем объекте. Для этого нам понадобится метод `hasOwnProperty`.

[source,javascript]
----
console.log(map.hasOwnProperty("toString"));
// → false
----

(((property,own)))Он говорит, является ли свойство свойством объекта, без оглядки на прототипы. Часто это более полезная информация, чем выдаёт оператор `in`.

(((prototype,pollution)))(((for/in loop)))Если вы волнуетесь, что кто-то другой, чей код вы загрузили в свою программу, испортил основной прототип объектов, я рекомендую писать циклы `for`/`in` так:

[source,javascript]
----
for (var name in map) {
  if (map.hasOwnProperty(name)) {
    // ... это наше личное свойство
  }
}
----

== Объекты без прототипов ==

(((map)))(((object,as map)))(((hasOwnProperty method)))Но кроличья нора на этом не заканчивается. А если кто-то зарегистрировал имя `hasOwnProperty` в объекте `map` и назначил ему значение 42? Теперь вызов `map.hasOwnProperty` обращается к локальному свойству, в котором содержится номер, а не функция.

(((Object.create function)))(((prototype,avoidance)))В таком случае прототипы только мешаются, и нам бы хотелось иметь объекты вообще без прототипов. Мы видели функцию `Object.create`, что позволяет создавать объект с заданным прототипом. Мы можем передать `null` для прототипа, чтобы создать свеженький объект без прототипа. Это то, что нам нужно для объектов типа `map`, где могут быть любые свойства.

[source,javascript]
----
var map = Object.create(null);
map["пицца"] = 0.069;
console.log("toString" in map);
// → false
console.log("пицца" in map);
// → true
----

(((in operator)))(((for/in loop)))(((Object prototype)))Так-то лучше! Нам уже не нужна приблуда `hasOwnProperty`, потому что все свойства объекта заданы лично нами. Мы спокойно используем циклы `for`/`in` без оглядки на то, что люди творили с `Object.prototype`.

== Полиморфизм ==

(((toString method)))(((String function)))(((polymorphism)))(((overriding)))Когда вы вызываете функцию `String`, преобразующую значение в строку, для объекта – он вызовет метод `toString`, чтобы создать осмысленную строчку. Я упомянул, что некоторые стандартные прототипы объявляют свои версии `toString` для создания строк, более полезных, чем просто `"[object Object]"`.

(((object-oriented programming)))Это простой пример мощной идеи. Когда кусок кода написан так, чтобы работать с объектами через определённый интерфейс,– в нашем случае через метод `toString`,– любой объект, поддерживающий этот ((интерфейс)), можно подключить к коду – и всё будет просто работать.

Такая техника называется __полиморфизм__ – хотя никто и не меняет своей формы. Полиморфный код может работать со значениями самых разных форм, пока они поддерживают одинаковый интерфейс.

[[tables]]
== Форматируем таблицу ==

(((MOUNTAINS data set)))(((table example)))Давайте рассмотрим пример, чтобы понять, как выглядит ((полиморфизм)), да и вообще ((объектно-ориентированное программирование)). Проект следующий: мы напишем программу, которая получает массив массивов из ячеек ((таблицы)), и строит строку, содержащую красиво отформатированную таблицу. То есть, колонки и ряды выровнены. Типа вот этого:

[source,text/plain]
----
name         height country
------------ ------ -------------
Kilimanjaro    5895 Tanzania
Everest        8848 Nepal
Mount Fuji     3776 Japan
Mont Blanc     4808 Italy/France
Vaalserberg     323 Netherlands
Denali         6168 United States
Popocatepetl   5465 Mexico
----

Работать она будет так: основная функция будет спрашивать каждую ячейку, какой она ширины и высоты, и потом использует эту информацию для определения ширины колонок и высоты рядов. Затем она попросит ячейки нарисовать себя, и соберёт результаты в одну строку.

[[table_interface]]
(((table example)))Программа будет общаться с объектами ячеек через хорошо определённый ((интерфейс)). Типы ячеек не будут заданы жёстко. Мы сможем добавлять новые стили ячеек – к примеру, подчёркнутые ячейки у заголовка. И если они будут поддерживать наш интерфейс, они просто заработают, без изменений в программе.

Интерфейс:

* `minHeight()` возвращает число, показывающее минимальную высоту, которую требует ячейка (выраженную в строчках).

* `minWidth()` возвращает число, показывающее минимальную ширину, которую требует ячейка (выраженную в символах).

* `draw(width, height)` возвращает массив длины `height`, содержащий наборы строк, каждая из которых шириной в `width` символов.
  Это содержимое ячейки.

(((function,higher-order)))Я буду использовать функции высшего порядка, поскольку они здесь очень уместны.

(((rowHeights function)))(((colWidths function)))(((maximum)))(((map method)))(((reduce method)))Первая часть программы вычисляет массивы минимальных ширин колонок и высот строк для матрицы ячеек. Переменная `rows` будет содержать массив массивов, где каждый внутренний массив – это строка ячеек.

// include_code

[source,javascript]
----
function rowHeights(rows) {
  return rows.map(function(row) {
    return row.reduce(function(max, cell) {
      return Math.max(max, cell.minHeight());
    }, 0);
  });
}

function colWidths(rows) {
  return rows[0].map(function(_, i) {
    return rows.reduce(function(max, row) {
      return Math.max(max, row[i].minWidth());
    }, 0);
  });
}
----

(((underscore character)))(((programming style)))Используя переменную, у которой имя начинается с (или полностью состоит из) подчёркивания (_), мы показываем тому, кто будет читать код, что этот аргумент не будет использоваться.

Функция `rowHeights` не должна вызвать затруднений. Она использует `reduce` для подсчёта максимальной высоты массива ячеек, и заворачивает это в `map`, чтобы пройти все строки в массиве `rows`.

(((map method)))(((filter method)))(((forEach method)))(((array,indexing)))(((reduce method)))Ситуация с `colWidths` посложнее, потому что внешний массив – это массив строк, а не столбцов. Я забыл упомянуть, что `map` (как и `forEach`, `filter` и похожие методы массивов) передаёт в заданную функцию второй аргумент – ((индекс)) текущего элемента. Проходя при помощи `map` элементы первой строки и используя только второй аргумент функции, `colWidths` строит массив с одним элементом для каждого индекса столбца. Вызов `reduce` проходит по внешнему массиву `rows` для каждого индекса, и выбирает ширину широчайшей ячейки в этом индексе.

(((table example)))(((drawTable function)))Код для вывода таблицы:

// include_code

[source,javascript]
----
function drawTable(rows) {
  var heights = rowHeights(rows);
  var widths = colWidths(rows);

  function drawLine(blocks, lineNo) {
    return blocks.map(function(block) {
      return block[lineNo];
    }).join(" ");
  }

  function drawRow(row, rowNum) {
    var blocks = row.map(function(cell, colNum) {
      return cell.draw(widths[colNum], heights[rowNum]);
    });
    return blocks[0].map(function(_, lineNo) {
      return drawLine(blocks, lineNo);
    }).join("\n");
  }

  return rows.map(drawRow).join("\n");
}
----

(((inner function)))(((nesting,of functions)))Функциия `drawTable` использует внутреннюю функцию `drawRow` для рисования всех строк, и соединяет их месте через символы новой строки.

(((table example)))Функция `drawRow` сперва превращает объекты ячеек строки в _блоки_, которые являются массивами строк, представляющими содержимое ячеек, разделённые линиями. Одна ячейка, содержащая число 3776, может быть представлена массивом из одного элемента `["3776"]`, а подчёркнутая ячейка может занять две строки и выглядеть как массив `["name", "----"]`.

(((map method)))(((join method)))Блоки для строки, у которых одинаковая высота, должны выводиться рядом друг с другом. Второй вызов `map` в `drawRow` строит эту строку вывода линия за линией, начиная с линий самого левого блока, и затем для каждой из них дополняя строку до полной ширины таблицы. Эти линии затем соединяются через символ новой строки, создавая целый ряд, который возвращает `drawRow`.

Функция `drawLine` выцепляет строки, которые должны появляться рядом друг с другом из массива блоков, и соединяет их через пробел, чтобы создать промежуток в один символ между столбцами таблицы.

[[split]]
(((split method)))(((string,methods)))(((table example)))Давайте напишем конструктор для ячеек, содержащих текст, который предоставляет ((интерфейс)) для ячеек. Он разбивает строчку в массив строк при помощи метода `split`, который режет строчку каждый раз, когда в ней встречается его аргумент, и возвращает массив этих кусочков. Метод `minWidth` находит максимальную ширину линии в массиве.

// include_code

[source,javascript]
----
function repeat(string, times) {
  var result = "";
  for (var i = 0; i < times; i++)
    result += string;
  return result;
}

function TextCell(text) {
  this.text = text.split("\n");
}
TextCell.prototype.minWidth = function() {
  return this.text.reduce(function(width, line) {
    return Math.max(width, line.length);
  }, 0);
};
TextCell.prototype.minHeight = function() {
  return this.text.length;
};
TextCell.prototype.draw = function(width, height) {
  var result = [];
  for (var i = 0; i < height; i++) {
    var line = this.text[i] || "";
    result.push(line + repeat(" ", width - line.length));
  }
  return result;
};
----

(((TextCell type)))Используется вспомогательная функция `repeat`, которая строит строчку с заданным значением, повторённым необходимое количество раз. Метод `draw` использует её для создания “отступов” в строках, чтобы они все были необходимой длины.

Давайте нарисуем для опыта шахматную доску 5х5.

[source,javascript]
----
var rows = [];
for (var i = 0; i < 5; i++) {
   var row = [];
   for (var j = 0; j < 5; j++) {
     if ((j + i) % 2 == 0)
       row.push(new TextCell("##"));
     else
       row.push(new TextCell("  "));
   }
   rows.push(row);
}
console.log(drawTable(rows));
// → ##    ##    ##
//      ##    ##   
//   ##    ##    ##
//      ##    ##   
//   ##    ##    ##
----

Работает! Но так как у всех ячеек один размер, код форматирования таблицы не делает ничего интересного.

[[mountains]]
(((data set)))(((MOUNTAINS data set)))Исходные данные для таблицы гор, которую мы строим, доступна в переменной `MOUNTAINS` ((песочницы)) и для http://eloquentjavascript.net/2nd_edition/code/mountains.js[скачивания] на сайте(!book (http://eloquentjavascript.net/2nd_edition/code#6[_eloquentjavascript.net/2nd_edition/code#6_])!).

(((table example)))Нам нужно выделить верхнюю строку, содержащую названия столбцов, при помощи подчёркивания. Никаких проблем – мы просто задаём тип ячейки, который этим занимается.

// include_code

[source,javascript]
----
function UnderlinedCell(inner) {
  this.inner = inner;
}
UnderlinedCell.prototype.minWidth = function() {
  return this.inner.minWidth();
};
UnderlinedCell.prototype.minHeight = function() {
  return this.inner.minHeight() + 1;
};
UnderlinedCell.prototype.draw = function(width, height) {
  return this.inner.draw(width, height - 1)
    .concat([repeat("-", width)]);
};
----

(((UnterlinedCell type)))Подчёркнутая ячейка _содержит_ другую ячейку. Она возвращает такие же размеры, как и у ячейки `inner` (через вызовы её методов `minWidth` и `minHeight`), но добавляет единичку к высоте из-за места, занятого чёрточками.

(((concat method)))(((concatenation)))Рисовать её просто – мы берём содержимое ячейки `inner` и добавляем одну строку, заполненную чёрточками.

(((dataTable function)))Теперь, имея основной движок, мы можем написать функцию, строящую сетку ячеек из нашего набора данных.

// test: wrap, trailing

[source,javascript]
----
function dataTable(data) {
  var keys = Object.keys(data[0]);
  var headers = keys.map(function(name) {
    return new UnderlinedCell(new TextCell(name));
  });
  var body = data.map(function(row) {
    return keys.map(function(name) {
      return new TextCell(String(row[name]));
    });
  });
  return [headers].concat(body);
}

console.log(drawTable(dataTable(MOUNTAINS)));
// → name         height country
//   ------------ ------ -------------
//   Kilimanjaro  5895   Tanzania
//   … и так далее
----

[[keys]]
(((Object.keys function)))(((property)))(((for/in loop)))Стандартная функция `Object.keys` возвращает массив имён свойств объекта. Верхняя строка таблицы должна содержать подчёркнутые ячейки с названиями столбцов. Значения всех объектов из набора данных выглядят под заголовком как нормальные ячейки – мы извлекаем их проходом функции `map` по массиву `keys`, чтобы быть уверенным в сохранении одного порядка ячеек в каждой строке.

(((right-aligning)))Итоговая таблица напоминает таблицу из примера, только вот числа в столбце `height` не выровнены по правому краю. Мы займёмся этим чуть позже.

== Геттеры и сеттеры ==

(((getter)))(((setter)))(((property)))При создании интерфейса можно ввести свойства, не являющиеся методами. Мы могли просто определить `minHeight` и `minWidth` как переменные для хранения номеров. Но это потребовало бы от нас писать код вычисления их значений в ((конструктор))е – а это плохо, поскольку _конструирование_ объекта не связано с ними напрямую. Могли возникнуть проблемы, когда например внутренняя ячейка или подчёркнутая ячейка изменяются – и тогда их размер тоже должен меняться.

(((programming style)))Эти соображения привели к тому, что свойства, не являющиеся методами, многие не включают в интерфейс. Вместо прямого доступа к свойствам-значениям, используются методы типа `getSomething` и `setSomething` для чтения и записи значений свойств. Но есть и минус – приходится писать (и читать) много дополнительных методов.

К счастью, JavaScript даёт нам технику, использующую лучшее из обоих подходов. Мы можем задать свойства, которые снаружи выглядят обыкновенными, но втайне имеют связанные с ними ((метод))ы.

[source,javascript]
----
var pile = {
  elements: ["скорлупа", "кожура", "червяк"],
  get height() {
    return this.elements.length;
  },
  set height(value) {
    console.log("Игнорируем попытку задать высоту", value);
  }
};

console.log(pile.height);
// → 3
pile.height = 100;
// → Игнорируем попытку задать высоту 100
----

(((defineProperty function)))((({} (object))))(((getter)))(((setter)))В объявлении объекта записи `get` или `set` позволяют задать функцию, которая будет вызвана при чтении или записи свойства. Можно также добавить такое свойство в существующий объект, к примеру, в `prototype`, используя функцию `Object.defineProperty` (раньше мы её уже использовали, создавая несчётные свойства).

[source,javascript]
----
Object.defineProperty(TextCell.prototype, "heightProp", {
  get: function() { return this.text.length; }
});

var cell = new TextCell("да\nну");
console.log(cell.heightProp);
// → 2
cell.heightProp = 100;
console.log(cell.heightProp);
// → 2
----

Так же можно задавать свойство `set` в объекте, передаваемом в `defineProperty`, для задания метода-сеттера. Когда геттер есть, а сеттера нет – попытка записи в свойство просто игнорируется.

== Наследование ==

(((inheritance)))(((table example)))(((alignment)))(((TextCell type)))Но мы ещё не закончили с нашим упражнением по форматированию таблицы. Читать её было бы удобнее, если б числовой столбец был выровнен по правому краю. Нам нужно создать ещё один тип ячеек вроде `TextCell`, но вместо дополнения текста пробелами справа, он дополняет его слева, чтобы выровнять его по правому краю.

(((RTextCell type)))Мы могли бы написать новый ((конструктор)) со всеми тремя методами в прототипе. Но прототипы могут сами иметь прототипы, и поэтому мы можем поступить умнее.

// include_code

[source,javascript]
----
function RTextCell(text) {
  TextCell.call(this, text);
}
RTextCell.prototype = Object.create(TextCell.prototype);
RTextCell.prototype.draw = function(width, height) {
  var result = [];
  for (var i = 0; i < height; i++) {
    var line = this.text[i] || "";
    result.push(repeat(" ", width - line.length) + line);
  }
  return result;
};
----

(((shared property)))(((overriding)))(((interface)))Мы повторно использовали конструктор и методы `minHeight` и `minWidth` из обычного `TextCell`. И `RTextCell` теперь в общем эквивалентен `TextCell`, за исключением того, что в методе `draw` находится другая функция.

(((call method)))Такая схема называется _((наследование))м_. Мы можем строить в чем-то отличные типы данных на основе существующих, не тратя много сил. Обычно новый конструктор вызывает старый (через метод `call`, чтобы передать ему новый объект и его значение). После этого мы можем предположить, что все поля, которые должны быть в старом объекте, добавлены. Мы наследуем ((прототип)) конструктора от старого так, что экземпляры этого типа будут иметь доступ к свойствам старого прототипа. И наконец, мы можем переопределить некоторые свойства, добавляя их к новому прототипу.

(((dataTable function)))Если мы чуть отредактируем функцию `dataTable`, чтобы она использовала для числовых ячеек ++RTextCells++, мы получим нужную нам таблицу.

// start_code bottom_lines: 1
// include_code strip_log

[source,javascript]
----
function dataTable(data) {
  var keys = Object.keys(data[0]);
  var headers = keys.map(function(name) {
    return new UnderlinedCell(new TextCell(name));
  });
  var body = data.map(function(row) {
    return keys.map(function(name) {
      var value = row[name];
      // Тут поменяли:
      if (typeof value == "number")
        return new RTextCell(String(value));
      else
        return new TextCell(String(value));
    });
  });
  return [headers].concat(body);
}

console.log(drawTable(dataTable(MOUNTAINS)));
// → … красиво отформатированная таблица
----

(((object-oriented programming)))Наследование – основная часть объектно-ориентированной традиции, вместе с инкапсуляцией и полиморфизмом. Но, в то время как последние две воспринимают как отличные идеи, первая вызывает споры.

(((complexity)))В основном потому, что её обычно путают с ((полиморфизм))ом, представляют более мощным инструментом, чем она на самом деле является, и используют не по назначению. Тогда как ((инкапсуляция)) и полиморфизм используются для _разделения_ частей кода и уменьшения связанности программы, ((наследование)) связывает типы вместе и создаёт _большую_ связанность.

(((code structure)))(((programming style)))Мы можем использовать полиморфизм без наследования. Я не советую вам полностью избегать наследования – я его использую регулярно в своих программах. Но относитесь к нему как к более хитрому трюку, который позволяет определять новые типы с минимумом кода – а не как к основному принципу организации кода. Предпочтительно расширять типы при помощи ((композиции)) – как `UnderlinedCell` построен на использовании другого объекта ячейки. Он просто хранит его в свойстве и перенаправляет вызовы из своих в его ((метод))ы.

== Оператор instanceof ==

(((type)))(((instanceof operator)))(((constructor)))(((object)))Иногда удобно знать, произошёл ли объект от конкретного конструктора. Для этого JavaScript даёт нам бинарный оператор `instanceof`.

[source,javascript]
----
console.log(new RTextCell("A") instanceof RTextCell);
// → true
console.log(new RTextCell("A") instanceof TextCell);
// → true
console.log(new TextCell("A") instanceof RTextCell);
// → false
console.log([1] instanceof Array);
// → true
----

(((inheritance)))Оператор проходит и через наследованные типы. `RTextCell` является экземпляром `TextCell`, поскольку `RTextCell.prototype` происходит от `TextCell.prototype`. Оператор также можно применять к стандартным конструкторам типа `Array`. Практически все объекты – экземпляры `Object`.

== Итог ==

Получается, что объекты чуть более сложны, чем я их подавал сначала. У них есть прототипы – это другие объекты, и они ведут себя так, как будто у них есть свойство, которого на самом деле нет, если это свойство есть у прототипа. Прототипом простых объектов является `Object.prototype`.

Конструкторы,– функции, имена которых обычно начинаются с заглавной буквы,– можно использовать с оператором `new` для создания объектов. Прототипом нового объекта будет объект, содержащийся в свойстве `prototype` конструктора. Это можно использовать, помещая свойства, которые делят между собой все величины данного типа, в их прототип. Оператор `instanceof`, если ему дать объект и конструктор, может сказать, является ли объект экземпляром этого конструктора.

Для объектов можно сделать интерфейс и сказать всем, чтобы они общались с объектом только через этот интерфейс. Остальные детали реализации объекта теперь _инкапсулированы_, скрыты за интерфейсом.

А после этого никто не запрещал использовать разные объекты при помощи одинаковых интерфейсов. Если разные объекты имеют одинаковые интерфейсы, то и код, работающий с ними, может работать с разными объектами одинаково. Это называется _полиморфизмом_, и это очень полезная штука.

Определяя несколько типов, различающихся только в мелких деталях, бывает удобно просто наследовать прототип нового типа от прототипа старого типа, чтобы новый конструктор вызывал старый. Это даёт вам тип объекта, сходный со старым, но при этом к нему можно добавлять свойства или переопределять старые.

== Упражнения ==

[[exercise_vector]]
=== Векторный тип ===

(((dimensions)))(((Vector type)))(((coordinates)))(((vector (exercise))))Напишите ((конструктор)) `Vector`, представляющий вектор в двумерном пространстве. Он принимает параметры `x` и `y` (числа), которые хранятся в одноимённых свойствах.

(((addition)))(((subtraction)))Дайте прототипу `Vector` два метода, `plus` и `minus`, которые принимают другой вектор в качестве параметра, и возвращают новый вектор, который хранит в _x_ и _y_ сумму или разность двух (один `this`, второй — аргумент).

Добавьте ((геттер)) `length` в прототип, подсчитывающий длину вектора – расстояние от (0, 0) до (_x_, _y_).

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Ваш код.

console.log(new Vector(1, 2).plus(new Vector(2, 3)));
// → Vector{x: 3, y: 5}
console.log(new Vector(1, 2).minus(new Vector(2, 3)));
// → Vector{x: -1, y: -1}
console.log(new Vector(3, 4).length);
// → 5
----
endif::interactive_target[]

!!hint!!

(((vector (exercise))))Your solution can follow the pattern of the
`Rabbit` constructor from this chapter quite closely.

(((Pythagoras)))(((defineProperty function)))(((square
root)))(((Math.sqrt function)))Adding a getter property to the
constructor can be done with the `Object.defineProperty` function. To
compute the distance from (0, 0) to (x, y), you can use the
Pythagorean theorem, which says that the square of the distance we are
looking for is equal to the square of the x-coordinate plus the square
of the y-coordinate. Thus, (!html √(x^2^ + y^2^pass:[)]!)(!tex pass:[$\sqrt{x^2 + y^2}$]!)
is the number you want, and `Math.sqrt` is the way you compute a square
root in JavaScript.

!!hint!!

=== Ещё одна ячейка ===

(((StretchCell (exercise))))(((interface)))Создайте тип ячейки `StretchCell(inner, width, height)`, соответствующий link:06_object.html#table_interface[интерфейсу ячеек таблицы] из этой главы. Он должен оборачивать другую ячейку (как делает `UnderlinedCell`), и убеждаться, что результирующая ячейка имеет как минимум заданные ширину и высоту, даже если внутренняя ячейка была бы меньше.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Ваш код.

var sc = new StretchCell(new TextCell("abc"), 1, 2);
console.log(sc.minWidth());
// → 3
console.log(sc.minHeight());
// → 2
console.log(sc.draw(3, 2));
// → ["abc", "   "]
----

endif::interactive_target[]

!!hint!!

(((StretchCell (exercise))))You'll have to store all three constructor
arguments in the instance object. The `minWidth` and `minHeight`
methods should call through to the corresponding methods in the
`inner` cell but ensure that no number less than the given size is
returned (possibly using `Math.max`).

Don't forget to add a `draw` method that simply forwards the call to
the inner cell.

!!hint!!

=== Интерфейс к последовательностям ===

(((sequence (exercise))))Разработайте _((интерфейс))_, абстрагирующий ((проход)) по ((набору)) значений. Объект с таким интерфейсом представляет собой последовательность, а интерфейс должен давать возможность в коде проходить по последовательности, работать со значениями, которые её составляют, и как-то сигнализировать о том, что мы достигли конца последовательности.

Задав интерфейс, попробуйте сделать функцию `logFive`, которая принимает объект-последовательность и вызывает `console.log` для первых её пяти элементов – или для меньшего количества, если их меньше пяти.

Затем создайте тип объекта `ArraySeq`, оборачивающий массив, и позволяющий проход по массиву с использованием разработанного вами интерфейса. Создайте другой тип объекта, `RangeSeq`, который проходит по диапазону чисел (его конструктор должен принимать аргументы `from` и `to`).

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Ваш код.

logFive(new ArraySeq([1, 2]));
// → 1
// → 2
logFive(new RangeSeq(100, 1000));
// → 100
// → 101
// → 102
// → 103
// → 104
----

endif::interactive_target[]

!!hint!!

(((sequence (exercise))))(((collection)))One way to solve this is to
give the sequence objects _((state))_, meaning their properties are
changed in the process of using them. You could store a counter that
indicates how far the sequence object has advanced.

Your ((interface)) will need to expose at least a way to get the next
element and to find out whether the iteration has reached the end of
the sequence yet. It is tempting to roll these into one method,
`next`, which returns `null` or `undefined` when the sequence is at
its end. But now you have a problem when a sequence actually contains
`null`. So a separate method (or getter property) to find out whether
the end has been reached is probably preferable.

(((mutation)))(((pure function)))(((efficiency)))Another solution is
to avoid changing state in the object. You can expose a method for
getting the current element (without advancing any counter) and
another for getting a new sequence that represents the remaining
elements after the current one (or a special value if the end of the
sequence is reached). This is quite elegant—a sequence value will
“stay itself” even after it is used and can thus be shared with other
code without worrying about what might happen to it. It is,
unfortunately, also somewhat inefficient in a language like
JavaScript because it involves creating a lot of objects during
iteration.

!!hint!!
