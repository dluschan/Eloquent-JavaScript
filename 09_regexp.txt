:chap_num: 9
:prev_link: 08_error
:next_link: 10_modules

= Регулярные выражения =

[chapterquote="true"]
[quote,Джейми Завински]
____
Некоторые люди, столкнувшись с проблемой, думают: «О, а использую-ка я регулярные выражения». Теперь у них есть две проблемы.
____

ifdef::interactive_target[]

[chapterquote="true"]
[quote, Мастер Юан-Ма, Книга программирования]
____
Юан-Ма сказал: «Требуется большая сила, чтобы резать дерево поперёк структуры древесины. Требуется много кода, чтобы программировать поперёк структуры проблемы.»
____

endif::interactive_target[]

(((Zawinski+++,+++ Jamie)))(((evolution)))(((adoption)))(((integration)))((Инструмент))ы и техники программирования выживают и распространяются хаотично-эволюционным способом. Иногда выживают не красивые и гениальные, а просто такие, которые достаточно хорошо работают в своей области – к примеру, если их интегрируют в другую успешную технологию.

(((domain-specific language)))В этой главе мы обсудим такой инструмент – _((регулярные выражения))_. Это способ описывать ((шаблон))ы в строковых данных. Они создают небольшой отдельный язык, который входит в JavaScript и во множество других языков и инструментов.

(((interface,design)))Регулярки одновременно очень странные и крайне полезные. Их синтаксис загадочен, а программный ((интерфейс)) в JavaScript для них неуклюж. Но это мощный ((инструмент)) для исследования и обработки строк. Разобравшись с ними, вы станете более эффективным программистом.

== Создаём регулярное выражение ==

(((regular expression,creation)))(((RegExp constructor)))(((literal expression)))(((slash character)))Регулярка – тип объекта. Её можно создать, вызвав конструктор `RegExp`, или написав нужный шаблон, окружённый слешами.

[source,javascript]
----
var re1 = new RegExp("abc");
var re2 = /abc/;
----

Оба этих регулярных выражения представляют один ((шаблон)): символ _a_, за которым следует символ _b_, за которым следует символ _c_.

(((backslash character)))(((RegExp constructor)))Если вы используете конструктор `RegExp`, тогда шаблон записывается как обычная строка, поэтому действуют все правила относительно обратных слешей.

(((regular expression,escaping)))(((escaping,in regexps)))(((slash character)))Вторая запись, где шаблон находится между слешами, обрабатывает обратные слеши по-другому. Во-первых, так как шаблон заканчивается прямым слешем, то нужно ставить обратный слеш перед прямым слешем, который мы хотим включить в наш шаблон. Кроме того, обратные слеши, не являющиеся частью специальных символов типа `\n`, будут _сохранены_ (а не проигнорированы, как в строках), и изменят смысл шаблона. У некоторых символов, таких, как знак вопроса или плюс, есть особое значение в регулярках, и если вам нужно найти такой символ, его также надо предварять обратным слешем.

[source,javascript]
----
var eighteenPlus = /eighteen\+/;
----

Чтобы знать, какие символы надо предварять слешем, вам надо выучить список всех специальных символов в регулярках. Пока это нереально, поэтому в случае сомнений просто ставьте обратный слеш перед любым символом, не являющимся буквой, числом или ((пробел))ом.

== Проверяем на совпадения ==

(((matching)))(((test method)))(((regular expression,methods)))У регулярок есть несколько методов. Простейший – `test`. Если передать ему строку, он вернёт ((булевское)) значение, сообщая, содержит ли строка вхождение заданного шаблона.

[source,javascript]
----
console.log(/abc/.test("abcde"));
// → true
console.log(/abc/.test("abxde"));
// → false
----

(((pattern)))((Регулярка)), состоящая только из неспециальных символов, просто представляет собой последовательность этих символов. Если _abc_ есть где-то в строке, которую мы проверяем (не только в начале), `test` вернёт `true`.

== Ищем набор символов ==

(((regular expression)))(((indexOf method)))Выяснить, содержит ли строка _abc_, можно было бы и при помощи `indexOf`. Регулярки позволяют пройти дальше и составлять более сложные ((шаблон))ы.

Допустим, нам надо найти любой ((номер)). Когда мы в регулярке помещаем ((набор)) символов в квадратные скобки, это означает, что эта часть выражения совпадает с любым из символов в скобках.

Оба выражения находятся в строчках, содержащих ((цифру)):

[source,javascript]
----
console.log(/[0123456789]/.test("in 1992"));
// → true
console.log(/[0-9]/.test("in 1992"));
// → true
----

(((dash character)))В квадратных скобках тире между двумя символами используется для задания ((диапазон))а символов, где последовательность задаётся кодировкой ((Unicode)). Символы от 0 до 9 находятся там просто подряд (коды с 48 до 57), поэтому `[0-9]` захватывает их все и совпадает с любой ((цифрой)).

(((whitespace)))(((alphanumeric character)))(((period character)))У нескольких групп символов есть свои встроенные сокращения.

[cols="1,5"]
|====
|`\d`      |Любая ((цифра))
|`\w`      |Алфавитно-цифровой символ
|`\s`      |Пробельный символ (пробел, табуляция, перевод строки, и т.п.)
|`\D`      |_Не_ цифра
|`\W`      |_Не_ алфавитно-цифровой символ
|`\S`      |_Не_ пробельный символ
|`.`       |Любой символ, кроме перевода строки
|====

Таким образом можно задать формат ((даты)) и ((времени)) вроде 30-01-2003 15:20 следующим выражением:

[source,javascript]
----
var dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(dateTime.test("30-01-2003 15:20"));
// → true
console.log(dateTime.test("30-jan-2003 15:20"));
// → false
----

(((backslash character)))Выглядит ужасно, не так ли? Слишком много обратных слешей, которые затрудняют понимание ((шаблон))а. link:09_regexp.html#date_regexp_counted[Позже] мы слегка улучшим его.

(((escaping,in regexps)))(((regular expression)))(((set)))Обратные слеши можно использовать и в ((квадратных скобках)). Например, `[\d.]` означает любую цифру или точку. Заметьте, что точка внутри квадратных скобок теряет своё особое значение и превращается просто в точку. То же касается и других специальных символов, типа `+`.

(((square brackets)))(((inversion)))(((caret character)))_Инвертировать_ набор символов – то есть, сказать, что вам надо найти любой символ, _кроме_ тех, что есть в наборе – можно, поставив знак `^` (“карет”) сразу после открывающей квадратной скобки.

[source,javascript]
----
var notBinary = /[^01]/;
console.log(notBinary.test("1100100010100110"));
// → false
console.log(notBinary.test("1100100010200110"));
// → true
----

== Повторяем части шаблона ==

(((regular expression,repetition)))Мы знаем, как найти одну цифру. А если нам надо найти число целиком – ((последовательность)) из одной или более ((цифр))?

(((plus character)))(((repetition)))(((+ operator)))Если поставить после чего-либо в регулярке знак `+`, это будет означать, что этот элемент может быть повторён более одного раза. `/\d+/` означает одну или несколько цифр.

[source,javascript]
----
console.log(/'\d+'/.test("'123'"));
// → true
console.log(/'\d+'/.test("''"));
// → false
console.log(/'\d*'/.test("'123'"));
// → true
console.log(/'\d*'/.test("''"));
// → true
----

(((pass:[*] operator)))(((asterisk)))У звёздочки `*` значение почти такое же, но она разрешает шаблону присутствовать ноль раз. Если после чего-то стоит звёздочка, то оно никогда не препятствует нахождению шаблона в строке – оно просто находится там ноль раз.

(((British English)))(((American English)))(((question mark)))Знак вопроса делает часть шаблона необязательной, то есть она может встретиться ноль или один раз. В следующем примере символ _u_ может встречаться, но шаблон совпадает и тогда, когда его нет.

[source,javascript]
----
var neighbor = /neighbou?r/;
console.log(neighbor.test("neighbour"));
// → true
console.log(neighbor.test("neighbor"));
// → true
----

(((repetition)))(((curly braces)))Чтобы задать точное количество раз, которое шаблон должен встретиться, используются фигурные скобки. `{4}` после элемента означает, что он должен встретиться в строке 4 раза. Также можно задать ((промежуток)): `{2,4}` означает, что элемент должен встретиться не менее 2 и не более 4 раз.

[[date_regexp_counted]]
Ещё одна версия формата ((даты)) и ((времени)), где разрешены дни, месяцы и часы из одной или двух ((цифр)). И ещё она чуть более читаема.

[source,javascript]
----
var dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(dateTime.test("30-1-2003 8:45"));
// → true
----

Можно использовать ((промежутки)) с открытым концом, опуская одно из чисел. `{,5}` означает, что шаблон может встретиться от нуля до пяти раз, а `{5,}` – от пяти и более.

== Группировка подвыражений ==

(((regular expression,grouping)))(((grouping)))Чтобы использовать операторы `*` или `+` на нескольких элементах сразу, можно использовать ((круглые скобки)). Часть регулярки, заключённая в скобки, считается одним элементом с точки зрения операторов.

[source,javascript]
----
var cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test("Boohoooohoohooo"));
// → true
----

(((crying)))Первый и второй плюсы относятся только ко вторым буквам _o_ в словах _boo_ и _hoo_. Третий `+` относится к целой группе `(hoo+)`, находя одну или несколько таких последовательностей.

(((case sensitivity)))(((capitalization)))(((regular expression,flags)))Буква `i` в конце выражения делает регулярку нечувствительной к регистру симолов – так, что _B_ совпадает с _b_.

== Совпадения и группы ==

(((regular expression,grouping)))(((exec method)))(((array)))Метод `test` – самый простой метод проверки регулярок. Он только сообщает, было ли найдено совпадение, или нет. У регулярок есть ещё метод `exec`, который вернёт `null`, если ничего не было найдено, а в противном случае вернёт объект с информацией о совпадении.

[source,javascript]
----
var match = /\d+/.exec("one two 100");
console.log(match);
// → ["100"]
console.log(match.index);
// → 8
----

(((index property)))(((string,indexing)))У возвращаемого `exec` объекта есть свойство `index`, _где_ содержится номер символа, с которого случилось совпадение. А вообще объект выглядит как массив строк, где первый элемент – строка, которая была подобрана. В нашем примере это будет последовательность ((цифр)), которую мы искали.

(((string,methods)))(((match method)))У строк есть метод `match`, работающий примерно так же.

[source,javascript]
----
console.log("one two 100".match(/\d+/));
// → ["100"]
----

(((grouping)))(((capture group)))(((exec method)))Когда в регулярке содержатся подвыражения, сгруппированные круглыми скобками, текст, совпавший с этими группами, тоже появится в массиве. Первый элемент – всегда совпадение целиком. Второй – часть, совпавшая с первой группой (той, у кого круглые скобки встретились раньше всех), затем со второй группой, и так далее.

[source,javascript]
----
var quotedText = /'([^']*)'/;
console.log(quotedText.exec("she said 'hello'"));
// → ["'hello'", "hello"]
----

(((capture group)))Когда группа не найдена вообще (например, если за ней стоит знак вопроса), её позиция в массиве содержит undefined. Если группа совпала несколько раз, то в массиве будет только последнее совпадение.

[source,javascript]
----
console.log(/bad(ly)?/.exec("bad"));
// → ["bad", undefined]
console.log(/(\d)+/.exec("123"));
// → ["123", "3"]
----

(((exec method)))(((regular expression,methods)))(((extraction)))Группы полезны для извлечения частей строк. Если нам не просто надо проверить, есть ли в строке ((дата)), а извлечь её и создать представляющий дату объект, мы можем заключить последовательности цифр в круглые скобки и выбрать дату из результата `exec`.

Но для начала небольшое отступление, в котором мы узнаем предпочтительный способ хранения даты и ((времени)) в JavaScript.

== Тип даты ==

(((constructor)))(((Date constructor)))В JavaScript есть стандартный тип объекта для ((дат)) – а точнее, моментов во ((времени)). Он называется `Date`. Если просто создать объект даты через `new`, вы получите текущие дату и ремя.

// test: no

[source,javascript]
----
console.log(new Date());
// → Wed Dec 04 2013 14:24:57 GMT+0100 (CET)
----

(((Date constructor)))Также можно создать объект, содержащий заданное время

[source,javascript]
----
console.log(new Date(2009, 11, 9));
// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)
console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)
----

(((zero-based counting)))(((interface,design)))JavaScript использует соглашение, в котором номера месяцев начинаются с нуля, а номера дней – с единицы. Это глупо и нелепо. Поберегитесь.

Последние четыре аргумента (часы, минуты, секунды и миллисекунды) необязательны, и в случае отсутствия приравниваются к нулю.

(((getTime method)))Метки времени хранятся как количество миллисекунд, прошедших с начала 1970 года. Для времени до 1970 года используются отрицательные числа (это связано с соглашением по “((Unix time))”, которое было создано примерно в то время). Метод `getTime` объекта даты возвращает это число. Оно, естественно, большое.

[source,javascript]
----
console.log(new Date(2013, 11, 19).getTime());
// → 1387407600000
console.log(new Date(1387407600000));
// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)
----

(((Date.now function)))(((Date constructor)))Если задать конструктору `Date` один аргумент, он воспринимается как это количество миллисекунд. Можно получить текущее значение миллисекунд, создав объект `Date` и вызвав метод `getTime`, или же вызвав функцию `Date.now`.

(((getFullYear method)))(((getMonth method)))(((getDate method)))(((getHours method)))(((getMinutes method)))(((getSeconds method)))(((getYear method)))У объекта `Date` для извлечения его компонентов есть методы `getFullYear`, `getMonth`, `getDate`, `getHours`, `getMinutes`, и `getSeconds`. Есть также метод `getYear`, возвращающий довольно бесполезный двузначный код, типа `93` или `14`.

(((capture group)))Заключив нужные части шаблона в круглые скобки, мы можем создать объект даты прямо из строки.

[source,javascript]
----
function findDate(string) {
  var dateTime = /(\d{1,2})-(\d{1,2})-(\d{4})/;
  var match = dateTime.exec(string);
  return new Date(Number(match[3]),
                  Number(match[2]) - 1,
                  Number(match[1]));
}
console.log(findDate("30-1-2003"));
// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)
----

== Границы слова и строки ==

(((matching)))(((regular expression,boundary)))К сожалению, `findDate` так же радостно извлечёт бессмысленную дату 00-1-3000 из строки `"100-1-30000"`. Совпадение может случиться в любом месте строки, так что в данном случае он просто начнёт со второго символа и закончит на предпоследнем.

(((boundary)))(((caret character)))(((dollar sign)))Если нам надо принудить совпадение взять всю строку целиком, мы используем метки `^` и `$`. `^` совпадает с началом строки, а `$` с концом. Поэтому `/^\d+$/` совпадает со строкой, состоящей только из одной или нескольких цифр, `/^!/` совпадает со сторокой, начинающейся с восклицательного знака, а `/x^/` не совпадает ни с какой строчкой (перед началом строки не может быть _x_).

(((word boundary)))(((word character)))Если, с другой стороны, нам просто надо убедиться, что дата начинается и заканчивается на границе слова, мы используем метку `\b`. Границей слова может быть начало или конец строки, или любое место строки, где с одной стороны стоит алфавитно-цифровой символ `\w`, а с другой – не алфавитно-цифровой.

[source,javascript]
----
console.log(/cat/.test("concatenate"));
// → true
console.log(/\bcat\b/.test("concatenate"));
// → false
----

(((matching)))Отметим, что метка границы не представляет из себя символ. Это просто ограничение, обозначающее, что совпадение происходит только если выполняется определённое условие.

== Шаблоны с выбором ==

(((branching)))(((regular expression,alternatives)))(((farm example)))Допустим, надо выяснить, содержит ли текст не просто номер, а номер, за которым следует _pig_, _cow_, или _chicken_ в единственном или множественном числе.

Можно было бы написать три регулярки и проверить их по очереди, но есть способ лучше. Символ `|` обозначает ((выбор)) между шаблонами слева и справа от него. И можно сказать следующее:

[source,javascript]
----
var animalCount = /\b\d+ (pig|cow|chicken)s?\b/;
console.log(animalCount.test("15 pigs"));
// → true
console.log(animalCount.test("15 pigchickens"));
// → false
----

(((parentheses)))Скобки ограничивают часть шаблона, к которой применяется `|`, и можно поставить много таких операторов друг за другом, чтобы обозначить выбор из более чем двух вариантов.

== Механизм поиска ==

(((regular expression,matching)))(((matching,algorithm)))Регулярные выражения можно рассматривать как ((блок-схемы)). Следующая диаграмма описывает последний животноводческий пример.

image::img/re_pigchickens.svg[alt="Visualization of /\\b\\d+ (pig|cow|chicken)s?\\b/"]

(((traversal)))Выражение совпадает со строкой, если можно найти путь с левой части диаграммы в правую. Мы запоминаем текущее положение в строке, и каждый раз, проходя прямоугольник, проверяем, что часть строки сразу за нашим положением в ней совпадает с содержимым прямоугольника.

Значит, проверка совпадения нашей регулярки в строке `"the 3 pigs"` при прохождении по блок-схеме выглядит так:

 - На позиции 4 есть ((граница)) слова, и проходим первый прямоугольник.

 - Начиная с 4 позиции находим цифру, и проходим второй прямоугольник.

 - На позиции 5 один путь замыкается назад перед вторым прямоугольником, а второй проходит далее к прямоугольнику с пробелом. У нас пробел, а не цифра, и мы выбираем второй путь.

 - Теперь мы на позиции 6, начало “pigs”, и на тройном разветвлении путей. В строке нет “cow” или “chicken”, зато есть “pig”, поэтому мы выбираем этот путь.

 - На позиции 9 после тройного разветвления, один путь обходит _s_ и направляется к последнему прямоугольнику с границей слова, а второй проходит через _s_. У нас есть _s_, поэтому мы идём туда.

 - На позиции 10 мы в конце строки, и совпасть может только ((граница)) слова. Конец строки считается границей, и мы проходим через последний прямоугольник. И вот мы успешно нашли наш шаблон.

(((regular expression,matching)))(((matching,algorithm)))(((searching)))В принципе, работают регулярные выражения следующим образом: алгоритм начинает в начале строки и пытается найти совпадение там. В нашем случае там _есть_ граница слова, поэтому он проходит первый прямоугольник – но там нет цифры, поэтому на втором прямоугольнике он спотыкается. Потом он двигается ко второму символу в строке, и пытается найти совпадение там... И так далее, пока он не находит совпадение или не доходит до конца строки, в таком случае совпадение на найдено.

[[backtracking]]
== Откаты ==

(((regular expression,backtracking)))(((binary number)))(((decimal number)))(((hexadecimal number)))(((flow diagram)))(((matching,algorithm)))(((backtracking)))Регулярка `/\b([01]+b|\d+|[\da-f]h)\b/` совпадает либо с двоичным числом, за которым следует _b_, либо с десятичным числом без суффикса, либо шестнадцатеричным (цифры от 0 до 9 или символы от _a_ до _h_), за которым идёт _h_. Соответствующая диаграмма:

image::img/re_number.svg[alt="Visualization of /\\b([01]+b|\\d+|[\\da-f]+h)\\b/"]

(((branching)))В поисках совпадения может случиться, что алгоритм пошёл по верхнему пути (двоичное число), даже если в строке нет такого числа. Если там есть строка `"103"`, к примеру, понятно, что только достигнув цифры 3 алгоритм поймёт, что он на неправильном пути. Вообще строка _совпадает_ с регуляркой, просто не в этой ветке.

(((backtracking)))(((searching)))Тогда алгоритм совершает _откат_. На развилке он запоминает текущее положение (в нашем случае, это начало строки, сразу после границы слова), чтобы можно было вернуться назад и попробовать другой путь, если выбранный не срабатывает. Для строки `"103"` после встречи с тройкой он вернётся и попытается пройти путь для десятичных чисел. Это сработает, поэтому совпадение будет найдено.

(((matching,algorithm)))Алгоритм останавливается, как только найдёт полное совпадение. Это значит, что даже если несколько вариантов могут подойти, используется только один из них (в том порядке, в каком они появляются в регулярке).

Откаты случаются при использовании операторов ((повторения)), таких, как `+` и `*`. Если вы ищете `/^.*x/` в строке `"abcxe"`, часть регулярки `.*` попробует поглотить всю строчку. Алгоритм затем сообразит, что ему нужен ещё и _x_. Так как никакого _x_ после конца строки нет, алгоритм попробует поискать совпадение, откатившись на один символ. После `abcx` тоже нет _x_, тогда он снова откатывается, уже к подстроке `abc`. И после неё он находит _x_ и докладывает об успешном совпадении, на позициях с 0 по 4.

(((performance)))(((complexity)))Можно написать регулярку, которая приведёт ко _множественным_ откатам. Такая проблема возникает, когда шаблон может совпасть с входными данными множеством разных способов. Например, если мы ошибёмся при написании регулярки для двоичных чисел, мы можем случайно написать что-то вроде `/([01]+)+b/`.

image::img/re_slow.svg[alt="Visualization of /([01]+)+b/",width="6cm"]

(((inner loop)))(((nesting,in regexps)))Если алгоритм будет искать такой шаблон в длинной строке из нолей и единиц, не содержащей в конце _b_, он сначала пройдёт по внутренней петле, пока у него не кончатся цифры. Тогда он заметит, что в конце нет _b_, сделает откат на одну позицию, пройдёт по внешней петле, опять сдастся, попытается откатиться на ещё одну позицию по внутренней петле... И будет дальше искать таким образом, задействуя обе петли. То есть, количество работы с каждым символом строки будет _удваиваться_. Даже для нескольких десятков символов поиск совпадения займёт очень долгое время.

== Метод replace ==

(((replace method)))(((regular expression)))У строк есть метод `replace`, который может заменять часть строки другой строкой.

[source,javascript]
----
console.log("папа".replace("п", "м"));
// → мапа
----

(((regular expression,flags)))(((regular expression,global)))Первый аргумент может быть и регулярным выражением, в таком случае заменяется первое вхождение регулярки в строке. Когда к регулярке добавляется опция `g` (_global_, _всеобщий_), заменяются _все_ вхождения, а не только первое.

[source,javascript]
----
console.log("Borobudur".replace(/[ou]/, "a"));
// → Barobudur
console.log("Borobudur".replace(/[ou]/g, "a"));
// → Barabadar
----

(((interface,design)))(((argument)))Имело бы смысл передавать опцию “заменить всё” через отдельный аргумент, или через отдельный метод типа `replaceAll`. Но к сожалению, опция передаётся через саму регулярку.

(((grouping)))(((capture group)))(((dollar sign)))(((replace method)))(((regular expression,grouping)))Вся сила регулярок с `replace` раскрывается, когда мы используем ссылки на найденные в строке группы, заданные в регулярке. Например, у нас есть строка, содержащая имена людей, одно имя на строчку, в формате `Фамилия, Имя`. Если нам надо поменять их местами и убрать запятую, чтобы получилось `Имя Фамилия`, мы пишем следующее:

[source,javascript]
----
console.log(
  "Hopper, Grace\nMcCarthy, John\nRitchie, Dennis"
    .replace(/([\w ]+), ([\w ]+)/g, "$2 $1"));
// → Grace Hopper
//   John McCarthy
//   Dennis Ritchie
----

`$1` и `$2` в строчке на замену ссылаются на группы символов, заключённые в скобки. `$1` заменяется текстом, который совпал с первой группой, `$2` – со второй группой, и так далее, до `$9`. Всё совпадение целиком содержится в переменной `$&`.

(((function,higher-order)))(((grouping)))(((capture group)))Также можно в качестве второго аргумента `replace` передавать и функцию. Для каждой замены будет вызвана функция, аргументами которой будут найденные группы (и вся совпадающая часть строки целиком), а её результат будет вставлен в новую строку.

Простой пример:

[source,javascript]
----
var s = "the cia and fbi";
console.log(s.replace(/\b(fbi|cia)\b/g, function(str) {
  return str.toUpperCase();
}));
// → the CIA and FBI
----

А вот более интересный:

[source,javascript]
----
var stock = "1 lemon, 2 cabbages, and 101 eggs";
function minusOne(match, amount, unit) {
  amount = Number(amount) - 1;
  if (amount == 1) // only one left, remove the 's'
    unit = unit.slice(0, unit.length - 1);
  else if (amount == 0)
    amount = "no";
  return amount + " " + unit;
}
console.log(stock.replace(/(\d+) (\w+)/g, minusOne));
// → no lemon, 1 cabbage, and 100 eggs
----

Код принимает строку, находит все вхождения чисел, за которыми идёт слово, и возвращает строчку, где каждое число уменьшено на единицу.

Группа `(\d+)` попадает в аргумент `amount`, а `(\w+)` – в `unit`. Функция преобразовывает `amount` в число – и это всегда срабатывает, потому что наш шаблон как раз `\d+`. И затем вносит изменения в слово, на случай если остался всего 1 предмет или их не осталось вовсе.

== Жадность ==

(((greed)))(((regular expression)))Несложно при помощи `replace` написать функцию, убирающую все ((комментарии)) из ((код))а JavaScript. Вот первая попытка:

// test: wrap

[source,javascript]
----
function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*\*\//g, "");
}
console.log(stripComments("1 + /* 2 */3"));
// → 1 + 3
console.log(stripComments("x = 10;// ten!"));
// → x = 10;
console.log(stripComments("1 /* a */+/* b */ 1"));
// → 1  1
----

(((period character)))(((slash character)))(((newline character)))(((empty set)))(((block comment)))(((line comment)))Часть перед оператором _или_ совпадает с двумя слешами, за которыми идут любое количество символов, кроме символов перевода строки. Часть, убирающая многострочные комментарии, более сложна. Мы используем `[^]`, т.е. любой символ, не являющийся пустым, в качестве способа найти любой символ. Мы не можем использовать точку, потому что блочные комментарии продолжаются и на новой строке, а символ перевода строки не совпадает с точкой.

Но вывод предыдущего примера неправильный. Почему?

(((backtracking)))(((greed)))(((regular expression)))Часть `[^]*` сначала попытается захватить столько символов, сколько может. Если из-за этого следующая часть регулярки не найдёт себе совпадения, произойдёт откат на один символ и попробует снова. В примере, алгоритм пытается захватить всю строку, и затем откатывается. Откатившись на 4 символа назад, он найдёт в строчке `*/` — а это не то, чего мы добивались. Мы-то хотели захватить только один комментарий, а не пройти до конца строки и найти последний комментарий.

Из-за этого мы говорим, что операторы повторения (`+`, `*`, `?`, and `{}`) _((жадные))_, то есть они сначала захватывают, сколько могут, а потом идут назад. Если вы поместите ((вопрос)) после такого оператора (`+?`, `*?`, `??`, `{}?`), они превратятся в нежадных, и начнут находить самые маленькие из возможных вхождений.

И это то, что нам нужно. Заставив звёздочку находить совпадения в минимально возможном количестве символов строчки, мы поглощаем только один блок комментариев, и не более того.

// test: wrap

[source,javascript]
----
function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
}
console.log(stripComments("1 /* a */+/* b */ 1"));
// → 1 + 1
----

Множество ((баг))ов возникает при использовании жадных операторов вместо нежадных. При использовании оператора ((повтора)) сначала всегда рассматривайте вариант нежадного оператора.

== Динамическое создание объектов RegExp ==

(((regular expression,creation)))(((underscore character)))(((RegExp constructor)))В некоторых случаях точный ((шаблон)) неизвестен во время написания кода. Например, вам надо будет искать имя пользователя в тексте, и заключать его в подчёркивания. Так как вы узнаете имя только после запуска программы, вы не можете использовать запись со слешами.

Но вы можете построить строку и использовать ((конструктор)) `RegExp`. Вот пример:

[source,javascript]
----
var name = "гарри";
var text = "А у Гарри на лбу шрам.";
var regexp = new RegExp("\\b(" + name + ")\\b", "gi");
console.log(text.replace(regexp, "_$1_"));
// → А у _Гарри_ на лбу шрам.
----

(((regular expression,flags)))(((backslash character)))При создании ((границ)) слова приходится использовать двойные слеши, потому что мы пишем их в нормальной строке, а не в регулярке с прямыми слешами. Второй аргумент для `RegExp` содержит опции для регулярок – в нашем случае `"gi"`, т.е. глобальный и регистро-независимый.

Но что, если имя будет `"dea+hl[]rd"` (если наш пользователь – кульхацкер)? В результате мы получим бессмысленную регулярку, которая не найдёт в строке совпадений.

(((backslash character)))(((escaping,in regexps)))(((regular expression,escaping)))Мы можем добавить обратных слешей перед любым символом, который нам не нравится. Мы не можем добавлять обратные слеши перед буквами, потому что `\b` или `\n` – это спецсимволы. Но добавлять слеши перед любыми не алфавитно-цифровыми символами или ((пробелами)) можно без проблем.

[source,javascript]
----
var name = "dea+hl[]rd";
var text = "Этот dea+hl[]rd всех достал.";
var escaped = name.replace(/[^\w\s]/g, "\\$&");
var regexp = new RegExp("\\b(" + escaped + ")\\b", "gi");
console.log(text.replace(regexp, "_$1_"));
// → Этот _dea+hl[]rd_ всех достал.
----

== Метод search ==

(((searching)))(((regular expression,methods)))(((indexOf method)))(((search method)))Метод `indexOf` нельзя использовать с регулярками. Зато есть метод `search`, который как раз ожидает регулярку. Как и `indexOf`, он возвращает индекс первого вхождения, или -1, если его не случилось.

[source,javascript]
----
console.log("  word".search(/\S/));
// → 2
console.log("    ".search(/\S/));
// → -1
----

К сожалению, никак нельзя задать, чтобы метод искал совпадение, начиная с конкретного смещения (как это можно сделать с `indexOf`). Это было бы полезно.

== Свойство lastIndex ==

(((exec method)))(((regular expression)))Метод `exec` тоже не даёт удобного способа начать поиск с заданной позиции в строке. Но __не__удобный способ даёт.

(((regular expression,matching)))(((matching)))(((source property)))(((lastIndex property)))У объекта регулярок есть свойства. Одно из них – `source`, содержащее строку. Ещё одно – `lastIndex`, контролирующее, в некоторых условиях, где начнётся следующий поиск вхождений.

(((interface,design)))(((exec method)))(((regular expression,global)))Эти условия включают необходимость присутствия глобальной опции `g`, и то, что поиск должен идти с применением метода `exec`. Более разумным решением было бы просто допустить дополнительный аргумент для передачи в `exec`, но разумность – не основополагающая черта в интерфейсе регулярок JavaScript.

[source,javascript]
----
var pattern = /y/g;
pattern.lastIndex = 3;
var match = pattern.exec("xyzzy");
console.log(match.index);
// → 4
console.log(pattern.lastIndex);
// → 5
----

(((side effect)))(((lastIndex property)))Если поиск был успешным, вызов `exec` обновляет свойство `lastIndex`, чтоб оно указывало на позицию после найденного вхождения. Если успеха не было, `lastIndex` устанавливается в ноль – как и `lastIndex` у только что созданного объекта.

(((bug)))При использовании глобальной переменной-регулярки и нескольких вызовов `exec` эти автоматические обновления `lastIndex` могут привести к проблемам. Ваша регулярка может начать поиск с позиции, оставшейся с предыдущего вызова.

[source,javascript]
----
var digit = /\d/g;
console.log(digit.exec("here it is: 1"));
// → ["1"]
console.log(digit.exec("and now: 1"));
// → null
----

(((regular expression,global)))(((match method)))Ещё один интересный эффект опции `g` в том, что она меняет работу метода `match`. Когда он вызывается с этой опцией, вместо возврата массива, похожего на результат работы `exec`, он находит _все_ вхождения шаблона в строке и возвращает массив из найденных подстрок.

[source,javascript]
----
console.log("Банан".match(/ан/g));
// → ["ан", "ан"]
----

Так что поосторожнее с глобальными переменными-регулярками. В случаях, когда они необходимы – вызовы `replace` или места, где вы специально используете `lastIndex` – пожалуй и все случаи, в которых их следует применять.

=== Циклы по вхождениям ===

(((lastIndex property)))(((exec method)))(((loop)))Типичная задача – пройти по всем вхождениям шаблона в строку так, чтобы иметь доступ к объекту `match` в теле цикла, используя `lastIndex` и `exec`.

[source,javascript]
----
var input = "A string with 3 numbers in it... 42 and 88.";
var number = /\b(\d+)\b/g;
var match;
while (match = number.exec(input))
  console.log("Found", match[1], "at", match.index);
// → Found 3 at 14
//   Found 42 at 33
//   Found 88 at 40
----

(((while loop)))(((= operator)))Используется тот факт, что значением ((присвоения)) является присваиваемое значение. Используя конструкцию `match = re.exec(input)` в качестве условия в цикле `while`, мы производим поиск в начале каждой итерации, сохраняем результат в ((переменной)), и заканчиваем цикл, когда все совпадения найдены.

[[ini]]
== Разбор INI файла ==

(((comment)))(((file format)))(((enemies example)))(((ini file)))В заключение главы рассмотрим задачу с использованием ((регулярных выражений)). Представьте, что мы пишем программу, собирающую сведения о наших врагах через ((интернет)) в автоматическом режиме. (Всю программу писать не будем, только ту часть, которая читает файл с настройками. Извините.) Файл выглядит так:

[source,text/plain]
----
searchengine=http://www.google.com/search?q=$1
spitefulness=9.7

; перед комментариями ставится точка с запятой
; каждая секция относится к отдельному врагу
[larry]
fullname=Larry Doe
type=бычара из детсада
website=http://www.geocities.com/CapeCanaveral/11451

[gargamel]
fullname=Gargamel
type=злой волшебник
outputdir=/home/marijn/enemies/gargamel
----

(((grammar)))Точный формат файла (который довольно широко используется, и обычно называется _INI_), следующий:

- Пустые строки и строки, начинающиеся с точки с запятой, игнорируются.

- Строки, заключённые в квадратные скобки, начинают новую ((секцию)).

- Строки, содержащие алфавитно-цифровой идентификатор, за которым следует `=`, добавляют настройку в данной секции.

- Всё остальное – неверные данные.

Наша задача – преобразовать такую строку в массив объектов, каждый со свойством `name` и массивом настроек. Для каждой секции нужен один объект, и ещё один – для глобальных настроек сверху файла.

(((carriage return)))(((line break)))(((newline character)))Так как файл надо разбирать ((построчно)), неплохо начать с разбиения файла на строки. Для этого в link:06_object.html#split[главе 6] мы использовали `string.split("\n")`. Некоторые операционки используют для перевода строки не один символ `"\n"`, а два — `"\r\n"`. Так как метод `split` принимает регулярки в качестве аргумента, мы можем делить линии при помощи выражения `/\r?\n/`, разрешающего и одиночные `"\n"` и `"\r\n"` между строками.

[source,javascript]
----
function parseINI(string) {
  // Начнём с объекта, содержащего настройки верхнего уровня
  var currentSection = {name: null, fields: []};
  var categories = [currentSection];

  string.split(/\r?\n/).forEach(function(line) {
    var match;
    if (/^\s*(;.*)?$/.test(line)) {
      return;
    } else if (match = line.match(/^\[(.*)\]$/)) {
      currentSection = {name: match[1], fields: []};
      categories.push(currentSection);
    } else if (match = line.match(/^(\w+)=(.*)$/)) {
      currentSection.fields.push({name: match[1],
                                  value: match[2]});
    } else {
      throw new Error("Строчка '" + line + "' содержит неверные данные.");
    }
  });

  return categories;
}
----

(((parseINI function)))(((parsing)))Код проходит все строки, обновляя объект “текущей секции”. Сначала он проверяет, можно ли игнорировать строчку, при помощи регулярки `/^\s*(;.*)?$/`. Соображаете, как это работает? Часть между ((скобок)) совпадает с комментариями, а `?` делает так, что регулярка совпадёт и со строчками, состоящими из одних пробелов.

Если строка – не ((комментарий)), код проверяет, начинает ли она новую ((секцию)). Если да, он создаёт новый объект для текущей секции, к которому добавляются последующие настройки.

Последняя осмысленная возможность – строка является обычной настройкой, и в этом случае она добавляется к текущему объекту.

Если ни один вариант не сработал, функция выдаёт ошибку.

(((caret character)))(((dollar sign)))(((boundary)))Заметьте, как частое использование `^` и `$` заботится о том, что выражение совпадает со всей строкой целиком, а не с частью. Если их не использовать, код в целом будет работать, но иногда будет выдавать странные результаты, и такую ошибку будет трудно отследить.

(((if keyword)))(((assignment)))(((= operator)))Конструкция `if (match = string.match(...))` похожа на трюк, использующий присвоение как условие в цикле `while`. Часто вы не знаете, что вызов `match` будет успешным, поэтому вы можете получить доступ к результирующему объекту только внутри блока `if`, который это проверяет. Чтоб не разбивать красивую цепочку проверок `if`, мы присваиваем результат поиска переменной, и сразу используем это присвоение как проверку.

== Международные символы ==

(((internationalization)))(((Unicode)))(((regular expression,internationalization)))Из-за изначально простой реализации языка, и последующей фиксации такой реализации “в граните”, регулярки JavaScript тупят с символами, не встречающимися в английском языке. К примеру, символ “((буквы))” с точки зрения регулярок JavaScript, может быть одним из 26 букв английского алфавита (в верхнем или в нижнем регистре), и почему-то ещё подчёркиванием. Буквы типа _é_ или _β_, однозначно являющиеся буквами, не совпадают с `\w` (и совпадут с `\W`, то есть с не-буквой).

(((whitespace)))По странному стечению обстоятельств, исторически `\s` (пробел) совпадает со всеми символами, которые в Unicode считаются пробельными, включая такие штуки, как ((неразрывный пробел)) или ((монгольский разделитель гласных)).

(((character category)))У некоторых ((реализаций)) ((регулярок)) в других языках есть особый синтаксис для поиска специальных категорий символов ((Unicode)), типа “все прописные буквы”, “все знаки препинания” или “управляющие символы”. Есть планы по добавлению таких категорий и в JavaScript, но они, видимо, будут реализованы не скоро.

[[summary_regexp]]
== Итог ==

Регулярные выражения – это объекты, представляющие шаблоны поиска в строках. Они используют свой синтаксис для выражения этих шаблонов.

[cols="1,5"]
|====
|`/abc/`     |Последовательность символов
|`/[abc]/`   |Любой символ из списка
|`/[^abc]/`  |Любой символ, _кроме_ символов из списка
|`/[0-9]/`   |Любой символ из промежутка
|`/x+/`      |Одно или более вхождений шаблона `x`
|`/x+?/`     |Одно или более вхождений, нежадное
|`/x*/`      |Ноль или более вхождений
|`/x?/`      |Ноль или одно вхождение
|`/x{2,4}/`  |От двух до четырёх вхождений
|`/(abc)/`   |Группа
|++/a{brvbar}b{brvbar}c/++ |Любой из нескольких шаблонов
|`/\d/`      |Любая цифра
|`/\w/`      |Любой алфавитно-цифровой символ (“буква”)
|`/\s/`      |Любой пробельный символ
|`/./`       |Любой символ, кроме переводов строки
|`/\b/`      |Граница слова
|`/^/`       |Начало строки
|`/$/`       |Конец строки
|====

У регулярки есть метод `test`, для проверки того, есть ли шаблон в строке. Есть метод `exec`, возвращающий массив, содержащий все найденные группы. У массива есть свойство `index`, где содержится номер символа, с которого случилось совпадение.

У строк есть метод `match` для поиска шаблонов, и метод `search`, возвращающий только начальную позицию вхождения. Метод `replace` может заменять вхождения шаблона на другую строку. Кроме этого, вы можете передать в `replace` функцию, которая будет строить строчку на замену, основываясь на шаблоне и найденных группах.

У регулярок есть настройки, которые пишут после закрывающего слеша. Опция `i` делает регулярку регистронезависимой, а опция `g` делает её _глобальной_, что, кроме прочего, заставляет метод `replace` заменять все найденные вхождения, а не только первое.

Конструктор `RegExp` можно использовать для создания регулярок из строк.

Регулярки – острый ((инструмент)) с неудобной ручкой. Они сильно упрощают одни задачи, и могут стать неуправляемыми при решении других, сложных задач. Часть умения пользоваться регулярками состоит в том, чтобы уметь сопротивляться искушению запихнуть в них задачу, для которой они не предназначены.

== Упражнения ==

(((debugging)))(((bug)))Неизбежно при решении задач у вас возникнут непонятные случаи, и вы можете иногда отчаиваться, видя непредсказуемое ((поведение)) некоторых регулярок. Иногда помогает изучить поведение регулярки через онлайн-сервис типа https://www.debuggex.com/[_debuggex.com_], где можно посмотреть её визуализацию и сравнить с желаемым эффектом.

=== Регулярный гольф ===

(((program size)))(((code golf)))(((regexp golf (exercise))))_Гольфом_ в коде называют игру, где нужно выразить заданную программу минимальным количеством символов. _Регулярный гольф_ – практическое упражнение по написанию наименьших возможных регулярок для поиска заданного шаблона, и _только_ его.

(((boundary)))(((matching)))Для каждой из подстрочек напишите ((регулярное выражение)) для проверки их нахождения в строке. Регулярка должна находить только эти указанные подстроки. Не волнуйтесь насчёт границ слов, если это не упомянуто особо. Когда у вас получится работающая регулярка, попробуйте её уменьшить.

 1. _car_ и _cat_
 2. _pop_ и _prop_
 3. _ferret_, _ferry_, и _ferrari_
 4. Любое слово, заканчивающееся на _ious_
 5. Пробел, за которым идёт точка, запятая, двоеточие или точка с запятой
 6. Слово длинее шести букв
 7. Слово без букв _e_

Refer to the table in the link:09_regexp.html#summary_regexp[chapter summary] for help. Test each solution with a few test strings.

ifdef::interactive_target[]
[source,javascript]
----
// Впишите свои регулярки

verify(/.../,
       ["my car", "bad cats"],
       ["camper", "high art"]);

verify(/.../,
       ["pop culture", "mad props"],
       ["plop"]);

verify(/.../,
       ["ferret", "ferry", "ferrari"],
       ["ferrum", "transfer A"]);

verify(/.../,
       ["how delicious", "spacious room"],
       ["ruinous", "consciousness"]);

verify(/.../,
       ["bad punctuation ."],
       ["escape the dot"]);

verify(/.../,
       ["hottentottententen"],
       ["no", "hotten totten tenten"]);

verify(/.../,
       ["red platypus", "wobbling nest"],
       ["earth bed", "learning ape"]);


function verify(regexp, yes, no) {
  // Ignore unfinished exercises
  if (regexp.source == "...") return;
  yes.forEach(function(s) {
    if (!regexp.test(s))
      console.log("Не нашлось '" + s + "'");
  });
  no.forEach(function(s) {
    if (regexp.test(s))
      console.log("Неожиданное вхождение '" + s + "'");
  });
}
----
endif::interactive_target[]

=== Кавычки в тексте ===

(((quoting style (exercise))))(((single-quote character)))(((double-quote character)))Допустим, вы написали рассказ, и везде для обозначения диалогов использовали ((одинарные кавычки)). Теперь вы хотите заменить кавычки диалогов на двойные, и оставить одинарные в сокращениях слов типа _aren’t_.

(((replace method)))Придумайте шаблон, различающий два этих использования кавычек, и напишите вызов метода `replace`, который производит замену.

ifdef::interactive_target[]
// test: no

[source,javascript]
----
var text = "'I'm the cook,' he said, 'it's my job.'";
// Change this call.
console.log(text.replace(/A/g, "B"));
// → "I'm the cook," he said, "it's my job."
----
endif::interactive_target[]

!!hint!!

(((quoting style (exercise))))(((boundary)))The most obvious solution
is to only replace quotes with a nonword character on at least one
side. Something like `/\W'|'\W/`. But you also have to take the start
and end of the line into account.

(((grouping)))(((replace method)))In addition, you must ensure that
the replacement also includes the characters that were matched by the
`\W` pattern so that those are not dropped. This can be done by
wrapping them in ((parentheses)) and including their groups in the
replacement string (`$1`, `$2`). Groups that are not matched will be
replaced by nothing.

!!hint!!

=== Снова числа ===

(((number)))Последовательности ((цифр)) можно найти простой регуляркой `/\d+/`.

(((sign)))(((fractional number)))(((syntax)))(((minus)))(((plus character)))(((exponent)))(((scientific notation)))(((period character)))Напишите выражение, находящее только числа, записанные в стиле JavaScript. Оно должно поддерживать возможный минус _или_ плюс перед числом, десятичную точку, и экспоненциальную запись `5e-3` или `1E10` – опять-таки с возможными плюсом или минусом. Также заметьте, что до или после точки не обязательно могут стоять цифры, но при этом число не может состоять из одной точки. То есть, `.5` или `5.` – допустимые числа, а одна точка сама по себе – _нет_.

ifdef::interactive_target[]
// test: no

[source,javascript]
----
// Впишите сюда регулярку.
var number = /^...$/;

// Tests:
["1", "-1", "+15", "1.55", ".5", "5.", "1.3e2", "1E-4",
 "1e+12"].forEach(function(s) {
  if (!number.test(s))
    console.log("Не нашла '" + s + "'");
});
["1a", "+-1", "1.2.3", "1+1", "1e4.5", ".5.", "1f5",
 "."].forEach(function(s) {
  if (number.test(s))
    console.log("Неправильно принято '" + s + "'");
});
----
endif::interactive_target[]

!!hint!!

(((regular expression,escaping)))(((backslash character)))First, do
not forget the backslash in front of the dot.

Matching the optional ((sign)) in front of the ((number)), as well as
in front of the ((exponent)), can be done with `[+\-]?` or `(\+|-|)`
(plus, minus, or nothing).

(((pipe character)))The more complicated part of the exercise is the
problem of matching both `"5."` and `".5"` without also matching
`"."`. For this, a good solution is to use the `|` operator to
separate the two cases—either one or more digits optionally followed
by a dot and zero or more digits _or_ a dot followed by one or more
digits.

(((exponent)))(((case sensitivity)))(((regular
expression,flags)))Finally, to make the _e_ case-insensitive, either
add an `i` option to the regular expression or use `[eE]`.

!!hint!!
