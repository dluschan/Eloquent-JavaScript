:chap_num: 4
:prev_link: 03_functions
:next_link: 05_higher_order
:load_files: ["code/jacques_journal.js", "code/chapter/04_data.js"]
:zip: node/html

= Структуры данных: объекты и массивы =

[chapterquote="true"]
[quote, Чарльз Бэббидж, Отрывки из жизни философа (1864)]
____
Два раза меня спрашивали: «Скажите, м-р Бэббидж, а если вы введёте в машину неправильные данные, получится ли правильный ответ?». Непостижима та путаница в головах, которая приводит к таким вопросам.
____

(((Babbage+++,+++ Charles)))(((object)))(((data structure)))Числа, булевские значения и строки – кирпичики, из которых строятся структуры ((данных)). Но нельзя сделать дом из одного кирпича. _Объекты_ позволяют нам группировать значения (в том числе и другие объекты) вместе – и строить более сложные структуры.

Написание программ, которым мы до сего момента занимались, сильно затруднял тот факт, что они работали только с простыми данными. Эта глава добавит вам в инструментарий понимание структур данных. К её концу вы будете знать достаточно для того, чтобы начать писать полезные программы.

Глава пройдётся по более-менее реалистичному примеру программирования, вводя понятия по мере необходимости. Код примеров будет строиться из функций и переменных, которые мы определяли ранее.

ifdef::book_target[]

(((sandbox)))The online coding sandbox for the book
(http://eloquentjavascript.net/2nd_edition/code[_eloquentjavascript.net/code_])
provides a way to run code in the context of a specific chapter. If
you decide to work through the examples in another environment, be
sure to first download the full code for this chapter from the
sandbox page.

endif::book_target[]

== Белка-оборотень ==

(((weresquirrel example)))(((lycanthropy)))Иногда, обычно между восемью и десятью часами вечера, ((Жак)) против своей воли превращается в небольшого грызуна с пушистым хвостом.

С одной стороны, Жак рад, что он не превращается в классического волка. Превращение в белку влечёт меньше проблем. Вместо того, чтобы волноваться о том, не съешь ли ты соседа (_это_ было бы неловко), он волнуется, как бы его не съел соседский кот. После того, как он дважды просыпался на очень тонкой ветке в кроне дуба, голый и дезориентированный, он приучился запирать окна и двери в своей комнате на ночь, и класть несколько орешков на пол, чтобы чем-то занять себя.

image::img/weresquirrel.png[alt="The weresquirrel"]

Так решаются проблемы с котом и дубом. Но Жак всё ещё страдает от своего заболевания. Нерегулярные обращения наводят его на мысль, что они должны быть чем-то вызваны. Сначала он думал, что это происходит только в те дни, когда он прикасался к деревьям. Он перестал это делать, и даже стал избегать подходить к ним. Но проблема не исчезла.

(((journal)))Перейдя к более научному подходу, Жак решил вести ежедневный дневник всего, чем он занимался, записывая туда, обращался ли он в белку. Так он надеется сузить круг вещей, приводящих к трансформации. 

Сперва он решил разработать структуру данных для хранения этой информации.

== Наборы данных ==

(((data structure)))Для работы с куском данных нам вначале нужно найти способ представлять их в ((памяти)) машины. К примеру, нам нужно запомнить ((коллекцию)) чисел: 2, 3, 5, 7 и 11.

(((string)))Можно поиграть со строками – строки могут быть любой длины, в них можно поместить много данных, и использовать для представления этого набора `"2 3 5 7 11"`. Но это неудобно. Нам нужно будет как-то вынимать оттуда числа или вставлять новые в строку.

(((array,creation)))((([] (array))))К счастью, JavaScript предлагает тип данных специально для хранения последовательностей чисел. Он называется _массивом_ (_array_), и записывается, как список значений в ((квадратных скобках)), разделённых запятыми.

[source,javascript]
----
var listOfNumbers = [2, 3, 5, 7, 11];
console.log(listOfNumbers[2]);
// → 5
console.log(listOfNumbers[2 - 1]);
// → 3
----

((([] (subscript))))(((array,indexing)))Запись для получения элемента из массива тоже использует ((квадратные скобки)). Пара скобок после выражения, содержащая внутри ещё одно выражение, найдёт в массиве, который задан первым выражением, элемент, _((индекс))_ (_порядковый номер_) которого задан вторым выражением.

[[array_indexing]]
Номер первого элемента – ноль, а не один. Поэтому первый элемент можно получить так: `listOfNumbers[0]`. Если вы раньше не программировали, придётся привыкнуть к такой нумерации. Но она имеет давнюю традицию, и всё время, пока её последовательно соблюдают, она прекрасно работает.

[[properties]]
== Свойства ==

(((Math object)))(((Math.max function)))(((length property,for string)))(((object,property)))(((period character)))Мы видели много подозрительных выражений вроде `myString.length` (получение длины строки) и `Math.max` (получение максимума) в ранних примерах. Эти выражения используют _((свойства))_ величин. В первом случае, мы получаем доступ к свойству `length` (длина) переменной `myString`. Во втором — доступ к свойству `max` объекта `Math` (который является набором функций и переменных, связанных с математикой).

(((property)))(((null)))(((undefined)))Почти у всех переменных в JavaScript есть свойства. Исключения — `null` и `undefined`. Если вы попробуете получить доступ к несуществующим свойствам этих не-величин, получите ошибку:

// test: no

[source,javascript]
----
null.length;
// → TypeError: Cannot read property 'length' of null
----

indexsee:[dot character,period character]
((([] (subscript))))(((period character)))(((square brackets)))(((computed property)))Два основных способа доступа к свойствам – точка и квадратные скобки. `value.x` и `value[x]` получают доступ к ((свойству)) ++value++ – но не обязательно к одному и тому же. Разница в том, как интерпретируется `x`. При использовании точки запись после точки должна быть именем существующей переменной, и она таким образом напрямую вызывает свойство по имени. При использовании квадратных скобок выражение в скобках _вычисляется_ для получения имени свойства. `value.x` вызывает свойство под именем “x”, а `value[x]` вычисляет выражение `x` и использует результат в качестве имени свойства.

Если вы знаете, что интересующее вас свойство называется “length”, вы пишете `value.length`. Если вы хотите извлечь имя свойства из переменной `i`, вы пишете `value[i]`. А поскольку свойство может иметь любое имя, для доступа к свойству по имени “2” или “Jon Doe” вам придётся использовать квадратные скобки: `value[2]` или `value["John Doe"]`. Это необходимо даже когда вы знаете точное имя свойства, потому что “2” или “Jon Doe” не являются допустимыми именами переменных, поэтому к ним нельзя обратиться при помощи записи через точку.

(((array)))(((length property,for array)))(((array,length of)))Элементы массива хранятся в свойствах. Так как имена этих свойств – числа, и нам часто приходится получать их имена из значений переменных, нужно использовать квадратные скобки для доступа к ним. Свойство `length` массива говорит о том, сколько в нём элементов. Имя этого свойства – допустимое имя переменной, и мы его знаем заранее, поэтому обычно мы пишем `array.length`, потому, что это проще, чем писать `array["length"]`.

[[methods]]
== Методы ==

(((function,as property)))(((method)))(((string)))Объекты string и array содержат, в дополнение к свойству `length`, несколько свойств, ссылающихся на функции.

[source,javascript]
----
var doh = "Дык";
console.log(typeof doh.toUpperCase);
// → function
console.log(doh.toUpperCase());
// → ДЫК
----

(((case conversion)))(((toUpperCase method)))(((toLowerCase method)))У каждой строки есть свойство `toUpperCase`. При вызове оно возвращает копию строки, в которой все буквы заменены на прописные. Есть также и `toLowerCase` – можете догадаться, что оно делает.

(((this)))Что интересно, хотя вызов `toUpperCase` не передаёт никаких аргументов, функция каким-то образом получает доступ к строчке `"Дык"`, свойство которой мы вызывали. Как это работает, описано в link:06_object.html#obj_methods[Главе 6].

Свойства, содержащие функции, обычно называют _методами_ той переменной, которой они принадлежат. То есть, “++toUpperCase++ – это метод строки”.

[[array_methods]]
(((collection)))(((array)))(((string)))(((push method)))(((pop method)))(((join method)))В следующем примере демонстрируются некоторые методы, имеющиеся у массивов:

[source,javascript]
----
var mack = [];
mack.push("Трест,");
mack.push("который", "лопнул");
console.log(mack);
// → ["Трест,", "который", "лопнул"]
console.log(mack.join(" "));
// → Трест, который лопнул
console.log(mack.pop());
// → лопнул
console.log(mack);
// → ["Трест,", "который"]
----

Метод `push` используется для добавления значений в конец массива. `pop` делает обратное: удаляет значение из конца массива и возвращает его. Массив строк можно сплющить в одну строку при помощи метода `join`. В качестве аргумента `join` передают строку, которая будет вставлена между элементами массива.

== Объекты ==

(((journal)))(((weresquirrel example)))(((array)))(((record)))Вернёмся к нашей белке. Набор журнальных записей можно представить в виде массива. Но записи не состоят только лишь из номеров или строк – каждая должна хранить список того, что сделал наш герой, и булевское значение, показывающее, превратился ли Жак в белку. В идеале нам бы хотелось группировать каждую из записей в какую-то одну переменную, и потом добавлять их в массив.

(((syntax)))(((object)))(((property)))(((curly braces)))((({} (object))))Переменные типа _object_ (_объект_) – коллекции произвольных свойств, и мы можем добавлять и удалять свойства объекта по желанию. Один из способов создать объект – использовать фигурные скобки.

[source,javascript]
----
var day1 = {
  squirrel: false,
  events: ["работа", "тронул дерево", "пицца", "пробежка",
           "телевизор"]
};
console.log(day1.squirrel);
// → false
console.log(day1.wolf);
// → undefined
day1.wolf = false;
console.log(day1.wolf);
// → false
----

(((quoting,of object properties)))(((colon character)))В скобках мы можем задать список свойств, разделённых запятыми. Записывается каждое свойство как имя, после которого идёт двоеточие, затем идёт выражение, которое и является значением свойства. Пробелы и переносы строк не учитываются. Разбивая запись свойств объекта на несколько строк, вы улучшаете читаемость кода. Если имя свойства не является допустимым именем переменной, его нужно заключать в кавычки:

[source,javascript]
----
var descriptions = {
  work: "Пошёл на работу",
  "тронул дерево": "Дотронулся до дерева"
};
----

Получается, у ((фигурных скобок)) в JavaScript _два_ значения. Употреблённые в начале инструкции, они начинают новый блок инструкций. В любом другом месте они описывают объект. Обычно нет смысла начинать инструкцию с описания объекта, и поэтому в программах обычно нет двусмысленностей по поводу этих двух применений фигурных скобок.

(((undefined)))Если вы попытаетесь прочесть значение несуществующего свойства, вы получите `undefined` – как в примере, когда мы первый раз попробовали прочесть свойство `wolf`.

(((property,assignment)))(((mutability)))(((= operator)))Свойству можно назначать значение через оператор `=`. Если у него ранее было значение, оно будет заменено. Если свойство отсутствовало, оно будет создано.

(((tentacle (analogy))))(((property,model of)))Возвращаясь к нашей модели со щупальцами и ((переменными)), мы видим, что свойства тоже похожи на них. Они _хватают_ значения, но на эти же значения могут ссылаться другие переменные и свойства. Объекты – это осьминоги с произвольным количеством щупалец, на каждом из которых написано имя свойства.

image::img/octopus-object.jpg[alt="Artist's representation of an object"]

(((delete operator)))(((property,deletion)))Оператор `delete` отрезает щупальце. Это унарный оператор, применяемый к выражению доступа к свойству. Это делается редко, но вполне возможно.

[source,javascript]
----
var anObject = {left: 1, right: 2};
console.log(anObject.left);
// → 1
delete anObject.left;
console.log(anObject.left);
// → undefined
console.log("left" in anObject);
// → false
console.log("right" in anObject);
// → true
----

(((in operator)))(((property,testing for)))(((object)))Бинарный оператор `in` принимает строку и имя объекта, и возвращает булевское значение, показывающее, есть ли у объекта свойство с таким именем. Есть разница между установкой значения свойства в `undefined` и удалением свойства. В первом случае свойство _сохраняется_ у объекта, просто оно пустое. Во втором – свойства больше нет, и тогда `in` возвращает `false`.

(((array)))(((collection)))Получается, что массивы – это разновидность объектов, которые специализируются на хранении последовательностей. Выражение `typeof [1, 2]` вернёт `"object"`. Их можно рассматривать как длинных плоских осьминогов, у которых все щупальца расположены ровным рядом и размечены номерами.

image::img/octopus-array.jpg[alt="Artist's representation of an array"]

(((journal)))(((weresquirrel example)))Поэтому журнал Жака можно представить в виде массива объектов.

[source,javascript]
----
var journal = [
  {events: ["работа", "тронул дерево", "пицца",
            "пробежка", "телевизор"],
   squirrel: false},
  {events: ["работа ", "мороженое", "цветная капуста",
            "лазанья", " тронул дерево ", "почистил зубы"],
   squirrel: false},
  {events: ["выходной", "велик", "перерыв",
            "арахис", "пивасик"],
   squirrel: true},
  /* и так далее... */
];
----

== Изменчивость (Mutability) ==

Скоро мы уже и до _программирования_ доберёмся. А пока нам нужно понять последнюю часть теории.

(((mutability)))(((side effect)))(((number)))(((string)))(((Boolean)))(((object)))Мы увидели, что значения объекта можно менять. Типы значений, которые мы рассматривали ранее,– числа, строки, булевские значения,– __неизменяемы__. Нельзя поменять существующее значение заданного типа. Их можно комбинировать и выводить из них новые значения, но когда вы работаете с некоторым значением строки, это значение остаётся постоянным. Текст внутри строки нельзя поменять. Если у вас есть ссылка на строку `"кошка"`, в коде нельзя поменять в _ней_ символ, чтобы получилось `"мошка"`.

А вот у объектов содержимое _можно_ менять, изменяя значения их свойств.

(((object,identity)))(((identitiy)))(((memory)))Если у нас есть два числа, 120 и 120, мы можем рассматривать их как одно и тоже, независимо от того, хранятся ли они в памяти в одном и том же месте. Но когда мы имеем дело с объектами, есть разница, есть ли у нас две ссылки на один объект или же у нас есть два разных объекта, содержащих одинаковые свойства. Рассмотрим пример:

[source,javascript]
----
var object1 = {value: 10};
var object2 = object1;
var object3 = {value: 10};

console.log(object1 == object2);
// → true
console.log(object1 == object3);
// → false

object1.value = 15;
console.log(object2.value);
// → 15
console.log(object3.value);
// → 10
----

(((tentacle (analogy))))(((variable,model of)))Переменные `object1` и `object2` держатся за _один и тот же_ объект, поэтому изменения `object1` приводят к изменениям в `object2`. Переменная `object3` показывает на другой объект, который изначально содержит те же свойства, что и `object1`, но живёт своей собственной жизнью.

(((== operator)))(((comparison,of objects)))(((deep comparison)))Оператор `==` при сравнении объектов возвращает `true` только, если сравниваемые объекты – это одна и та же переменная. Сравнение разных объектов вернёт `false`, даже если у них идентичное содержимое. Оператора “глубокого” сравнения, который бы сравнивал содержимое объектов, в JavaScript не предусмотрено, но его возможно сделать самостоятельно (это будет одним из link:04_data.html#exercise_deep_compare[упражнений] в конце главы).

== Журнал оборотня ==

(((weresquirrel example)))(((lycanthropy)))(((addEntry function)))Итак, Жак запускает свой любимый интерпретатор JavaScript и создаёт окружение, необходимое для хранения ((журнала)).

// include_code

[source,javascript]
----
var journal = [];

function addEntry(events, didITurnIntoASquirrel) {
  journal.push({
    events: events,
    squirrel: didITurnIntoASquirrel
  });
}
----

Каждый вечер, часов в десять,– а иногда и назавтра утром, спускаясь с верхней полки шкафа,– он записывает свой день.

[source,javascript]
----
addEntry(["работа", "тронул дерево", "пицца", "пробежка",
          "телевизор"], false);
addEntry(["работа", "мороженое", "цветная капуста", "лазанья",
          "тронул дерево", "почистил зубы"], false);
addEntry(["выходной", "велик", "перерыв", "арахис",
          "пивасик"], true);
----

Как только у него будет достаточно данных, он собирается вычислить ((корреляцию)) между его оборачиваниями и событиями каждого из дней, и в идеале узнать из их корреляций что-то полезное.

(((correlation)))_Корреляция_ – это мера ((зависимости)) между ((переменными)) величинами (“переменными” в статистическом смысле, а не в смысле JavaScript). Она обычно выражается в виде коэффициента, принимающего значения от -1 до 1. Нулевая корреляция обозначает, что переменные вообще не связаны, а корреляция 1 означает, что они полностью связаны – если вы знаете одну, вы автоматически знаете другую. Минус один также означает прочную связь переменных, но и их противоположность – когда одна true, вторая всегда false.

(((phi coefficient)))Для измерения корреляции булевских переменных хорошо подходит коэффициент _фи_ (_ϕ_), к тому же, его сравнительно легко подсчитать. Для этого нам нужна ((таблица)), содержащая количество раз, когда наблюдались различные комбинации двух переменных. К примеру, мы можем взять события “поел ((пиццы))” и “обращение” и представить их в следующей таблице:

image::img/pizza-squirrel.svg[alt="Eating pizza versus turning into a squirrel",width="7cm"]

_ϕ_ можно вычислить по следующей формуле, где _n_ относится к ячейкам таблицы:

ifdef::html_target[]

++++
<div>
<style scoped="scoped">sub { font-size: 60%; }</style>
<table style="border-collapse: collapse; margin-left: 1em;"><tr>
  <td style="vertical-align: middle"><em>ϕ</em> =</td>
  <td style="padding-left: .5em">
    <div style="border-bottom: 1px solid black; padding: 0 7px;">n<sub>11</sub>n<sub>00</sub> - n<sub>10</sub>n<sub>01</sub></div>
    <div style="padding: 0 7px;">√<span style="border-top: 1px solid black; position: relative; top: 2px;">
      <span style="position: relative; top: -4px">n<sub>1•</sub>n<sub>0•</sub>n<sub>•1</sub>n<sub>•0</sub></span>
    </span></div>
  </td>
</tr></table>
</div>
++++

endif::html_target[]

ifdef::tex_target[]

pass:[\begin{equation}\varphi = \frac{n_{11}n_{00}-n_{10}n_{01}}{\sqrt{n_{1\bullet}n_{0\bullet}n_{\bullet1}n_{\bullet0}}}\end{equation}]

endif::tex_target[]

(!html _n_~01~!)(!tex pass:[$n_{01}$]!) обозначает количество измерений, когда первое событие (обращение) false (0), а второе событие (пицца) true (1). В нашем примере (!html _n_~01~!)(!tex pass:[$n_{01}$]!) равно 9.

Запись (!html _n_~1•~!)(!tex pass:[$n_{1\bullet}$]!) обозначает сумму всех измерений, где первое событие было true, что для нашего примера равно 5. Соответственно, (!html _n_~•0~!)(!tex pass:[$n_{\bullet0}$]!) – сумма всех измерений, где второе событие было false.

(((correlation)))(((phi coefficient)))Значит, для таблицы с пиццей числитель формулы будет 1×76 - 4×9 = 40, а знаменатель – корень из 5×85×10×80, или (!html √340000!)(!tex pass:[$\sqrt{340000}$]!). Получается, что _ϕ_ ≈ 0.069, что довольно мало. Непохоже, чтобы ((пицца)) влияла на обращения в белку.

== Вычисляем корреляцию ==

(((array,as table)))(((nesting,of arrays)))((Таблицу)) 2х2 можно представить массивом из четырёх элементов (`[76, 9, 4, 1]`), массивом из двух элементов, каждый из которых является также двухэлементным массивом (`[[76, 9], [4, 1]]`), или же объектом со свойствами под именами `"11"` или `"01"`. Но для нас одномерный массив проще и выражение для доступа к нему будет короче. Мы будем обрабатывать индексы массива как двузначные ((двоичные числа)), где левый знак обозначает переменную оборачиваемости, а правый – события. К примеру, `10` обозначает случай, когда Жак обратился в белку, но событие (к примеру, “пицца”) не имело места. Так случилось 4 раза. И поскольку двоичное `10` – это десятичное 2, мы будем хранить это в массиве по индексу 2.

(((phi coefficient)))(((phi function)))Функция, вычисляющая коэффициент _ϕ_ из такого массива:

// test: clip
// include_code strip_log

[source,javascript]
----
function phi(table) {
  return (table[3] * table[0] - table[2] * table[1]) /
    Math.sqrt((table[2] + table[3]) *
              (table[0] + table[1]) *
              (table[1] + table[3]) *
              (table[0] + table[2]));
}

console.log(phi([76, 9, 4, 1]));
// → 0.068599434
----

(((square root)))(((Math.sqrt function)))Это просто прямая реализация формулы _ϕ_ на языке JavaScript. `Math.sqrt` – это функция извлечения квадратного корня объекта `Math` из стандартного окружения JavaScript. Нам нужно сложить два поля таблицы для получения полей типа (!html n~1•~!)(!tex pass:[$n_{1\bullet}$]!), потому что мы не храним в явном виде суммы столбцов или строк.

(((JOURNAL data set)))Жак вёл журнал три месяца. Результат доступен на сайте книги
(!book (http://eloquentjavascript.net/2nd_edition/code#4[_eloquentjavascript.net/2nd_edition/code#4_])!), где он хранится в переменной `JOURNAL` и в загружаемом http://eloquentjavascript.net/2nd_edition/code/jacques_journal.js[файле].

(((tableFor function)))(((hasEvent function)))Чтобы извлечь ((таблицу)) 2х2 для конкретного события, нам нужно в цикле пройтись по всем записям и посчитать, сколько раз оно случается по отношению к обращению в белку.

// include_code strip_log

[source,javascript]
----
function hasEvent(event, entry) {
  return entry.events.indexOf(event) != -1;
}

function tableFor(event, journal) {
  var table = [0, 0, 0, 0];
  for (var i = 0; i < journal.length; i++) {
    var entry = journal[i], index = 0;
    if (hasEvent(event, entry)) index += 1;
    if (entry.squirrel) index += 2;
    table[index] += 1;
  }
  return table;
}

console.log(tableFor("pizza", JOURNAL));
// → [76, 9, 4, 1]
----

(((array,searching)))(((indexOf method)))Функция `hasEvent` проверяет, содержит ли запись нужный элемент. У массивов есть метод `indexOf`, который ищет заданное значение (в нашем случае – имя события) в массиве. и возвращает индекс его положения в массиве (-1, если его в массиве нет). Значит, если вызов indexOf не вернул -1, то событие в записи есть.

(((array,indexing)))Тело цикла в `tableFor` рассчитывает, в какую ячейку таблицы попадает каждая из журнальных записей. Она смотрит, содержит ли запись нужное событие, и связано ли оно с обращением в белку. Затем цикл увеличивает на единицу элемент массива, соответствующий нужной ячейке.

Теперь у нас есть все инструменты для подсчёта ((корреляций)). Осталось только подсчитать корреляции для каждого из событий, и посмотреть, не выдаётся ли что из списка. Но как хранить эти корреляции?

== Объекты как карты (map) ==

(((weresquirrel example)))(((array)))Один из способов – хранить ((корреляции)) в массиве, используя объекты со свойствами `name` и `value`. Однако поиск корреляций в массиве будет довольно громоздким: нужно будет пройтись по всему массиву, чтобы найти объект с нужным именем. Можно было бы обернуть этот процесс в функцию, но код пришлось бы писать всё равно, и компьютер выполнял бы больше работы, чем необходимо.

[[object_map]]
(((object)))(((square brackets)))(((object,as map)))(((in operator)))Способ лучше – использовать свойства объектов с именами событий. Мы можем использовать квадратные скобки для создания и чтения свойств и оператор `in` для проверки существования свойства.

[source,javascript]
----
var map = {};
function storePhi(event, phi) {
  map[event] = phi;
}

storePhi("pizza", 0.069);
storePhi("touched tree", -0.081);
console.log("pizza" in map);
// → true
console.log(map["touched tree"]);
// → -0.081
----

(((data structure)))_((Карта))_ (_((map))_) – способ связать значения из одной области (в данном случае – названия событий) со значениями в другой (в нашем случае – коэффициенты _ϕ_).

С таким использованием объектов есть пара проблем – мы обсудим их в link:06_object.html#prototypes[Главе 6], но пока волноваться не будем.

(((for/in loop)))(((for loop)))(((object,looping over)))Что, если нам надо собрать все события, для которых сохранены коэффициенты? Они не создают предсказуемую последовательность, как было бы в массиве, поэтому обычный цикл `for` использовать не получится. JavaScript предлагает конструкцию цикла специально для обхода всех свойств объекта. Она похожа на цикл `for`, но использует команду `in`.

[source,javascript]
----
for (var event in map)
  console.log("Кореляция для '" + event +
              "' получается " + map[event]);
// → Кореляция для 'пицца' получается 0.069
// → Кореляция для 'тронул дерево' получается -0.081
----

[[analysis]]
== Итоговый анализ ==

(((journal)))(((weresquirrel example)))(((gatherCorrelations function)))Чтобы найти все типы событий, представленных в наборе данных, мы обрабатываем каждое вхождение по очереди, и затем создаём цикл по всем событиям вхождения. Мы храним объект `phis`, в котором содержатся корреляционные коэффициенты для всех типов событий, которые мы уже нашли. Если мы встречаем новый тип, которого ещё не было в `phis`, мы подсчитываем его корреляцию и добавляем её в объект.

// test: clip
// include_code strip_log

[source,javascript]
----
function gatherCorrelations(journal) {
  var phis = {};
  for (var entry = 0; entry < journal.length; entry++) {
    var events = journal[entry].events;
    for (var i = 0; i < events.length; i++) {
      var event = events[i];
      if (!(event in phis))
        phis[event] = phi(tableFor(event, journal));
    }
  }
  return phis;
}

var correlations = gatherCorrelations(JOURNAL);
console.log(correlations.pizza);
// → 0.068599434
----

(((correlation)))Смотрим. что получилось.

// test: no

[source,javascript]
----
for (var event in correlations)
  console.log(event + ": " + correlations[event]);
// → морковка:   0.0140970969
// → упражнения: 0.0685994341
// → выходной:   0.1371988681
// → хлеб:      -0.0757554019
// → пудинг:    -0.0648203724
// и так далее...
----

(((for/in loop)))Большинство корреляций лежат близко к нулю. Морковки, хлеб и пудинг, очевидно, не связаны с обращением в белку. Но оно _вроде бы_ более часто происходит на выходных. Давайте отфильтруем результаты, чтобы выводить только корреляции больше 0.1 или меньше -0.1.

// start_code
// test: no

[source,javascript]
----
for (var event in correlations) {
  var correlation = correlations[event];
  if (correlation > 0.1 || correlation < -0.1)
    console.log(event + ": " + correlation);
}
// → выходной:     0.1371988681
// → чистил зубы: -0.3805211953
// → конфета:      0.1296407447
// → работа:      -0.1371988681
// → спагетти:     0.2425356250
// → читал:        0.1106828054
// → арахис:       0.5902679812
----

Ага! У двух факторов ((корреляции)) заметно больше остальных. ((Арахис)) сильно влияет на вероятность превращения в белку, тогда как чистка зубов наоборот, препятствует этому.

Интересно. Попробуем вот что.

// include_code strip_log

[source,javascript]
----
for (var i = 0; i < JOURNAL.length; i++) {
  var entry = JOURNAL[i];
  if (hasEvent("арахис", entry) &&
     !hasEvent("чистка зубов", entry))
    entry.events.push("арахис зубы");
}
console.log(phi(tableFor("арахис зубы", JOURNAL)));
// → 1
----

Ошибки быть не может! Феномен случается именно тогда, когда Жак ест ((арахис)) и не чистит зубы. Если б он только не был таким неряхой относительно оральной гигиены, он бы вообще не заметил своего несчастья.

Зная это, Жак просто перестаёт есть арахис и обнаруживает, что трансформации прекратились.

(((weresquirrel example)))У Жака какое-то время всё хорошо. Но через несколько лет он теряет ((работу)), и в конце концов ему приходится наняться в ((цирк)), где он выступает как _Удивительный Человек-белка_, набирая полный рот арахисового масла перед шоу. Однажды, устав от столь жалкого существования, Жак не обращается обратно в человека, пробирается через дыру в цирковом тенте и исчезает в лесу. Больше его никто не видел.

== Дальнейшая массивология ==

(((array,methods)))(((method)))В конце главы хочу познакомить вас ещё с несколькими концепциями, относящимися к объектам. Начнём с полезных методов, имеющихся у массивов.

(((push method)))(((pop method)))(((shift method)))(((unshift
method)))Мы видели методы `push` и `pop` link:04_data.html#array_methods[раннее] в этой главе, которые добавляют и удаляют элементы в конце массива. Соответствующие методы для начала массива называются `unshift` и `shift`.

[source,javascript]
----
var todoList = [];
function rememberTo(task) {
  todoList.push(task);
}
function whatIsNext() {
  return todoList.shift();
}
function urgentlyRememberTo(task) {
  todoList.unshift(task);
}
----

(((task management example)))Данная программа управляет списком дел. Вы добавляете дела в конец списка, вызывая `rememberTo("поесть")`, а когда вы готовы заняться чем-то, вызываете `whatIsNext()`, чтобы получить (и удалить) первый элемент списка. Функция `urgentlyRememberTo` тоже добавляет задачу, но только в начало списка.

(((array,searching)))(((indexOf method)))(((lastIndexOf method)))У метода `indexOf` есть родственник по имени `lastIndexof`, который начинает поиск элемента в массиве с конца.

[source,javascript]
----
console.log([1, 2, 3, 2, 1].indexOf(2));
// → 1
console.log([1, 2, 3, 2, 1].lastIndexOf(2));
// → 3
----

Оба метода, `indexOf` и `lastIndexOf`, принимают необязательный второй аргумент, который задаёт начальную позицию поиска.

(((slice method)))(((array,indexing)))Ещё один важный метод – `slice`, который принимает номера начального и конечного элементов, и возвращает массив, состоящий только из элементов, попадающих в этот промежуток. Включая тот, что находится по начальному индексу, но исключая тот, что по конечному.

[source,javascript]
----
console.log([0, 1, 2, 3, 4].slice(2, 4));
// → [2, 3]
console.log([0, 1, 2, 3, 4].slice(2));
// → [2, 3, 4]
----

(((string,indexing)))Когда конечный индекс не задан, `slice` выбирает все элементы после начального индекса. У строк также есть метод `slice`, который работает аналогично.

(((concatenation)))(((concat method)))Метод `concat` используется для склейки массивов, примерно как оператор `+` склеивает строки. В примере показаны методы `concat` и `slice` в деле. Функция принимает массив и индекс, и возвращает копию переданного массива, за исключением удалённого элемента с заданным индексом.

[source,javascript]
----
function remove(array, index) {
  return array.slice(0, index)
    .concat(array.slice(index + 1));
}
console.log(remove(["a", "b", "c", "d", "e"], 2));
// → ["a", "b", "d", "e"]
----

== Строки и их свойства ==

(((string,properties)))Мы можем получать значения свойств строк, например `length` и `toUpperCase`. Но попытка добавить новое свойство ни к чему не приведёт.

[source,javascript]
----
var myString = "Шарик";
myString.myProperty = "значение";
console.log(myString.myProperty);
// → undefined
----

Величины типа строка, число и булевские – не объекты, и хотя язык не жалуется на попытки назначить им новые свойства, он на самом деле их не сохраняет. Величины неизменяемы.

(((string,methods)))(((slice method)))(((indexOf method)))(((string,searching)))Но у них есть свои встроенные свойства. У каждой строки есть набор методов. Самые полезные, пожалуй – `slice` и `indexOf`, напоминающие те же методы у массивов.

[source,javascript]
----
console.log("кокосы".slice(3, 6));
// → осы
console.log("кокос".indexOf("с"));
// → 4
----

Разница в том, что у строки метод `indexOf` может принять строку, содержащую больше одного символа, а у массивов такой метод работает только с одним элементом.

[source,javascript]
----
console.log("раз два три".indexOf("ва"));
// → 5
----

(((whitespace)))(((trim method)))Метод `trim` удаляет пробелы (а также переводы строк, табуляцию и прочие подобные символы) с обоих концов строки.

[source,javascript]
----
console.log("  ладно  \n ".trim());
// → ладно
----

(((length property,for string)))(((charAt method)))(((string,indexing)))Мы уже сталкивались со свойством строки `length`. Доступ к отдельным символам строчки можно получить через метод `charAt`, а также просто через нумерацию позиций, как в массиве.

[source,javascript]
----
var string = "abc";
console.log(string.length);
// → 3
console.log(string.charAt(0));
// → a
console.log(string[1]);
// → b
----

[[arguments_object]]
== Объект arguments ==

(((arguments object)))(((length property)))(((parameter)))(((optional argument)))(((array-like object)))Когда вызывается функция, к окружению исполняемого тела функции добавляется особая переменная под названием `arguments`. Она указывает на объект, содержащий все аргументы, переданные функции. Помните, что в JavaScript вы можете передавать функции больше или меньше аргументов, чем объявлено при помощи параметров.

[source,javascript]
----
function noArguments() {}
noArguments(1, 2, 3); // Пойдёт
function threeArguments(a, b, c) {}
threeArguments(); // И так можно
----

(((length property)))У объекта `arguments` есть свойство `length`, которое содержит реальное количество переданных функции аргументов. Также у него есть свойства для каждого аргумента под именами 0, 1, 2 и т.д.

indexsee:[pseudo array,array-like object]
(((array,methods)))Если вам кажется, что это очень похоже на массив – вы правы. Это очень _похоже_ на массив. К сожалению, у этого объекта нет методов типа `slice` или `indexOf`, что делает доступ к нему труднее.

[source,javascript]
----
function argumentCounter() {
  console.log("Ты дал мне", arguments.length, "аргумента.");
}
argumentCounter("Дядя", "Стёпа", "Милиционер");
// → Ты дал мне 3 аргумента.
----

(((journal)))(((console.log)))(((variadic function)))Некоторые функции рассчитаны на любое количество аргументов, как `console.log`. Они обычно проходят циклом по свойствам объекта `arguments`. Это можно использовать для создания удобных интерфейсов. К примеру, вспомните, как мы создавали записи для журнала Жака.

[source,javascript]
----
addEntry(["работа", "тронул дерево", "пицца", "пробежка",
          "телевизор"], false);
----

Так как мы часто вызываем эту функцию, мы можем сделать альтернативу, которую проще вызывать.

[source,javascript]
----
function addEntry(squirrel) {
  var entry = {events: [], squirrel: squirrel};
  for (var i = 1; i < arguments.length; i++)
    entry.events.push(arguments[i]);
  journal.push(entry);
}
addEntry(true, "работа", "тронул дерево", "пицца",
         "пробежка", "телевизор");
----

(((arguments object,indexing)))Эта версия читает первый аргумент как обычно, а по остальным проходит в цикле (начиная с индекса 1, пропуская первый аргумент) и собирает их в массив.

== Объект Math ==

(((Math object)))(((Math.min function)))(((Math.max function)))(((Math.sqrt function)))(((minimum)))(((maximum)))(((square root)))Мы уже видели, что `Math` – набор инструментов для работы с числами, такими, как `Math.max` (максимум), `Math.min` (минимум), и `Math.sqrt` (квадратный корень).

[[namespace_pollution]]
(((namespace)))(((namespace pollution)))(((object)))Объект `Math` используется просто как контейнер для группировки связанных функций. Есть только один объект `Math`, и он почти не используется в виде значений. Он просто предоставляет _пространство имён_ для всех этих функций и значений, чтоб не нужно было делать их глобальными.

(((variable,naming)))Слишком большое число глобальных переменных “загрязняет” пространство имён. Чем больше имён занято, тем больше вероятность случайно использовать одно из них в качестве переменной. К примеру, весьма вероятно, что вы захотите использовать имя `max` для чего-то в своей программе. Поскольку встроенная в JavaScript функция `max` безопасно упакована в объект `Math`, нам не нужно волноваться по поводу того, что мы её перезапишем.

Многие языки остановят вас, или хотя бы предупредят, когда вы будете определять переменную с именем, которое уже занято. JavaScript не будет этого делать, поэтому будьте осторожны.

(((Math.cos function)))(((Math.sin function)))(((Math.tan function)))(((Math.acos function)))(((Math.asin function)))(((Math.atan function)))(((Math.PI constant)))(((cosine)))(((sine)))(((tangent)))(((PI constant)))(((pi)))Возвращаясь к объекту Math. Если вам нужна ((тригонометрия)), он вам поможет. У него есть `cos` (косинус), `sin` (синус), и `tan` (тангенс), их обратные функции — `acos`, `asin`, и `atan`. Число π (pi) – или, по крайней мере, его близкая аппроксимация, помещающаяся в число JavaScript,- также доступна как `Math.PI`. (Есть такая старая традиция в программировании — записывать имена ((констант)) в верхнем регистре).

// test: no

[source,javascript]
----
function randomPointOnCircle(radius) {
  var angle = Math.random() * 2 * Math.PI;
  return {x: radius * Math.cos(angle),
          y: radius * Math.sin(angle)};
}
console.log(randomPointOnCircle(2));
// → {x: 0.3667, y: 1.966}
----

Если вы незнакомы с синусами и косинусами – не отчаивайтесь. Мы их будем использовать в link:13_dom.html#sin_cos[Главе 13], и тогда я их объясню.

(((Math.random function)))(((random number)))В предыдущем примере используется `Math.random`. Это функция, возвращающая при каждом вызове новое псевдослучайное число между нулём и единицей (включая ноль).

// test: no

[source,javascript]
----
console.log(Math.random());
// → 0.36993729369714856
console.log(Math.random());
// → 0.727367032552138
console.log(Math.random());
// → 0.40180766698904335
----

(((pseudorandom number)))(((random number)))Хотя компьютеры – машины детерминистские (они всегда реагируют одинаково на одни и те же входные данные), возможно заставить их выдавать кажущиеся случайными номера. Для этого машина хранит у себя во внутреннем состоянии несколько номеров. Каждый раз, когда идёт запрос на случайный номер, она выполняет разные сложные детерминистские вычисления и возвращает часть результата вычислений. Этот результат она использует для того, чтобы изменить своё внутреннее состояние, поэтому следующий “случайный” номер получается другим.

(((rounding)))(((Math.floor function)))Если вам нужно целое случайное число, а не дробь, вы можете использовать `Math.floor` (округляет число вниз до ближайшего целого) на результате `Math.random`.

// test: no

[source,javascript]
----
console.log(Math.floor(Math.random() * 10));
// → 2
----

Умножая случайное число на 10, получаем номер от нуля до 10 (включая ноль). Так как `Math.floor` округляет вниз, мы получим число от 0 до 9 включительно.

(((Math.ceil function)))(((Math.round function)))Есть также функция `Math.ceil` (“ceiling” – потолок, которая округляет вверх до ближайшего целого) и `Math.round` (округляет до ближайшего целого).

== Объект global ==

(((global object)))(((window variable)))(((global scope)))(((scope)))(((object)))К глобальной области видимости, где живут глобальные переменные, vожно получить доступ так же, как к объекту. Каждая глобальная переменная является ((свойством)) этого объекта. В ((браузер))ах глобальная область видимости хранится в переменной `window`.

// test: no

[source,javascript]
----
var myVar = 10;
console.log("myVar" in window);
// → true
console.log(window.myVar);
// → 10
----

== Итог ==

Объекты и массивы (которые представляют из себя подвид объектов) позволяют сгруппировать несколько величин в одну. В принципе, это позволяет нам засунуть несколько связанных между собой вещей в мешок и бегать с ним кругами, вместо того, чтобы пытаться сгребать все эти вещи руками и пытаться держать их каждую по отдельности.

У большинства величин в JavaScript есть свойства, за исключением `null` и `undefined`. Мы получаем доступ к ним через `value.propName` или `value["propName"]`. Объекты используют имена для хранения свойств и хранят более-менее фиксированное их количество. Массивы обычно содержат переменное количество сходных по типу величин, и используют числа (начиная с нуля) в качестве имён этих величин.

Также в массивах _есть_ именованные свойства, такие как `length`, и несколько методов. Методы – это функции, живущие среди свойств и (обычно) работающие над той величиной, чьим свойством они являются.

Объекты также могут работать как карты, ассоциируя значения с именами. Оператор `in` используется для выяснения того, содержит ли объект свойство с данным именем. Это же ключевое слово используется в цикле `for` (`for (var name in object)`) для перебора всех свойств объекта.

== Упражнения ==

=== Сумма диапазона ===

(((summing (exercise))))Во link:00_intro.html#intro[введении] был упомянут удобный способ подсчёта сумм диапазонов чисел:

// test: no

[source,javascript]
----
console.log(sum(range(1, 10)));
----

(((range function)))(((sum function)))Напишите функцию `range`, принимающую два аргумента, `start` и `end`, и возвращающую массив, который содержит все числа от `start` до `end` включительно.

Затем напишите функцию `sum`, принимающую массив чисел и возвращающую их сумму. Запустите указанную выше инструкцию и убедитесь, что она возвращает 55.

(((optional argument)))В качестве бонуса дополните функцию `range`, чтобы она могла принимать необязательный третий аргумент – “шаг” для построения массива. Если он не задан, шаг равен единице. Вызов функции `range(1, 10, 2)` должен будет вернуть `[1, 3, 5, 7, 9]`. Убедитесь, что она работает с отрицательным шагом так, что вызов `range(5, 2, -1)` возвращает `[5, 4, 3, 2]`.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.

console.log(range(1, 10));
// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
console.log(range(5, 2, -1));
// → [5, 4, 3, 2]
console.log(sum(range(1, 10)));
// → 55
----
endif::interactive_target[]

!!hint!!

(((summing (exercise))))(((array,creation)))(((square
brackets)))Building up an array is most easily done by first
initializing a variable to `[]` (a fresh, empty array) and repeatedly
calling its `push` method to add a value. Don't forget to return the
array at the end of the function.

(((array,indexing)))(((comparison)))Since the end boundary is
inclusive, you'll need to use the `<=` operator rather than simply `<`
to check for the end of your loop.

(((arguments object)))To check whether the optional step argument was
given, either check `arguments.length` or compare the value of the
argument to `undefined`. If it wasn't given, simply set it to its
((default value)) (1) at the top of the function.

(((range function)))(((for loop)))Having `range` understand negative
step values is probably best done by writing two separate loops—one
for counting up and one for counting down—because the comparison that
checks whether the loop is finished needs to be `>=` rather than `<=`
when counting downward.

It might also be worthwhile to use a different default step, namely,
-1, when the end of the range is smaller than the start. That way,
`range(5, 2)` returns something meaningful, rather than getting stuck
in an ((infinite loop)).

!!hint!!

=== Обращаем вспять массив ===

(((reversing (exercise))))(((reverse method)))(((array,methods)))У массивов есть метод `reverse`, меняющий порядок элементов в массиве на обратный. В качестве упражнения напишите две функции, `reverseArray` и `reverseArrayInPlace`. Первая получает массив как аргумент и выдаёт _новый_ массив, с обратным порядком элементов. Вторая работает как оригинальный метод `reverse` – она меняет порядок элементов на обратный в том массиве, который был ей передан в качестве аргумента. Не используйте стандартный метод `reverse`.

(((efficiency)))(((pure function)))(((side effect)))Если иметь в виду побочные эффекты и чистые функции из link:03_functions.html#pure[предыдущей главы], какой из вариантов вам кажется более полезным? Какой более эффективным?

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.

console.log(reverseArray(["A", "B", "C"]));
// → ["C", "B", "A"];
var arrayValue = [1, 2, 3, 4, 5];
reverseArrayInPlace(arrayValue);
console.log(arrayValue);
// → [5, 4, 3, 2, 1]
----
endif::interactive_target[]

!!hint!!

(((reversing (exercise))))There are two obvious ways to implement
`reverseArray`. The first is to simply go over the input array from
front to back and use the `unshift` method on the new array to insert
each element at its start. The second is to loop over the input array
backward and use the `push` method. Iterating over an array backward
requires a (somewhat awkward) `for` specification like `(var i =
array.length - 1; i >= 0; i--)`.

Reversing the array in place is harder. You have to be careful not to
overwrite elements that you will later need. Using `reverseArray` or
otherwise copying the whole array (`array.slice(0)` is a good way to
copy an array) works but is cheating.

The trick is to _swap_ the first and last elements, then the
second and second-to-last, and so on. You can do this by looping
over half the length of the array (use `Math.floor` to round down—you
don't need to touch the middle element in an array with an odd
length) and swapping the element at position `i` with the one at
position `array.length - 1 - i`. You can use a local variable to
briefly hold on to one of the elements, overwrite that one with its
mirror image, and then put the value from the local variable in the
place where the mirror image used to be.

!!hint!!

[[list]]
=== Список ===

(((data structure)))(((list (exercise))))(((linked list)))(((object)))(((array)))(((collection)))Объекты могут быть использованы для построения различных структур данных. Часто встречающаяся структура – _список_ (не путайте с массивом). Список – связанный набор объектов, где первый объект содержит ссылку на второй, второй – на третий, и т.п.

// include_code

[source,javascript]
----
var list = {
  value: 1,
  rest: {
    value: 2,
    rest: {
      value: 3,
      rest: null
    }
  }
};
----

В результате объекты формируют цепочку:

image::img/linked-list.svg[alt="A linked list",width="6cm"]

(((structure sharing)))(((memory)))Списки удобны тем, что они могут делиться частью своей структуры. Например, можно сделать два списка, `{value: 0, rest: list}` и `{value: -1, rest: list}`, где `list` – это ссылка на ранее объявленную переменную. Это два независимых списка, при этом у них есть общая структура `list`, которая включает три последних элемента каждого из них. Кроме того, оригинальный список также сохраняет свои свойства как отдельный список из трёх элементов.

Напишите функцию `arrayToList`, которая строит такую структуру, получая в качестве аргумента `[1, 2, 3]`, а также функцию `listToArray`, которая создаёт массив из списка. Также напишите вспомогательную функцию `prepend`, которая получает элемент и создаёт новый список, где этот элемент добавлен спереди к первоначальному списку, и функцию `nth`, которая в качестве аргументов принимает список и число, а возвращает элемент на заданной позиции в списке, или же `undefined` в случае отсутствия такого элемента.

(((recursion)))Если ваша версия `nth` не рекурсивна, тогда напишите её рекурсивную версию.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.

console.log(arrayToList([10, 20]));
// → {value: 10, rest: {value: 20, rest: null}}
console.log(listToArray(arrayToList([10, 20, 30])));
// → [10, 20, 30]
console.log(prepend(10, prepend(20, null)));
// → {value: 10, rest: {value: 20, rest: null}}
console.log(nth(arrayToList([10, 20, 30]), 1));
// → 20
----
endif::interactive_target[]

!!hint!!

(((list (exercise))))(((linked list)))Building up a list is best done
back to front. So `arrayToList` could iterate over the array backward
(see previous exercise) and, for each element, add an object to the
list. You can use a local variable to hold the part of the list that
was built so far and use a pattern like `list = {value: X, rest:
list}` to add an element.

(((for loop)))To run over a list (in `listToArray` and `nth`), a `for`
loop specification like this can be used:

[source,javascript]
----
for (var node = list; node; node = node.rest) {}
----

Can you see how that works? Every iteration of the loop, `node` points
to the current sublist, and the body can read its `value` property to
get the current element. At the end of an iteration, `node` moves to
the next sublist. When that is null, we have reached the end of the
list and the loop is finished.

(((recursion)))The recursive version of `nth` will, similarly, look at
an ever smaller part of the “tail” of the list and at the same time
count down the index until it reaches zero, at which point it can
return the `value` property of the node it is looking at. To get the
zeroeth element of a list, you simply take the `value` property of its
head node. To get element _N_ + 1, you take the __N__th element of the
list that's in this list's `rest` property.

!!hint!!

[[exercise_deep_compare]]
=== Глубокое сравнение ===

(((deep comparison (exercise))))(((comparison)))(((deep comparison)))(((== operator)))Оператор `==` сравнивает переменные объектов, проверяя, ссылаются ли они на один объект. Но иногда полезно было бы сравнить объекты по содержимому.

Напишите функцию `deepEqual`, которая принимает два значения и возвращает `true`, только если это два одинаковых значения или это объекты, свойства которых имеют одинаковые значения, если их сравнивать рекурсивным вызовом `deepEqual`.

(((null)))(((=== operator)))(((typeof operator)))Чтобы узнать, когда сравнивать величины через `===`, а когда – объекты по содержимому, используйте оператор `typeof`. Если он выдаёт `"object"` для обеих величин, значит нужно делать глубокое сравнение. Не забудьте об одном дурацком исключении, случившемся из-за исторических причин: `typeof null` тоже возвращает `"object"`.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.

var obj = {here: {is: "an"}, object: 2};
console.log(deepEqual(obj, obj));
// → true
console.log(deepEqual(obj, {here: 1, object: 2}));
// → false
console.log(deepEqual(obj, {here: {is: "an"}, object: 2}));
// → true
----
endif::interactive_target[]

!!hint!!

(((deep comparison (exercise))))(((typeof operator)))(((object)))(((=== operator)))Your test for whether you are dealing with a
real object will look something like `typeof x == "object" && x !=
null`. Be careful to compare properties only when _both_ arguments are
objects. In all other cases you can just immediately return the result
of applying `===`.

(((for/in loop)))(((in operator)))Use a `for`/`in` loop to go over the
properties. You need to test whether both objects have the same set of
property names and whether those properties have identical values. The
first test can be done by counting the properties in both objects and
returning false if the numbers of properties are different. If they're
the same, then go over the properties of one object, and for each of
them, verify that the other object also has the property. The values
of the properties are compared by a recursive call to `deepEqual`.

(((return value)))Returning the correct value from the function is
best done by immediately returning false when a mismatch is noticed
and returning true at the end of the function.

!!hint!!
