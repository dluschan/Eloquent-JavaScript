:chap_num: 17
:prev_link: 16_canvas
:next_link: 18_forms
:load_files: ["code/chapter/17_http.js", "code/promise.js"]

= HTTP =

[chapterquote="true"]
[quote,Тим Бернес-Ли,Всемирная паутина: Очень короткая личная история]
____
Мечта, ради которой создавалась Сеть – это общее информационное пространство, в котором мы общаемся, делясь информацией. Его универсальность является его неотъемлемой частью: ссылка в гипертексте может вести куда угодно, будь то персональная, локальная или глобальная информация, черновик или выверенный текст.
____

(((Berners-Lee+++,+++ Tim)))(((World Wide Web)))(((HTTP)))_Протокол передачи гипертекста_ (или _Hypertext Transfer Protocol_), уже упомянутый в link:12_browser.html#web[главе 12], представляет собой механизм, посредством которого данные запрашиваются и предоставляются во ((всемирной паутине)) (или ((World Wide Web))). В этой главе более подробно описывается ((протокол)) и объясняется, каким образом JavaScript в ((браузер))е имеет к нему доступ.

== Протокол ==

(((IP address)))Если в ((адресной строке)) браузера набрать _eloquentjavascript.net/17_http.html_, ((браузер)) сначала распознает ((адрес)) сервера, связанный с именем _eloquentjavascript.net_ и попробует открыть ((TCP)) ((соединение)) по 80 ((порт))у – порт для ((HTTP)) по умолчанию. Если ((сервер)) существует и принимает соединение, браузер отправляет что-то вроде:

[source,http]
----
GET /17_http.html HTTP/1.1
Host: eloquentjavascript.net
User-Agent: Название браузера
----

Сервер отвечает по тому же соединению.

[source,http]
----
HTTP/1.1 200 OK
Content-Length: 65585
Content-Type: text/html
Last-Modified: Wed, 09 Apr 2014 10:48:09 GMT

<!doctype html>
... остаток документа
----

Браузер берёт ту часть ((ответ))а, что идёт после пустой строкой и показывает её в виде ((HTML))-документа.

(((HTTP)))Информация, отправленная клиентом, называется _((запрос))ом_. Он начинается со строки:

[source,http]
----
GET /17_http.html HTTP/1.1
----

(((DELETE method)))(((PUT method)))(((GET method)))Первое слово – _((метод))_ ((запрос))а. `GET` означает, что нам нужно _получить_ определённый ресурс. Другие распространённые методы – `DELETE` для удаления, `PUT` для замещения и `POST` для отправки информации. Заметьте, что ((сервер)) не обязан выполнять каждый полученный запрос. Если вы выберете случайный сайт и скажете ему `DELETE` главную страницу – он, скорее всего, откажется.

(((path,URL)))(((Twitter)))Часть после названия ((метод))а – путь к ((ресурс))у, к которому отправлен запрос. В простейшем случае, ресурс – просто ((файл)) на ((сервер))е, но протокол не ограничивается этой возможностью. Ресурс может быть чем угодно, что можно передать _в качестве_ файла. Многие серверы создают ответы на лету. К примеру, если вы откроете http://twitter.com/marijnjh[_twitter.com/marijnjh_], сервер посмотрит в базе данных пользователя _marijnjh_, и если найдёт – создаст страницу профиля этого пользователя.

После пути к ресурсу первая строка запроса упоминает `HTTP/1.1`, чтобы сообщить о ((версии)) ((HTTP)) – ((протокол))а, которую она использует.

(((status code)))((Ответ)) сервера также начинается с версии протокола, за которой идёт статус ответа – сначала код из трёх цифр, затем строчка.

[source,http]
----
HTTP/1.1 200 OK
----

(((200 (HTTP status code))))(((error response)))(((404 (HTTP status code))))Коды статуса, начинающиеся с 2, обозначают успешные запросы. Коды, начинающиеся с 4, означают, что что-то пошло не так. Код 404 – самый знаменитый статус HTTP, обозначающий, что запрошенный ресурс не найден. Коды, начинающиеся с 5, обозначают, что на ((сервер))е произошла ошибка, но не по вине запроса.

[[headers]]
(((HTTP)))За первой строкой запроса или ответа может идти любое число строк _((заголовка))_. Это строки в виде “имя: значение”, которые обозначают дополнительную информацию о запросе или ответе. Эти заголовки были частью ((ответ))а в примере:

----
Content-Length: 65585
Content-Type: text/html
Last-Modified: Wed, 09 Apr 2014 10:48:09 GMT
----

(((Content-Length header)))(((Content-Type header)))(((Last-Modified header)))Тут определяется размер и тип документа, полученного в ответ. В данном случае это HTML-документ размером 65585 байт. Также тут указано, когда документ был изменён последний раз.

(((Host header)))(((domain)))По большей части клиент или сервер определяют, какие ((заголовки)) необходимо включать в ((запрос)) или ((ответ)), хотя некоторые заголовки обязательны. К примеру, `Host`, обозначающий имя хоста, должен быть включён в запрос, потому что один ((сервер)) может обслуживать много имён хостов на одном ((IP-адресе)), и без этого заголовка сервер не узнает, с каким хостом клиент пытается общаться.

(((GET method)))(((DELETE method)))(((PUT method)))(((POST method)))(((body (HTTP))))После заголовков, как запрос, так и ответ могут указать пустую строку, за которой следует _тело_, содержащее передаваемые данные. Запросы `GET` и `DELETE` не пересылают дополнительных данных, а `PUT` и `POST` пересылают. Некоторые ответы, например, сообщения об ошибке, не требуют наличия тела.

== Браузер и HTTP ==

(((HTTP)))Как мы видели в примере, ((браузер)) отправляет запрос, когда мы вводим ((URL)) в ((адресную строку)). Когда в полученном HTML документе содержатся упоминания других файлов, такие, как ((картинки)) или ((файл))ы JavaScript, они тоже запрашиваются с сервера.

(((parallelism)))((Веб-сайт)) средней руки легко может содержать от 10 до 200 ((ресурс))ов. Чтобы иметь возможность запросить их побыстрее, браузеры делают несколько запросов одновременно, а не ждут окончания запросов одного за другим.

(((GET method)))Такие документы всегда запрашиваются через ((запрос))ы `GET`.

[[http_forms]]
На страницах HTML могут быть _((форм))ы_, которые позволяют пользователям вписывать информацию и отправлять её на сервер. Вот пример формы:

[source,text/html]
----
<form method="GET" action="example/message.html">
  <p>Имя: <input type="text" name="name"></p>
  <p>Сообщение:<br><textarea name="message"></textarea></p>
  <p><button type="submit">Отправить</button></p>
</form>
----

(((form)))(((method attribute)))(((GET method)))Код описывает форму с двумя ((поля))ми: маленькое запрашивает имя, а большое – сообщение. При нажатии ((кнопки)) «Отправить» информация из этих полей будет закодирована в _((строку запроса))_ (или _((query string))_). Когда атрибут `method` элемента `<form>` равен `GET`, или когда он вообще не указан, строка запроса помещается в URL из поля `action`, и браузер делает запрос `GET` с этим URL.

[source,text/html]
----
GET /example/message.html?name=Jean&message=Yes%3F HTTP/1.1
----

(((ampersand character)))Начало ((строки запроса)) обозначено ((знаком вопроса)). После этого идут пары имён и значений, соответствующие атрибуту `name` полей формы и содержимому этих полей. Амперсанд (`&`) используется для их разделения.

(((escaping,in URLs)))(((hexadecimal number)))(((percent sign)))(((URL encoding)))(((encodeURIComponent function)))(((decodeURIComponent function)))Сообщение, отправляемое в примере, содержит строку “Yes?”, хотя знак вопроса и заменён каким-то странным кодом. Некоторые символы в строке запроса нужно экранировать (escape). Знак вопроса в том числе, и он представляется кодом `%3F`. Есть какое-то неписаное правило, по которому у каждого формата должен быть способ экранировать символы. Это правило под названием _кодирование URL_ использует процент, за которым идут две шестнадцатеричные цифры, которые представляют код символа. В этом случае, число 3F, которое означает 63 в десятичной системе счисления, - это код знака вопроса. У JavaScript есть функции `encodeURIComponent` и `decodeURIComponent` для кодирования и раскодирования этого формата.

[source,javascript]
----
console.log(encodeURIComponent("Hello & goodbye"));
// → Hello%20%26%20goodbye
console.log(decodeURIComponent("Hello%20%26%20goodbye"));
// → Hello & goodbye
----

(((body (HTTP))))(((POST method)))Если мы поменяем атрибут `method` в форме в предыдущем примере на `POST`, запрос ((HTTP)) с отправкой ((формы)) пройдёт при помощи метода `POST`, который отправит ((строку запроса)) в теле запроса, вместо добавления её к URL.

[source,http]
----
POST /example/message.html HTTP/1.1
Content-length: 24
Content-type: application/x-www-form-urlencoded

name=Jean&message=Yes%3F
----

По соглашению метод `GET` используется для запросов, не имеющих побочных эффектов, таких, как поиск. Запросы, которые что-то меняют на сервере – создают новый аккаунт или размещают сообщение, должны отправляться методом `POST`. Клиентские программы типа браузера знают, что просто так делать запросы формата `POST` не нужно, и иногда незаметно для пользователя делают запросы `GET` – к примеру, чтобы загрузить заранее контент, который может вскоре понадобиться пользователю.

В link:18_forms.html#forms[следующей главе] мы вернёмся к формам и поговорим про то, как мы можем делать их при помощи JavaScript.

[[xmlhttprequest]]
== XMLHttpRequest ==

(((capitalization)))(((XMLHttpRequest)))((Интерфейс)), через который JavaScript в браузере может делать HTTP-запросы, называется `XMLHttpRequest` (заметьте, как прыгает размер букв). Он был разработан в ((Microsoft)) для ((браузер))а ((Internet Explorer)) в конце 1990-х. В это время формат ((XML)) был _очень_ популярным в мире ((бизнес-программ)) – а в этом мире Microsoft всегда чувствовал себя, как дома. Он был настолько популярным, что аббревиатура XML была пришпилена перед названием интерфейса для работы с ((HTTP)), хотя последний с XML вообще не связан.

(((modularity)))(((interface,design)))И всё же имя не полностью бессмысленное. Интерфейс позволяет разбирать вам ответы, как если бы это были документы XML. Смешивать две разные вещи (запрос и ((разбор)) ответа) в одну – это, конечно, отвратительный дизайн, но что поделаешь.

Когда интерфейс `XMLHttpRequest` был добавлен в Internet Explorer, стало можно делать вещи, которые раньше было делать очень сложно. К примеру, сайты стали показывать списки из подсказок, пока пользователь вводит что-либо в текстовое поле. Скрипт отправляет текст на сервер через ((HTTP)) одновременно с набором текста пользователем. ((Сервер)), у которого есть ((база данных)) для возможных вариантов ввода, ищет среди записей ((подходящие)) и возвращает их назад для показа. Это выглядело очень круто – люди до этого привыкли ждать перезагрузки всей страницы после каждого взаимодействия с сайтом.

(((compatibility)))(((Firefox)))(((XMLHttpRequest)))Другой важный браузер того времени ((Mozilla)) (позже Firefox), не хотел отставать. Чтобы разрешить делать сходные вещи, Mozilla скопировал интерфейс вместе с названием. Следующее поколение ((браузеров)) последовало этому примеру, и сегодня `XMLHttpRequest` является стандартом de facto.

== Отправка запроса ==

(((open method)))(((send method)))(((XMLHttpRequest)))Чтобы отправить простой ((запрос)), мы создаём объект запроса с конструктором `XMLHttpRequest` и вызываем методы `open` и `send`.

// test: trim

[source,javascript]
----
var req = new XMLHttpRequest();
req.open("GET", "example/data.txt", false);
req.send(null);
console.log(req.responseText);
// → This is the content of data.txt
----

(((path,URL)))(((open method)))(((relative URL)))(((slash character)))Метод `open` настраивает запрос. В нашем случае мы решили сделать `GET` запрос на файл _example/data.txt_. ((URL)), не начинающиеся с названия протокола (например, _http:_) называются относительными, то есть они интерпретируются относительно текущего документа. Когда они начинаются со слеша (/), они заменяют текущий путь – часть после названия сервера. В ином случае часть текущего пути вплоть до последнего слеша помещается перед относительным URL.

(((send method)))(((GET method)))(((body (HTTP))))(((responseText property)))После открытия запроса мы можем отправить его методом `send`. Аргументом служит тело запроса. Для запросов `GET` может использоваться `null`. Если третий аргумент для `open` был `false`, то `send` завершится только после того, как был получен ответ на наш запрос. Для получения тела ответа мы можем прочесть свойство `responseText` объекта `request`.

(((status property)))(((statusText property)))(((header)))(((getResponseHeader method)))Из объекта `response` можно получить и другую информацию. ((Код статуса)) доступен в свойстве `status`, а текст статуса – в `statusText`. Заголовки можно прочесть из `getResponseHeader`.

// test: no

[source,javascript]
----
var req = new XMLHttpRequest();
req.open("GET", "example/data.txt", false);
req.send(null);
console.log(req.status, req.statusText);
// → 200 OK
console.log(req.getResponseHeader("content-type"));
// → text/plain
----

(((case sensitivity)))(((capitalization)))Названия заголовков не чувствительны к регистру. Они обычно пишутся с заглавной буквы в начале каждого слова, например “Content-Type”, но “content-type” или “cOnTeNt-TyPe” будут описывать один и тот же заголовок.

(((Host header)))(((setRequestHeader method)))Браузер сам добавит некоторые ((заголовки)), такие, как “Host” и другие, которые нужны серверу, чтобы вычислить размер тела. Но вы можете добавлять свои собственные заголовки методом `setRequestHeader`. Это нужно для особых случаев и требует содействия ((сервер))а, к которому вы обращаетесь – он волен игнорировать заголовки, которые он не умеет обрабатывать.

== Асинхронные запросы ==

(((XMLHttpRequest)))(((event handling)))(((blocking)))(((synchronous I/O)))(((responseText property)))(((send method)))В примере запрос был окончен, когда заканчивается вызов `send`. Это удобно потому, что свойства вроде `responseText` становятся доступными сразу. Но это значит, что программа наша будет ожидать, пока ((браузер)) и сервер общаются меж собой. При плохой связи, слабом сервере или большом файле это может занять длительное время. Это плохо ещё и потому, что никакие обработчики событий не сработают, пока программа находится в режиме ожидания – документ перестанет реагировать на действия пользователя.

(((XMLHttpRequest)))(((open method)))(((asynchronous I/O)))Если третьим аргументом `open` мы передадим `true`, запрос будет _асинхронным_. Это значит, что при вызове `send` запрос ставится в очередь на отправку. Программа продолжает работать, а браузер позаботиться об отправке и получении данных в фоне.

Но пока запрос обрабатывается, мы не получим ответ. Нам нужен механизм оповещения о том, что данные поступили и готовы.

(((event handling)))(((load event)))Для этого нам нужно будет слушать событие `"load"` объекта запроса.

[source,javascript]
----
var req = new XMLHttpRequest();
req.open("GET", "example/data.txt", true);
req.addEventListener("load", function() {
  console.log("Done:", req.status);
});
req.send(null);
----

(((asynchronous programming)))(((callback function)))Так же, как вызов `requestAnimationFrame` в link:15_game.html#game[главе 15], этот код вынуждает нас использовать асинхронный стиль программирования, оборачивая в функцию тот код, который должен быть выполнен после запроса, и устраивая вызов этой функции в нужное время. Мы вернёмся к этому link:17_http.html#promises[позже].

== Получение данных XML ==

(((documentElement property)))(((responseXML property)))Когда ресурс, возвращённый объектом `XMLHttpRequest`, является документом ((XML)), свойство `responseXML` будет содержать разобранное представление о документе. Оно работает схожим образом с обсуждавшимся в link:13_dom.html#dom[главе 13] ((DOM)), за исключением того, что у него нет присущей HTML функциональности навроде свойства `style`. Объект, содержащийся в `responseXML`, соответствует объекту `document`. Его свойство `documentElement` ссылается на внешний тег документа XML. В следующем документе (_example/fruit.xml_) таким тегом будет `<fruits>`:

[source,application/xml]
----
<fruits>
  <fruit name="banana" color="yellow"/>
  <fruit name="lemon" color="yellow"/>
  <fruit name="cherry" color="red"/>
</fruits>
----

Мы можем получить такой файл следующим образом:

// test: no

[source,javascript]
----
var req = new XMLHttpRequest();
req.open("GET", "example/fruit.xml", false);
req.send(null);
console.log(req.responseXML.querySelectorAll("fruit").length);
// → 3
----

(((data format)))Документы XML можно использовать для обмена с сервером структурированной информацией. Их форма – вложенные теги – хорошо подходит для хранения большинства данных, ну или по крайней мере лучше, чем текстовые файлы. Интерфейс DOM неуклюж в плане извлечения информации, и ((XML)) документы получаются довольно многословными. Часто лучше общаться при помощи данных в формате ((JSON)), которые проще читать и писать – как программам, так и людям.

[source,javascript]
----
var req = new XMLHttpRequest();
req.open("GET", "example/fruit.json", false);
req.send(null);
console.log(JSON.parse(req.responseText));
// → {banana: "yellow", lemon: "yellow", cherry: "red"}
----

[[http_sandbox]]
== Песочница для HTTP ==

(((sandbox)))((HTTP))-запросы из скриптов веб-страницы вызывают вопросы касаемо ((безопасности)). Человек, контролирующий скрипт, может иметь интересы отличные от интересов пользователя, на чьём компьютере он запущен. Конкретно, если я зашёл на сайт _themafia.org_, я не хочу, чтобы их скрипты могли делать запросы к _mybank.com_, используя информацию моего ((браузер))а в качестве идентификатора, и давая команду отправить все мои деньги на какой-нибудь счёт ((мафии)).

((Вебсайты)) могут защитить себя от подобных ((атак)), но для этого требуются определённые усилия, и многие сайты с этим не справляются. Из-за этого браузеры защищают их, запрещая скриптам делать запросы к другим _((домен))ам_ (именам вроде _themafia.org_ и _mybank.com_).

(((Access-Control-Allow-Origin header)))(((cross-domain request)))Это может мешать разработке систем, которым надо иметь доступ к разным доменам по уважительной причине. К счастью, ((сервер)) может включать в ((ответ)) следующий ((заголовок)), поясняя браузерам, что запрос может прийти с других доменов:

----
Access-Control-Allow-Origin: *
----

== Абстрагируем запросы ==

(((HTTP)))(((XMLHttpRequest)))(((backgroundReadFile function)))В link:10_modules.html#amd[главе 10] в нашей реализации модульной системы AMD мы использовали гипотетическую функцию `backgroundReadFile`. Она принимала имя файла и функцию, и вызывала эту функцию после прочтения содержимого файла. Вот простая реализация этой функции:

// include_code

[source,javascript]
----
function backgroundReadFile(url, callback) {
  var req = new XMLHttpRequest();
  req.open("GET", url, true);
  req.addEventListener("load", function() {
    if (req.status < 400)
      callback(req.responseText);
  });
  req.send(null);
}
----

(((XMLHttpRequest)))Простая ((абстракция)) упрощает использование `XMLHttpRequest` для простых `GET`-запросов. Если вы пишете программу, которая делает HTTP-запросы, будет неплохо использовать вспомогательную функцию, чтобы вам не приходилось всё время повторять уродливый шаблон `XMLHttpRequest`.

(((function,as value)))(((callback function)))Аргумент `callback` (обратный вызов) – термин, часто использующийся для описания подобных функций. Функция обратного вызова передаётся в другой код, чтобы он мог “позвать нас обратно” позже.

(((library)))Несложно написать свою вспомогательную функцию HTTP, специально скроенную под вашу программу. Предыдущая делает только `GET`-запросы, и не даёт нам контроля над заголовками или телом запроса. Можно написать ещё один вариант для запроса `POST`, или более общий, поддерживающий разные запросы. Многие библиотеки JavaScript предлагают обёртки для `XMLHttpRequest`.

(((user experience)))(((error response)))Основная проблема с приведённой обёрткой – обработка ((ошибок)). Когда запрос возвращает ((код статуса)), обозначающий ошибку (от 400 и выше), он ничего не делает. В некоторых случаях это нормально, но представьте, что мы поставили индикатор загрузки на странице, показывающий, что мы получаем информацию. Если запрос не удался, потому что сервер упал или ((соединение)) прервано, страница будет делать вид, что она чем-то занята. Пользователь подождёт немного, потом ему надоест и он решит, что сайт какой-то дурацкий.

Нам нужен вариант, в котором мы получаем предупреждение о неудачном запросе, чтобы мы могли принять меры. Например, мы можем убрать сообщение о загрузке и сообщить пользователю, что что-то пошло не так.

(((exception handling)))(((callback function)))(((error handling)))(((asynchronous programming)))(((try keyword)))(((stack)))Обработка ошибок в асинхронном коде ещё сложнее, чем в синхронном. Поскольку нам часто приходится отделять часть работы и размещать её в функции обратного вызова, область видимости блока `try` теряет смысл. В следующем коде исключение _не_ будет поймано, потому что вызов `backgroundReadFile` возвращается сразу же. Затем управление уходит из блока `try`, и функция из него не будет вызвана.

// test: no

[source,javascript]
----
try {
  backgroundReadFile("example/data.txt", function(text) {
    if (text != "expected")
      throw new Error("That was unexpected");
  });
} catch (e) {
  console.log("Hello from the catch block");
}
----

[[getURL]]
(((HTTP)))(((getURL function)))(((exception)))Чтобы обрабатывать неудачные запросы, придётся передавать дополнительную функцию в нашу обёртку, и вызывать её в случае проблем. Другой вариант – использовать соглашение, что если запрос не удался, то в функцию обратного вызова передаётся дополнительный аргумент с описанием проблемы. Пример:

// include_code

[source,javascript]
----
function getURL(url, callback) {
  var req = new XMLHttpRequest();
  req.open("GET", url, true);
  req.addEventListener("load", function() {
    if (req.status < 400)
      callback(req.responseText);
    else
      callback(null, new Error("Request failed: " +
                               req.statusText));
  });
  req.addEventListener("error", function() {
    callback(null, new Error("Network error"));
  });
  req.send(null);
}
----

(((error event)))Мы добавили обработчик события `"error"`, который сработает при проблеме с вызовом. Также мы вызываем функцию ((обратного вызова)) с аргументом `Error`, когда запрос завершается со ((статус))ом, говорящим об ошибке.

Код, использующий `getURL`, должен проверять не возвращена ли ошибка, и обрабатывать её, если она есть.

[source,javascript]
----
getURL("data/nonsense.txt", function(content, error) {
  if (error != null)
    console.log("Failed to fetch nonsense.txt: " + error);
  else
    console.log("nonsense.txt: " + content);
});
----

(((uncaught exception)))(((exception handling)))(((try keyword)))С исключениями это не помогает. Когда мы совершаем последовательно несколько асинхронных действий, исключение в любой точке цепочки в любом случае (если только вы не обернули каждый обработчик в свой блок `try/catch`) вывалится на верхнем уровне и прервёт всю цепочку.

[[promises]]
== Обещания ==

(((promise)))(((asynchronous programming)))(((callback function)))(((readability)))(((uncaught exception)))Тяжело писать асинхронный код для сложных проектов в виде простых обратных вызовов. Очень легко забыть проверку на ошибку или позволить неожиданному исключению резко прервать программу. Кроме того, организация правильной обработки ошибок и проход ошибки через несколько последовательных обратных вызовов очень утомительна.

(((future)))(((ECMAScript 6)))Предпринималось множество попыток решить эту проблему дополнительными абстракциями. Одна из наиболее удачных попыток называется _обещаниями_ (_promises_). Обещания оборачивают асинхронное действие в объект, который может передаваться и которому нужно сделать какие-то вещи, когда действие завершается или не удаётся. Такой интерфейс уже стал частью текущей версии JavaScript, а для старых версий его можно использовать в виде библиотеки.

((Интерфейс)) обещаний не особенно интуитивно понятный, но мощный. В этой главе мы лишь частично опишем его. Больше информации можно найти на https://www.promisejs.org/[_www.promisejs.org_].

(((Promise constructor)))Для создания объекта обещание мы вызываем конструктор `Promise`, задавая ему функцию инициализации асинхронного действия. Конструктор вызывает эту функцию и передаёт ей два аргумента, которые сами также являются функциями. Первая должна вызываться в удачном случае, другая – в неудачном.

(((HTTP)))(((get function)))И вот наша обёртка для запросов `GET`, которая на этот раз возвращает обещание. Теперь мы просто назовём его `get`.

// include_code

[source,javascript]
----
function get(url) {
  return new Promise(function(succeed, fail) {
    var req = new XMLHttpRequest();
    req.open("GET", url, true);
    req.addEventListener("load", function() {
      if (req.status < 400)
        succeed(req.responseText);
      else
        fail(new Error("Request failed: " + req.statusText));
    });
    req.addEventListener("error", function() {
      fail(new Error("Network error"));
    });
    req.send(null);
  });
}
----

Заметьте, что ((интерфейс)) к самой функции упростился. Мы передаём ей URL, а она возвращает ((обещание)). Оно работает как _обработчик_ для выходных данных запроса. У него есть метод `then`, который вызывается с двумя функциями: одной для обработки успеха, другой – для неудачи.

[source,javascript]
----
get("example/data.txt").then(function(text) {
  console.log("data.txt: " + text);
}, function(error) {
  console.log("Failed to fetch data.txt: " + error);
});
----

(((chaining)))Пока это всё ещё один из способов выразить то же, что мы уже сделали. Только когда у вас появляется цепь событий, становится видна заметная разница.

(((then method)))Вызов `then` производит новое ((обещание)), чей результат (значение, передающееся в обработчики успешных результатов) зависит от значения, возвращаемого первой переданной нами в `then` функцией. Эта функция может вернуть ещё одно обещание, обозначая что проводится дополнительная асинхронная работа. В этом случае обещание, возвращаемое `then` само по себе будет ждать обещания, возвращённого функцией-обработчиком, и успех или неудача произойдут с таким же значением. Когда функция-обработчик возвращает значение, не являющееся обещанием, обещание, возвращаемое `then`, становится успешным, в качестве результата используя это значение.

(((then method)))(((chaining)))Значит, вы можете использовать `then` для изменения результата обещания. К примеру, следующая функция возвращает обещание, чей результат – содержимое с данного URL, разобранное как ((JSON)):

// include_code

[source,javascript]
----
function getJSON(url) {
  return get(url).then(JSON.parse);
}
----

(((error handling)))Последний вызов `then` не обозначил обработчик неудач. Это допустимо. Ошибка будет передана в обещание, возвращаемое через `then`, а ведь это нам и надо – `getJSON` не знает, что делать, когда что-то идёт не так, но есть надежда, что вызывающий её код это знает.

В качестве примера, показывающего использование ((обещаний)), мы напишем программу, получающую число JSON-файлов с сервера, и показывающую во время исполнения запроса слово _загрузка_. Файлы содержат информацию о людях и ссылки на другие файлы с информацией о других людях в свойствах типа отец, мать, супруг.

(((error message)))(((JSON)))Нам нужно получить имя матери супруга из _example/bert.json_. В случае проблем нам нужно убрать текст _загрузка_ и показать сообщение об ошибке. Вот как это можно делать при помощи ((обещаний)):

[source,text/html]
----
<script>
  function showMessage(msg) {
    var elt = document.createElement("div");
    elt.textContent = msg;
    return document.body.appendChild(elt);
  }

  var loading = showMessage("Загрузка...");
  getJSON("example/bert.json").then(function(bert) {
    return getJSON(bert.spouse);
  }).then(function(spouse) {
    return getJSON(spouse.mother);
  }).then(function(mother) {
    showMessage("Имя " + mother.name);
  }).catch(function(error) {
    showMessage(String(error));
  }).then(function() {
    document.body.removeChild(loading);
  });
</script>
----

(((error handling)))(((catch method)))(((then method)))(((readability)))(((program size)))Итоговая программа относительно компактна и читаема. Метод `catch` схож с `then`, но он ожидает только обработчик неудачного результата и в случае успеха передаёт дальше неизменённый результат. Исполнение программы будет продолжено обычным путём после отлова исключения – так же, как в случае с `try/catch`. Таким образом, последний `then`, удаляющий сообщение о загрузке, выполняется в любом случае, даже в случае неудачи.

(((asynchronous programming)))(((domain-specific language)))Можно представлять себе, что интерфейс обещаний – это отдельный язык для асинхронной обработки ((исполнения программы)). Дополнительные вызовы методов и функций, которые нужны для его работы, придают коду несколько странный вид, но не настолько неудобный, как обработка всех ошибок вручную.

== Цените HTTP ==

(((client)))(((HTTP)))При создании системы, в которой программа на JavaScript в ((браузер))е (клиентская) ((общается)) с ((сервер))ной программой, можно использовать несколько вариантов моделирования такого общения.

(((network)))(((abstraction)))Общепринятый метод – _((удалённые вызовы процедур))_. В этой модели общение идёт по шаблону обычных вызовов функций, только функции эти выполняются на другом компьютере. Вызов заключается в создании запроса на сервер, в который входят имя функции и аргументы. Ответ на запрос включает возвращаемое значение.

При использовании удалённых вызовов процедур HTTP служит лишь транспортом для общения, и вы, скорее всего, напишете слой абстракции, который спрячет его полностью.

(((media type)))(((document format)))Другой подход – построить свою систему общения на концепции ((ресурс))ов и ((метод))ов ((HTTP)). Вместо удалённого вызова процедуры по имени `addUser` вы делаете запрос `PUT` к `/users/larry`. Вместо кодирования свойств пользователя в аргументах функции вы определяете формат документа или используете существующий формат, который будет представлять пользователя. Тело `PUT`-запроса, создающего новый ресурс, будет просто документом этого формата. Ресурс получается через запрос `GET` к его URL (`/user/larry`), который возвращает представляющий этот ресурс документ.

Второй подход упрощает использование некоторых возможностей HTTP, например поддержки кеширования ресурсов (копия ресурса хранится на стороне клиента). Также он способствует созданию согласованного интерфейса, потому что думать в терминах ресурсов проще, чем в терминах функций.

== Безопасность и HTTPS ==

(((man-in-the-middle)))(((security)))(((HTTPS)))Данные путешествуют по интернету по длинному и опасному пути. Чтобы добраться до пункта назначения, им надо попрыгать через всякие места, начиная от Wi-Fi ((сети)) кофейни до сетей, контролируемых разными организациями и государствами. В любой точке пути их могут прочитать или даже поменять.

(((tampering)))Если нужно хранить что-либо в секрете, например ((пароли)) к ((емейл))у, или данным необходимо прийти в пункт назначения в неизменном виде — таким, например, как номер банковского счёта, на который вы переводите деньги,- простого HTTP недостаточно.

indexsee:[Secure HTTP,HTTPS]
(((cryptography)))(((encryption)))Безопасный протокол ((HTTP)), ((URL)) которого начинаются с _https://_, оборачивает HTTP-трафик так, чтобы его было сложнее прочитать и поменять. Сначала клиент подтверждает, что сервер – тот, за кого себя выдаёт, требуя с сервера представить криптографический ((сертификат)), выданный авторитетной стороной, которую признаёт ((браузер)). Потом, все данные, проходящие через ((соединение)), шифруются так, чтобы предотвратить прослушку и изменение.

Таким образом, когда всё работает правильно, ((HTTPS)) предотвращает как случаи, когда кто-то притворяется другим веб-сайтом, с которым вы общаетесь, так и случаи прослушки вашего общения. Он не идеален, и уже были случаи, когда HTTPS не справлялся с работой из-за поддельных или краденых сертификатов или сломанных программ. Тем не менее, с HTTP очень легко сделать что-то плохое, а взлом HTTPS требует таких усилий, которые могут прикладывать только государственные структуры или очень серьёзные криминальные организации.

== Итог ==

В этой главе мы увидели, что HTTP – это протокол доступа к ресурсам в интернете. _Клиент_ отправляет запрос, содержащий метод (обычно `GET`), и путь, который определяет ресурс. _Сервер_ решает, что ему делать с запросом и отвечает с кодом статуса и телом ответа. Запросы и ответы могут содержать заголовки, в которых передаётся дополнительная информация.

Браузеры делают `GET`-запросы для получения ресурсов, необходимых для показа страницы. Страница может содержать формы, которые позволяют информации, введённой пользователем, быть отправленной в запросе, который создаётся после отправки формы. Вы узнаете об этом больше в link:18_forms.html#forms[следующей главе].

Интерфейс, через который JavaScript делает HTTP-запросы из браузера, называется `XMLHttpRequest`. Можно игнорировать приставку “XML” (но писать её всё равно нужно). Использовать его можно двумя способами: синхронным, который блокирует всю работу до окончания выполнения запроса, и асинхронным, который требует установки обработчика событий, отслеживающего окончание запроса. Почти во всех случаях предпочтительным является асинхронный способ. Создание запроса выглядит так:

[source,javascript]
----
var req = new XMLHttpRequest();
req.open("GET", "example/data.txt", true);
req.addEventListener("load", function() {
  console.log(req.status);
});
req.send(null);
----

Асинхронное программирование – непростая вещь. _Обещания_ – интерфейс, который делает её проще, помогая направлять сообщения об ошибках и исключения к нужному обработчику, и абстрагируя некоторые повторяющиеся элементы, подверженные ошибкам.

== Упражнения ==

[[exercise_accept]]
=== Согласование содержания ===

(((Accept header)))(((media type)))(((document format)))(((content negotiation (exercise))))Одна из вещей, которые HTTP умеет делать, но которую мы не обсуждали, называется _согласованием содержания_ (_content negotiation_). Заголовок `Accept` в запросе можно использовать для сообщения серверу того, какие типы документов клиент желает получить. Многие серверы его игнорируют, но когда сервер знает о разных способах кодирования ресурса, он может взглянуть на заголовок и отправить тот, который предпочитает клиент.

(((media type)))(((MIME type)))URL http://eloquentjavascript.net/author[_eloquentjavascript.net/author_] настроен на ответ как прямым текстом, так и HTML или JSON, в зависимости от запроса клиента. Эти форматы определяются стандартизированными _типами содержимого_ `text/plain`, `text/html` и `application/json`.

(((setRequestHeader method)))(((XMLHttpRequest)))Отправьте запрос для получения всех трёх форматов этого ресурса. Используйте метод `setRequestHeader` объекта `XMLHttpRequest` для установки заголовка `Accept` в один из нужных типов содержимого. Убедитесь, что вы устанавливаете заголовок _после_ `open`, но _перед_ `send`.

Наконец, попробуйте запросить содержимое типа `application/rainbows+unicorns` и посмотрите, что произойдёт.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.
----

endif::interactive_target[]

!!hint!!

(((synchronous I/O)))(((content negotiation (exercise))))See the
various examples of using an `XMLHttpRequest` in this chapter for an
example of the method calls involved in making a request. You can use
a synchronous request (by setting the third parameter to `open` to
`false`) if you want.

(((406 (HTTP status code))))(((Accept header)))Asking for a bogus
media type will return a response with code 406, “Not acceptable”,
which is the code a server should return when it can't fulfill the
`Accept` header.

!!hint!!

=== Ожидание нескольких обещаний ===

(((all function)))(((Promise constructor)))У конструктора `Promise` есть метод `all`, который, получая массив ((обещаний)), возвращает обещание, которое ждёт завершения всех указанных в массиве обещаний. Затем он выдаёт успешный результат и возвращает массив с результатами. Если какие-то из обещаний в массиве завершились неудачно, общее обещание также возвращает неудачу (со значением неудавшегося обещания из массива).

Попробуйте сделать что-либо подобное, написав функцию `all`.

Заметьте, что после завершения обещания (когда оно либо завершилось успешно, либо с ошибкой), оно не может заново выдать ошибку или успех, и дальнейшие вызовы функции игнорируются. Это может упростить обработку ошибок в вашем обещании.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
function all(promises) {
  return new Promise(function(success, fail) {
    // Ваш код.
  });
}

// Проверочный код.
all([]).then(function(array) {
  console.log("Это должен быть []:", array);
});
function soon(val) {
  return new Promise(function(success) {
    setTimeout(function() { success(val); },
               Math.random() * 500);
  });
}
all([soon(1), soon(2), soon(3)]).then(function(array) {
  console.log("Это должен быть [1, 2, 3]:", array);
});
function fail() {
  return new Promise(function(success, fail) {
    fail(new Error("бабах"));
  });
}
all([soon(1), fail(), soon(3)]).then(function(array) {
  console.log("Сюда мы попасть не должны");
}, function(error) {
  if (error.message != "бабах")
    console.log("Неожиданный облом:", error);
});
----

endif::interactive_target[]

!!hint!!

(((all function)))(((Promise constructor)))(((then method)))The
function passed to the `Promise` constructor will have to call `then`
on each of the promises in the given array. When one of them succeeds,
two things need to happen. The resulting value needs to be stored in
the correct position of a result array, and we must check whether this
was the last pending ((promise)) and finish our own promise if it
was.

(((counter variable)))The latter can be done with a counter, which is
initialized to the length of the input array and from which we subtract
1 every time a promise succeeds. When it reaches 0, we are
done. Make sure you take the situation where the input array is empty
(and thus no promise will ever resolve) into account.

Handling failure requires some thought but turns out to be extremely
simple. Just pass the failure function of the wrapping promise to each
of the promises in the array so that a failure in one of them
triggers the failure of the whole wrapper.

!!hint!!
