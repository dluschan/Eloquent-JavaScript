:chap_num: 2
:prev_link: 01_values
:next_link: 03_functions

= Структура программ =

[chapterquote="true"]
[quote, _why, Why's (Poignant) Guide to Ruby]
____
Сердце моё сияет ярко-красным светом под моей тонкой, прозрачной кожей, и им приходится вколоть мне десять кубиков JavaScript, чтобы вернуть меня к жизни (я хорошо реагирую на токсины в крови). От этой фигни у вас враз жабры побледнеют!
____

(((why)))(((Poignant Guide)))В этой главе мы начнём заниматься тем, что уже можно назвать _программированием_. Мы расширим использование языка JavaScript за пределы существительных и фрагментов предложений к более-менее осмысленной прозе.

== Выражения и инструкции ==

(((grammar)))(((syntax)))(((code,structure of)))(((grammar)))(((JavaScript,syntax)))В link:01_values.html#values[Главе 1] мы создавали величины и применяли к ним операторы, получая новые величины. Это важная часть каждой программы, но только лишь часть.

(((literal expression)))Фрагмент кода, результатом работы которого является некая величина, называется _((выражение))м_. Каждая величина, записанная буквально (например, `22` или `"психоанализ"`) тоже является выражением. Выражение, записанное в ((скобках)), также является выражением, как и ((бинарный оператор)), применяемый к двум выражениям или унарный – к одному.

(((nesting,of expressions)))(((human language)))Это часть красоты языкового интерфейса. Выражения могут включать другие выражения так же, как сложноподчинённое предложение состоит из простых. Это позволяет нам комбинировать выражения для создания вычислений любой сложности.

(((statement)))(((semicolon)))(((program)))Если выражение – это фрагмент предложения, то _инструкция_ – это предложение полностью. Программа – это просто список инструкций.

(((syntax)))Простейшая инструкция – это выражение с точкой с запятой после него. Это — программа:

[source,javascript]
----
1;
!false;
----

Правда, это бесполезная программа. ((Выражение)) можно использовать только для получения величины, которая может быть использована в другом выражении, охватывающем это. ((Инструкция)) стоит сама по себе и её применение изменяет что-то в мире программы. Она может выводить что-то на экран (изменение в мире), или менять внутреннее состояние машины таким образом, что это повлияет на следующие за ним инструкции. Эти изменения называются _((побочными эффектами))_. Инструкции в предыдущем примере просто выдают величины `1` и `true`, и сразу их выбрасывают. Они не оказывают никакого влияния на мир программы. При выполнении программы ничего заметного не происходит.

(((programming style)))(((automatic semicolon insertion)))(((semicolon)))В некоторых случаях JavaScript позволяет опускать точку с запятой в конце инструкции. В других случаях она обязательно, или следующая ((строка)) будет расцениваться как часть той же инструкции. Правила, согласно которым можно или нельзя опускать точку с запятой, довольно сложны и увеличивают вероятность ошибиться. В этой книге мы не будем опускать точку с запятой, и я рекомендую делать так же в своих программах, пока вы не накопите опыт.

== Переменные ==

(((syntax)))(((variable,definition)))(((side effect)))(((memory)))Как же программа хранит внутреннее ((состояние))? Как она его запоминает? Мы получали новые величины из старых, но старые величины это не меняло, а новые нужно было использовать сразу, или же они исчезали. Чтобы захватить и хранить их, JavaScript предлагает нечто под названием _переменная_.

[source,javascript]
----
var caught = 5 * 5;
----

(((var keyword)))И это даёт нам второй вид инструкций. Специальное _((ключевое слово))_ (_keyword_) `var` показывает, что в этой инструкции мы объявляем переменную. За ним идёт имя переменной, и, если мы сразу хотим назначить ей значение – оператор `=` и выражение.
And that gives us our second kind of ((statement)).

Пример создаёт переменную под именем `caught` и использует её для захвата числа, которое получается в результате перемножения 5 и 5.

После определения переменной её имя можно использовать в ((выражения))х. Величина переменной будет такой, какое значение в ней сейчас содержится. Пример:

[source,javascript]
----
var ten = 10;
console.log(ten * ten);
// → 100
----

(((underscore character)))(((dollar sign)))(((variable,naming)))Переменные можно называть любым словом, которое не является ключевым (типа `var`). Нельзя использовать пробелы. Цифры тоже можно использовать, но не первым символом в названии. Нельзя использовать знаки пунктуации, кроме символов `$` и `_`.

(((= operator)))(((assignment)))(((variable,assignment)))Переменной присваивают значение не навсегда. Оператор `=` можно использовать на существующих переменных в любое время, чтобы присвоить им новое значение.

[source,javascript]
----
var mood = "лёгкое";
console.log(mood);
// → лёгкое
mood = "тяжёлое";
console.log(mood);
// → тяжёлое
----

(((variable,model of)))(((tentacle (analogy))))Представляйте себе переменные не в виде коробочек, а в виде щупалец. Они не _содержат_ значения – они _хватают_ их. Две переменные могут ссылаться на одно значение. Программа имеет доступ только к значениям, которые они содержат. Когда вам нужно что-то запомнить, вы отращиваете щупальце и держитесь за это, или вы используете существующее щупальце, чтобы удержать это.

image::img/octopus.jpg[alt="Variables as tentacles"]

Пример. Для запоминания количества денег, которые вам должен Василий, вы создаёте переменную. Затем, когда он выплачивает часть долга, вы даёте ей новое значение.

[source,javascript]
----
var vasyaDebt = 140;
vasyaDebt = vasyaDebt - 35;
console.log(vasyaDebt);
// → 105
----

(((undefined)))Когда вы определяете переменную без присваивания ей значения, щупальцу не за что держаться, оно висит в воздухе. Если вы запросите значение пустой переменной, вы получите `undefined`.

(((var keyword)))Одна инструкция `var` может содержать несколько переменных. Определения нужно разделять запятыми.

[source,javascript]
----
var one = 1, two = 2;
console.log(one + two);
// → 3
----

== Ключевые и зарезервированные слова ==

(((syntax)))(((implements (reserved word))))(((interface (reserved word))))(((let keyword)))(((package (reserved word))))(((private (reserved word))))(((protected (reserved word))))(((public (reserved word))))(((static (reserved word))))(((void operator)))(((yield (reserved word))))(((reserved word)))(((variable,naming)))Слова со специальным смыслом, типа `var` – _((ключевые))_. Их нельзя использовать как имена переменных. Также есть несколько слов, “зарезервированных для использования” в ((будуших)) версиях JavaScript. Их тоже нельзя использовать, хотя в некоторых средах исполнения это возможно. Полный их список достаточно большой.

[source,text/plain]
----
break case catch class const continue debugger
default delete do else enum export extends false
finally for function if implements import in
instanceof interface let new null package private
protected public return static super switch this
throw true try typeof var void while with yield
----

Не нужно их запоминать, но имейте в виду, что ошибка может крыться здесь, если ваши определения переменных не работают, как надо.

== Окружение ==

(((standard environment)))Коллекция переменных и их значений, которая существует в определённый момент, называется _((окружение))м_. Когда программа запускается, окружение не пустое. Там всегда есть переменные, являющиеся частью программного ((стандарт))а, и большую часть времени там есть переменные, помогающие взаимодействовать с окружающей системой. К примеру, в ((браузер))е есть переменные и функции для изучения состояния загруженной веб-страницы и влияния на неё, для чтения ввода с ((мыши)) и ((клавиатуры)).

== Функции ==

indexsee:[application (of functions),function application]
indexsee:[invoking (of functions),function application]
indexsee:[calling (of functions),function application]
(((output)))(((function)))(((function,application)))(((alert function)))(((message box)))Многие величины из стандартного окружения имеют тип _function_ (_((функция))_). Функция – отдельный кусочек программы, который можно _использовать_ вместе с другими величинами. К примеру, в ((браузер))е переменная `alert` содержит функцию, которая показывает небольшое ((диалоговое окно)) с сообщением. Используют его так:

[source,javascript]
----
alert("С добрым утром!");
----

image::img/alert.png[alt="An alert dialog",width="8cm"]

(((parameter)))(((function,application)))Выполнение функции называют _вызовом_. Вы можете вызвать функцию, записав ((скобки)) после выражения, которое возвращает значение функции. Обычно вы напрямую используете имя функции в качестве выражения. Величины, которые можно написать внутри скобок, передаются программному коду внутри функции. В примере, функция `alert` использует данную ей строку для показа в диалоговом окне. Величины, передаваемые функциям, называются _((аргумент))_ами функций. Функция `alert` требует один аргумент, но другие могут требовать разное количество аргументов разных типов.

== Функция console.log ==

(((JavaScript console)))(((developer tools)))(((Node.js)))(((console.log)))(((output)))Функция `alert` может использоваться как средство вывода при экспериментах, но закрывать каждый раз это окно вам скоро надоест. В прошлых примерах мы использовали функцию `console.log` для вывода значений. Большинство систем JavaScript (включая все современные ((браузер))ы и Node.js) предоставляют функцию `console.log`, которая выводит величины на _какое-либо_ устройство вывода. В браузерах это ((консоль JavaScript)). Эта часть браузера обычно скрыта – большинство браузеров показывают её по нажатию F12, или Command-Option-I на Маке. Если это не сработало, поищите в меню “web console” или “developer tools”.

ifdef::interactive_target[]

When running the examples, or your own code, on the pages of this
book, `console.log` output will be shown after the example, instead of
in the browser's JavaScript console.

endif::interactive_target[]

[source,javascript]
----
var x = 30;
console.log("the value of x is", x);
// → the value of x is 30
----

(((object)))Хотя в именах ((переменных)) нельзя использовать ((точку)) – она, очевидно, содержится в названии `console.log`. Это оттого, что `console.log` – не простая переменная. Это выражение, возвращающее ((свойство)) `log` переменной `console`. Мы поговорим об этом в link:04_data.html#properties[Главе 4].

[[return_values]]
== Возвращаемые значения ==

(((comparison,of numbers)))(((return value)))(((Math.max function)))(((maximum)))Показ диалогового окна или вывод текста на экран – это _((побочный эффект))_. Множество функций полезны оттого, что они производят эти эффекты. Функции также могут производить значения, и в этом случае им не нужен побочный эффект для того, чтобы быть полезной. К примеру, функция `Math.max` принимает любое количество переменных и возвращает значение самой большой.

[source,javascript]
----
console.log(Math.max(2, 4));
// → 4
----

(((function,application)))(((minimum)))(((Math.min function)))Когда функция производит значение, говорят, что она _возвращает_ значение. Всё, что производит значение – это ((выражение)), то есть вызовы функций можно использовать внутри сложных выражений. К примеру, возвращаемое функцией `Math.min` (противоположность `Math.max`) значение используется как один из аргументов оператора сложения:

[source,javascript]
----
console.log(Math.min(2, 4) + 100);
// → 102
----

В link:03_functions.html#functions[следующей главе] описано, как писать собственные функции.

== prompt и confirm ==

(((dialog box)))(((input)))(((browser)))(((confirm function)))Окружение браузера содержит другие функции, кроме `alert`, которые показывают всплывающие окна. Можно вызвать окно с вопросом и кнопками OK/Cancel при помощи функции `confirm`. Она возвращает булевское значение – `true`, если нажато OK, и `false`, если нажато Cancel.

[source,javascript]
----
confirm("Shall we, then?");
----

image::img/confirm.png[alt="A confirm dialog",width="8cm"]

(((input)))(((prompt function)))(((text input)))Функцию `prompt` можно использовать, чтобы задать “открытый” вопрос. Первый аргумент – вопрос, второй – текст, с которого пользователь начинает. В диалоговое окно можно вписать строку текста, и функция вернёт его в виде строки.

[source,javascript]
----
prompt("Tell me everything you know.", "...");
----

image::img/prompt.png[alt="An prompt dialog",width="8cm"]

Эти функции нечасто используют, потому что нельзя изменять внешний вид этих окон — но они могут пригодиться для экспериментальных программ.

== Управление порядком выполнения программы ==

(((execution order)))(((program)))(((control flow)))Когда в программе больше одной ((инструкции)), они выполняются сверху вниз. В этом примере у программы две инструкции. Первая спрашивает число, вторая, выполняемая следом, показывает его ((квадрат)).

[source,javascript]
----
var theNumber = Number(prompt("Выбери число", ""));
alert("Твоё число – квадратный корень из " +
      theNumber * theNumber);
----

(((number,conversion to)))(((type coercion)))(((Number function)))(((String function)))(((Boolean function)))(((Boolean,conversion to)))Функция `Number` преобразовывает величину в число. Нам это нужно, потому что `prompt` возвращает строку. Есть сходные функции `String` и `Boolean`, преобразующие величины в соответствующие типы.

Простая схема прямого порядка исполнения программы:

image::img/controlflow-straight.svg[alt="Trivial control flow",width="4cm"]

== Условное выполнение ==

(((Boolean)))(((control flow)))Выполнять инструкции по порядку – не единственная возможность. В качестве альтернативы существует _((условное выполнение))_, где мы выбираем из двух возможных путей, основываясь на булевской величине:

image::img/controlflow-if.svg[alt="Conditional control flow",width="4cm"]

(((syntax)))(((Number function)))(((if keyword)))Условное выполнение записывается при помощи ключевого слова `if`. В простом случае нам нужно, чтобы некий код был выполнен, только если выполняется некое условие. К примеру, в предыдущей программе мы можем считать квадрат, только если было введено именно число.

[source,javascript]
----
var theNumber = Number(prompt("Выбери число", ""));
if (!isNaN(theNumber))
  alert("Твоё число – квадратный корень из " +
        theNumber * theNumber);
----

Теперь, введя “сыр”, вы не получите вывод.

Ключевое слово `if` выполняет или пропускает инструкцию, в зависимости от значения булевого выражения. Это выражение записывается после `if` в ((скобках)), и за ним идёт нужная инструкция.

(((isNaN function)))Функция `isNaN` – стандартная функция JavaScript, которая возвращает `true`, только если её аргумент – `NaN` (не число). Функция `Number` возвращает `NaN`, если задать ей строку, которая не представляет собой допустимое число. В результате, условие звучит так: “выполнить, если только `theNumber` не является не-числом”.

(((else keyword)))Часто нужно написать код не только для случая, когда выражение истинно, но и для случая, когда оно ложно. Путь с вариантами – это вторая стрелочка диаграммы. Ключевое слово `else` используется вместе с `if` для создания двух раздельных путей выполнения.

[source,javascript]
----
var theNumber = Number(prompt("Выбери число", ""));
if (!isNaN(theNumber))
  alert("Твоё число – квадратный корень из " +
        theNumber * theNumber);
else
  alert("Ну ты что число-то не ввёл?");
----

(((if keyword,chaining)))Если вам нужно больше разных путей, можно использовать несколько пар `if`/`else` по “цепочке”. Например:

[source,javascript]
----
var num = Number(prompt("Выбери число", "0"));

if (num < 10)
  alert("Маловато");
else if (num < 100)
  alert("Нормально");
else
  alert("Многовато");
----

Программа проверяет, действительно ли `num` меньше 10. Если да – выбирает эту ветку, и показывает `"Маловато"`. Если нет, выбирает другую – на которой ещё один `if`. Если следующее условие выполняется, значит номер будет между 10 и 100, и выводится `"Нормально"`. Если нет – значит, выполняется последняя ветка.

Последовательность выполнения примерно такая:

image::img/controlflow-nested-if.svg[alt="Nested if control flow",width="4cm"]

[[loops]]
== Циклы while и do ==

(((even number)))Представьте программу, выводящую все чётные числа от 0 до 12. Можно записать её так:

[source,javascript]
----
console.log(0);
console.log(2);
console.log(4);
console.log(6);
console.log(8);
console.log(10);
console.log(12);
----

(((control flow)))Это работает – но смысл программирования в том, чтобы работать _меньше_, чем компьютер, а не наоборот. Если б нам понадобились все числа до 1000, это решение было бы неприемлемым. Нам нужна возможность повторения. Этот вид контроля над порядком выполнения называется _((цикл))ом_.

image::img/controlflow-loop.svg[alt="Loop control flow",width="4cm"]

(((syntax)))(((counter variable)))Зацикливание даёт возможность вернуться назад к какой-то инструкции и повторить всё заново с новым состоянием программы. Если скомбинировать это с переменной для подсчёта, можно сделать следующее:

[source,javascript]
----
var number = 0;
while (number <= 12) {
  console.log(number);
  number = number + 2;
}
// → 0
// → 2
//   … и т.д.
----

(((while loop)))(((Boolean)))((Инструкция)), начинающаяся с ключевого слова `while` – это цикл. За `while` следует ((выражение)) в ((скобках)), и затем инструкция (тело цикла) – так же, как у `if`. Цикл выполняет инструкцию, пока выражение выдаёт истинный результат.

(((grouping)))((({} (block))))(((block)))В цикле нам нужно выводить значение и прибавлять к нему. Если нам нужно выполнять в цикле несколько ((инструкций)), мы заключаем его в ((фигурные скобки)) (`{` и `}`). Фигурные скобки для инструкций – как ((круглые скобки)) для выражений. Они группируют их и превращают в единое. Последовательность инструкций, заключённая в фигурные скобки, называется _блоком_.

(((programming style)))Многие программисты заключают любое тело цикла и условия `if` в скобки. Они делают это для единообразия, и для того, чтобы не нужно было добавлять и убирать скобки, если приходится изменять количество инструкций в цикле. В книге я не буду писать скобки вокруг единичных инструкций в цикле, так как люблю краткость. Вы можете делать, как угодно.

(((comparison)))(((state)))Переменная `number` показывает, как ((переменная)) может отслеживать прогресс программы. При каждом повторении цикла `number` увеличивается на `2`. Перед каждым повторением оно сравнивается с `12`, чтобы понять, сделала ли программа всё, что требовалось.

(((exponentiation)))Для примера более полезной работы мы можем написать программу вычисления 2 в 10 степени. Мы используем две переменные: одну для слежения за результатом, а вторую – для подсчёта количества умножений. Цикл проверяет, достигла ли вторая переменная 10, и затем обновляет обе.

[source,javascript]
----
var result = 1;
var counter = 0;
while (counter < 10) {
  result = result * 2;
  counter = counter + 1;
}
console.log(result);
// → 1024
----

Можно начинать counter с `1` и проверять его на `<= 10`, но по причинам, которые станут ясны в link:04_data.html#array_indexing[Глева 4], всегда лучше начинать счётчики с `0`.

(((loop body)))(((do loop)))(((control flow)))Цикл `do` похож на цикл `while`. Отличается только в одном: цикл `do` всегда выполняет тело хотя бы один раз, а проверяет условие после первого выполнения. Поэтому и тестируемое выражение записывают после тела цикла:

[source,javascript]
----
do {
  var yourName = prompt("Who are you?");
} while (!yourName);
console.log(yourName);
----

(((Boolean,conversion to)))(((! operator)))Эта программа заставляет ввести имя. Она спрашивает его снова и снова, пока не получит что-то кроме пустой строки. Добавление `!` превращает значение в булевское и затем применяет логическое отрицание, а все строки, кроме пустой, преобразуются в булевское `true`.

== Indenting Code ==

(((block)))(((code structure)))(((whitespace)))(((programming style)))Вы, наверно, заметили пробелы перед некоторыми инструкциями. В JavaScript это не обязательно – программа отработает и без них. Даже переводы ((строк)) не обязательно делать. Можно написать программу в одну строку. Роль ((отступ))ов в блоках – отделять их от остальной программы. В сложном коде, где в блоках встречаются другие блоки, может быть сложно разглядеть, где кончается один и начинается другой. Правильно отделяя их пробелами вы приводите в соответствие внешний вид кода и его блоки. Я люблю отделять каждый блок двумя пробелами, но вкусы различаются – некоторые используют четыре, некоторые – ((табуляцию)).

== Циклы for ==

(((syntax)))(((while loop)))(((counter variable)))Много циклов строятся по такому шаблону, как в примере. Создаётся “переменная-счётчик”, потом идёт цикл `while`, где проверочное выражение обычно проверяет, не достигли ли мы какой-нибудь границы. В конце тела цикла счётчик обновляется.

(((for loop)))(((loop)))Поскольку это такой частый случай, в JavaScript есть вариант покороче, цикл `for`.

[source,javascript]
----
for (var number = 0; number <= 12; number = number + 2)
  console.log(number);
// → 0
// → 2
//   … и т.д.
----

(((control flow)))(((state)))Эта программа эквивалентна link:02_program_structure.html#loops[предыдущей]. Только теперь все ((инструкции)), относящиеся к отслеживанию “состояния” цикла, сгруппированы.

((Скобки)) после `for` содержат две ((точки с запятой)), разделяя инструкцию на три части. Первая _инициализирует_ цикл, обычно задавая начальное значение ((переменной)). Вторая – ((выражение)) _проверки_ необходимости продолжения цикла. Третья – _обновляет_ состояние после каждого прохода. В большинстве случаев такая запись более короткая и понятная, чем `while`.

(((exponentiation)))Вычисляем 2^10^ при помощи `for` вместо `while`:

[source,javascript]
----
var result = 1;
for (var counter = 0; counter < 10; counter = counter + 1)
  result = result * 2;
console.log(result);
// → 1024
----

(((programming style)))(((indentation)))Хотя я не писал фигурных скобок, я отделяю тело цикла пробелами.

== Выход из цикла ==

(((loop,termination of)))(((break keyword)))Дождаться, пока условие цикла не станет ложным – не единственный способ закончить цикл. Специальная инструкция `break` приводит к немедленному выходу из цикла.

В следующем примере мы покидаем цикл, когда находим число, большее чем 20 или равное ему и делящееся на 7 без остатка.

[source,javascript]
----
for (var current = 20; ; current++) {
  if (current % 7 == 0)
    break;
}
console.log(current);
// → 21
----

(((remainder operator)))(((% operator)))Использование остатка от деления (`%`) - простой способ проверить делимость. Одно число делится на другое, если остаток от их деления равен нулю.

(((for loop)))Конструкция `for` не имеет проверочной части – поэтому цикл не остановится, пока не сработает инструкция `break`.

Если вы не укажете эту инструкцию, или случайно напишете условие, которое всегда выполняется, программа зависнет в _((бесконечном цикле))_ и никогда не закончит работу – обычно это плохо.

ifdef::interactive_target[]

Если вы сделаете бесконечный цикл, обычно через несколько секунд среда исполнения предложит вам прервать его. Если нет, вам придётся закрыть закладку, или даже весь браузер.

endif::interactive_target[]

(((continue keyword)))Ключевое слово `continue` также влияет на исполнение цикла. Когда это слово встречается в цикле, он немедленно переходит на следующую итерацию.

== Короткое обновление переменных ==

(((assignment)))(((+= operator)))(((-= operator)))(((/= operator)))(((*= operator)))(((state)))(((side effect)))Особенно часто в циклах программе нужно “обновить” переменную, основываясь на её предыдущем состоянии.

// test: no

[source,javascript]
----
counter = counter + 1;
----

В JavaScript есть для этого короткая запись:

// test: no

[source,javascript]
----
counter += 1;
----

Подобные записи работают для многих других операторов, к примеру `result *= 2` для удвоения, или `counter -= 1` для обратного отсчёта.

Это позволяет нам сократить программу вывода чётных чисел.

[source,javascript]
----
for (var number = 0; number <= 12; number += 2)
  console.log(number);
----

(((++ operator)))(((-- operator)))Для `counter += 1` и `counter -= 1` есть ещё более короткие записи: `counter++` and `counter--`.

== Работаем с переменными при помощи switch ==

(((syntax)))(((conditional execution)))(((dispatching)))(((if keyword,chaining)))Часто код выглядит так:

// test: no

[source,javascript]
----
if (variable == "value1") action1();
else if (variable == "value2") action2();
else if (variable == "value3") action3();
else defaultAction();
----

(((colon character)))(((switch keyword)))Существует конструкция под названием `switch`, которая упрощает подобную запись. К сожалению, синтаксис JavaScript в этом случае довольно странный – часто цепочка `if`/`else` выглядит лучше. Пример:

[source,javascript]
----
switch (prompt("Как погодка?")) {
  case "дождь":
    console.log("Не забудь зонт.");
    break;
  case "снег":
    console.log("Блин, мы в России!");
    break;
  case "солнечно":
    console.log("Оденься полегче.");
  case "облачно":
    console.log("Иди гуляй.");
    break;
  default:
    console.log("Непонятная погода!");
    break;
}
----

(((fallthrough)))(((comparison)))(((break keyword)))(((case keyword)))(((default keyword)))В блок `switch` можно поместить любое количество меток `case`. Программа перепрыгивает на метку, соответствующую значению переменной в `switch`, или на метку `default`, если подходящих меток не найдено. После этого инструкции исполняются до первой инструкции `break` – даже если мы уже прошли другую метку. Иногда это можно использовать для исполнения одного и того же кода в разных случаях (в обоих случаях `"солнечно"` и `"облачно"` программа порекомендует пойти погулять). Однако, очень легко забыть запись `break`, что приведёт к выполнению нежелательного участка кода.

== Регистр имён ==

(((capitalization)))(((variable,naming)))(((whitespace)))Имена переменных не могут содержать пробелы, однако часто удобно использовать несколько слов для понятного описания переменной. Вы можете выбирать из нескольких вариантов:

----
fuzzylittleturtle
fuzzy_little_turtle
FuzzyLittleTurtle
fuzzyLittleTurtle
----

(((camel case)))(((programming style)))(((underscore character)))Первый довольно сложно читать. Мне нравятся подчёркивания, хотя их не очень удобно печатать. ((Стандарт))ные функции JavaScript и большинство программистов используют последний вариант – каждое слово с большой буквы, кроме первого.

(((Number function)))(((constructor)))В некоторых случаях, например в случае функции `Number`, первую букву тоже пишут большой – когда нужно выделить функцию как конструктор. О конструкторах мы поговорим в link:06_object.html#constructors[Главе 6]. Сейчас просто не обращайте на это внимания.

== Комментарии ==

(((readability)))Часто код не содержит всю информацию, которую хотелось бы передать читателям-людям, или доносит её в непонятном виде. Иногда вы чувствуете поэтическое вдохновение, или просто хотите поделиться мыслями в своей программе. Для этого служат _((комментарии))_.

(((slash character)))(((line comment)))Комментарий – это текст, который записан в программе, но игнорируется компьютером. В JavaScript комментарии можно писать двумя способами. Для однострочного комментария можно использовать два слеша (`//`).

// test: no

[source,javascript]
----
var accountBalance = calculateBalance(account);
// Издалека долго
accountBalance.adjust();
// Течёт река Волга
var report = new Report();
// Течёт река Волга
addToReport(accountBalance, report);
// Конца и края нет
----

(((block comment)))Однострочный комментарий продолжается только до конца строки. Код между символами `/*` и `*/` будет игнорироваться вместе с возможными переводами строки. Это подходит для включения целых информационных блоков в программу:

[source,javascript]
----
/*
 Этот город – самый лучший
 Город на Земле.
 Он как будто нарисован
 Мелом на стене.
*/
var myCity = "Челябинск";
----

== Итог ==

Теперь вы знаете, что программа состоит из инструкций, которые сами могут содержать инструкции. В инструкциях содержатся выражения, которые могут состоять из выражений.

Записывая инструкции подряд, мы получаем программу, которая выполняется сверху вниз. Вы можете изменять этот поток выполнения, используя условные (`if`, `else`, и `switch`) операторы и операторы цикла (`while`, `do`, и `for`).

Переменные можно использовать для хранения кусочков данных под определённым названием и для отслеживания состояния программы. Окружение – набор определённых переменных. Системы, исполняющие JavaScript, всегда добавляют несколько стандартных переменных в ваше окружение.

Функции – особые переменные, включающие части программы. Их можно вызвать командой `functionName(argument1, argument2)`. Такой вызов – это выражение, и может выдавать значение.

== Упражнения ==

(((exercises)))Если вы не знаете, как приступить к решению упражнений, обратитесь к link:00_intro.html#intro[введению].

Каждое упражнение начинается с описания задачи. Прочтите и постарайтесь выполнить. В сложных ситуациях обращайтесь к подсказкам (!interactive после упражнения!)(!book в link:hints.html#hints[конце книги]!). Готовые решения задач можно найти на сайте книги http://eloquentjavascript.net/2nd_edition/code[_eloquentjavascript.net/code_]. Чтобы обучение было эффективным, не заглядывайте в ответы, пока не решите задачу сами, или хотя бы не попытаетесь её решить достаточно долго для того, чтобы у вас слегка заболела голова. Там же можно писать код прямо в браузере и выполнять его.

=== Треугольник в цикле ===

(((triangle (exercise))))Напишите ((цикл)), который за 7 вызовов `console.log` выводит такой треугольник:

----
#
##
###
####
#####
######
#######
----

Будет полезно знать, что длину строки можно узнать, приписав к переменной `.length`.

[source,javascript]
----
var abc = "abc";
console.log(abc.length);
// → 3
----

ifdef::interactive_target[]

Most exercises contain a piece of code that you can modify to solve
the exercise. Remember that you can click code blocks to edit them.

[source,javascript]
----
// Your code here.
----
endif::interactive_target[]

!!hint!!

(((triangle (exercise))))You can start with a program that simply
prints out the numbers 1 to 7, which you can derive by making a few
modifications to the
link:02_program_structure.html#loops[even number printing example]
given earlier in the chapter, where the `for` loop was introduced.

Now consider the equivalence between numbers and strings of hash
characters. You can go from 1 to 2 by adding 1 (`+= 1`). You can go
from `"#"` to `"##"` by adding a character (`+= "#"`). Thus, your
solution can closely follow the number-printing program.

!!hint!!

=== FizzBuzz ===

(((FizzBuzz (exercise))))(((loop)))(((conditional execution)))Напишите программу, которая выводит через `console.log` все цифры от 1 до 100, с двумя исключениями. Для чисел, нацело делящихся на 3, она должна выводить `"Fizz"`, а для чисел, делящихся на 5 (но не на 3) – `"Buzz"`.

Когда сумеете – исправьте её так, чтобы она выводила `"FizzBuzz"` для всех чисел, которые делятся и на 3 и на 5.

(На самом деле, этот вопрос подходит для ((собеседований)), и говорят, он позволяет отсеивать довольно большое число кандидатов. Поэтому, когда вы решите эту задачу, можете себя похвалить)

ifdef::interactive_target[]
[source,javascript]
----
// Your code here.
----
endif::interactive_target[]

!!hint!!

(((FizzBuzz (exercise))))(((remainder operator)))(((% operator)))Going
over the numbers is clearly a looping job, and selecting what to print
is a matter of conditional execution. Remember the trick of using the
remainder (`%`) operator for checking whether a number is divisible by
another number (has a remainder of zero).

In the first version, there are three possible outcomes for every
number, so you'll have to create an `if`/`else if`/`else` chain.

(((|| operator)))(((if keyword,chaining)))The second version of the
program has a straightforward solution and a clever one. The simple
way is to add another “branch” to precisely test the given condition.
For the clever method, build up a string containing the word or words
to output, and print either this word or the number if there is no
word, potentially by making elegant use of the `||` operator.

!!hint!!

=== Шахматная доска ===

(((chess board (exercise))))(((loop)))(((nesting,of loops)))(((newline character)))Напишите программу, создающую строку, содержащую решётку 8х8, в которой линии разделяются символами новой строки. На каждой позиции либо пробел, либо “#”. В результате должна получиться шахматная доска.

Передача этой строки в `console.log` должна показать что-то вроде этого:

----
 # # # #
# # # # 
 # # # #
# # # # 
 # # # #
# # # # 
 # # # #
# # # # 
----

Когда справитесь, определите ((переменную)) `size = 8`, чтобы можно было создавать доски любого размера.

ifdef::interactive_target[]
[source,javascript]
----
// Your code here.
----
endif::interactive_target[]

!!hint!!

(((chess board (exercise))))The string can be built by starting with
an empty one (`""`) and repeatedly adding characters. A newline
character is written `"\n"`.

Use `console.log` to inspect the output of your program.

(((nesting,of loops)))To work with two ((dimensions)), you will need a
((loop)) inside of a loop. Put ((curly braces)) around the bodies of
both loops to make it easy to see where they start and end. Try to
properly indent these bodies. The order of the loops must follow the
order in which we build up the string (line by line, left to right,
top to bottom). So the outer loop handles the lines and the inner loop
handles the characters on a line.

(((counter variable)))(((remainder operator)))(((% operator)))You'll
need two variables to track your progress. To know whether to put a
space or a hash sign at a given position, you could test whether the
sum of the two counters is even (`% 2`).

Terminating a line by adding a newline character happens after the
line has been built up, so do this after the inner loop but inside of
the outer loop.

!!hint!!
